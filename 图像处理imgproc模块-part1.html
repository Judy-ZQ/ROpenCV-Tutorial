<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>6 图像处理（imgproc模块-PART1） | ROpenCV — R与OpenCV之间的桥梁</title>
<meta name="author" content="zpy">
<meta name="generator" content="bookdown 0.40 with bs4_book()">
<meta property="og:title" content="6 图像处理（imgproc模块-PART1） | ROpenCV — R与OpenCV之间的桥梁">
<meta property="og:type" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="6 图像处理（imgproc模块-PART1） | ROpenCV — R与OpenCV之间的桥梁">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.8.0/transition.js"></script><script src="libs/bs3compat-0.8.0/tabs.js"></script><script src="libs/bs3compat-0.8.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-141212623-1"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-141212623-1');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<meta name="description" content="6.1 灰度化 通常使用如下公式实现三通道彩色图形的灰度化： \[ Y = 0.11 \times B+0.59 \times G+0.3 \times R \] 其中：\(B\)、\(G\)和\(R\)分别表示彩色图像的蓝色、绿色和红色分量矩阵。 set.seed(123) img_arr = array(sample(0:9,27,replace=TRUE),dim=c(3,3,3))...">
<meta property="og:description" content="6.1 灰度化 通常使用如下公式实现三通道彩色图形的灰度化： \[ Y = 0.11 \times B+0.59 \times G+0.3 \times R \] 其中：\(B\)、\(G\)和\(R\)分别表示彩色图像的蓝色、绿色和红色分量矩阵。 set.seed(123) img_arr = array(sample(0:9,27,replace=TRUE),dim=c(3,3,3))...">
<meta name="twitter:description" content="6.1 灰度化 通常使用如下公式实现三通道彩色图形的灰度化： \[ Y = 0.11 \times B+0.59 \times G+0.3 \times R \] 其中：\(B\)、\(G\)和\(R\)分别表示彩色图像的蓝色、绿色和红色分量矩阵。 set.seed(123) img_arr = array(sample(0:9,27,replace=TRUE),dim=c(3,3,3))...">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">ROpenCV — R与OpenCV之间的桥梁</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">前言</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> 简介</a></li>
<li><a class="" href="RBasis.html"><span class="header-section-number">2</span> R基础</a></li>
<li><a class="" href="imagebasis.html"><span class="header-section-number">3</span> OpenCV中的图像矩阵类（Mat）</a></li>
<li><a class="" href="%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html"><span class="header-section-number">4</span> 图像基本操作</a></li>
<li><a class="" href="%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">5</span> 核心功能（核心模块）</a></li>
<li><a class="active" href="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86imgproc%E6%A8%A1%E5%9D%97-part1.html"><span class="header-section-number">6</span> 图像处理（imgproc模块-PART1）</a></li>
<li><a class="" href="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86imgproc%E6%A8%A1%E5%9D%97-part2.html"><span class="header-section-number">7</span> 图像处理（imgproc模块-PART2）</a></li>
<li><a class="" href="%E6%91%84%E5%83%8F%E6%9C%BA%E6%A0%87%E5%AE%9A%E5%92%8C%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BAcalib3d%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">8</span> 摄像机标定和三维重建（calib3d模块）</a></li>
<li><a class="" href="d%E7%89%B9%E5%BE%81%E6%A1%86%E6%9E%B6feature2d%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">9</span> 2D特征框架（feature2d模块）</a></li>
<li><a class="" href="%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91io%E4%BB%A5%E5%8F%8Avideo%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">10</span> 视频处理（视频IO以及Video模块）</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/Judy-ZQ/ROpenCV-Tutorial">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="图像处理imgproc模块-part1" class="section level1" number="6">
<h1>
<span class="header-section-number">6</span> 图像处理（imgproc模块-PART1）<a class="anchor" aria-label="anchor" href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86imgproc%E6%A8%A1%E5%9D%97-part1"><i class="fas fa-link"></i></a>
</h1>
<div id="灰度化" class="section level2" number="6.1">
<h2>
<span class="header-section-number">6.1</span> 灰度化<a class="anchor" aria-label="anchor" href="#%E7%81%B0%E5%BA%A6%E5%8C%96"><i class="fas fa-link"></i></a>
</h2>
<p>通常使用如下公式实现三通道彩色图形的灰度化：</p>
<p><span class="math display">\[
Y = 0.11 \times B+0.59 \times G+0.3 \times R
\]</span>
其中：<span class="math inline">\(B\)</span>、<span class="math inline">\(G\)</span>和<span class="math inline">\(R\)</span>分别表示彩色图像的蓝色、绿色和红色分量矩阵。</p>
<div class="sourceCode" id="cb834"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html">array</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">9</span>,<span class="fl">27</span>,replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>,dim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">0.11</span><span class="op">*</span><span class="va">img_arr</span><span class="op">[</span>,,<span class="fl">1</span><span class="op">]</span><span class="op">+</span><span class="fl">0.59</span><span class="op">*</span><span class="va">img_arr</span><span class="op">[</span>,,<span class="fl">2</span><span class="op">]</span><span class="op">+</span><span class="fl">0.3</span><span class="op">*</span><span class="va">img_arr</span><span class="op">[</span>,,<span class="fl">3</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    7    5    3
## [2,]    5    6    6
## [3,]    5    5    9</code></pre>
<p>利用OpenCV封装的<strong>cvtColor</strong>函数可以把三通道彩色图像转变为（单通道）灰度图：</p>
<div class="sourceCode" id="cb836"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定随机数种子</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html">array</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">9</span>,<span class="fl">27</span>,replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>,dim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#利用r2cv函数将img.arr转变为图形矩阵</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_arr</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span></span>
<span><span class="co">#利用cvtColor函数，指定颜色转变代码COLOR_BGR2GRAY，对img进行灰度化，</span></span>
<span><span class="co">#灰度化结果保存在gray中</span></span>
<span><span class="va">gray</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">img</span>,<span class="va">gray</span>,<span class="va">COLOR_BGR2GRAY</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看灰度化结果</span></span>
<span><span class="va">gray</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    7    5    3
## [2,]    5    6    6
## [3,]    5    5    9
## attr(,"depth")
## [1] 0</code></pre>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb838"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件，读取结果保存在img中</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span><span class="co">#用cvtColor函数将图像转变为灰度图，结果保存在gray中</span></span>
<span><span class="va">gray</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">img</span>,<span class="va">gray</span>,<span class="va">COLOR_BGR2GRAY</span><span class="op">)</span></span>
<span><span class="co">#显示灰度化结果</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"灰度化结果"</span>,<span class="va">gray</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-5-1.png" width="672"></div>
</div>
<div id="尺寸变换" class="section level2" number="6.2">
<h2>
<span class="header-section-number">6.2</span> 尺寸变换<a class="anchor" aria-label="anchor" href="#%E5%B0%BA%E5%AF%B8%E5%8F%98%E6%8D%A2"><i class="fas fa-link"></i></a>
</h2>
<p>OpenCV的<strong>resize</strong>函数可以更改图像尺寸：</p>
<div class="sourceCode" id="cb839"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/roi.jpg"</span><span class="op">)</span></span>
<span><span class="co">#获取图形基本信息</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过指定横向、纵向的缩放系数将img的宽度和高度都放大2倍，结果保存在img_resize22中</span></span>
<span><span class="va">img_resize22</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_resize</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_resize22</span>,<span class="fu">Size</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'img'</span>,<span class="va">img_resize22</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过指定目标图像的尺寸将img的宽度放大2倍，高度放大3倍，结果保存在img_resize23中</span></span>
<span><span class="va">img_resize23</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_resize</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_resize23</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">img_info</span><span class="op">$</span><span class="va">width</span>,<span class="fl">3</span><span class="op">*</span><span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'img'</span>,<span class="va">img_resize23</span><span class="op">)</span></span></code></pre></div>
<p>OpenCV在更改图像尺寸的过程中，会涉及插值操作，而目前封装的插值方法有：</p>
<pre><code>##  [1] "INTER_AREA"          "INTER_CUBIC"         "INTER_LANCZOS4"     
##  [4] "INTER_LINEAR"        "INTER_LINEAR_EXACT"  "INTER_MAX"          
##  [7] "INTER_NEAREST"       "INTER_NEAREST_EXACT" "WARP_FILL_OUTLIERS" 
## [10] "WARP_INVERSE_MAP"    "WARP_RELATIVE_MAP"</code></pre>
<p>以下代码演示了INTER_CUBIC插值方法的应用效果：</p>
<div class="sourceCode" id="cb841"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/HappyFish.jpg"</span><span class="op">)</span></span>
<span><span class="co">#获取图形基本信息</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过指定横向、纵向的缩放系数将img的宽度和高度都放大2倍，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_resize</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="fu">Size</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span>,<span class="fl">2</span>,<span class="va">INTER_CUBIC</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示原始图像和放大图像</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"原图"</span>,<span class="va">img</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"cubic插值放大图"</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<p>一般而言，OpenCV使用<strong>resize</strong>函数缩小图像时，采用INTER_AREA插值方法，在放大图像时，则采用INTER_CUBIC插值方法（速度较慢）或者INTER_LINEAR（速度较快）插值方法。</p>
<p><strong>示例</strong></p>
<p>以下代码用滑动条控制图像的放大系数，可以动态观察图像放大效果。</p>
<div class="sourceCode" id="cb842"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#控制图像放大系数的滑动条的最大取值为3</span></span>
<span><span class="va">max_size</span> <span class="op">=</span> <span class="fl">3</span></span>
<span><span class="co">#将图形窗口的标题存放在window_name中</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"resize demo"</span></span>
<span></span>
<span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/HappyFish.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#定义滑动条滑动事件的响应函数imgResize</span></span>
<span><span class="va">imgResize</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">param</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#获取图像放大系数的的滑动条的当前取值并加1后，存入sz中</span></span>
<span>  <span class="va">sz</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"Ratio:"</span>, <span class="va">window_name</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>  </span>
<span>  <span class="co">#通过指定横向、纵向的缩放系数将img的宽度和高度都放大2倍，</span></span>
<span>  <span class="co">#插值方式选择INTER_CUBIC，</span></span>
<span>  <span class="co">#结果保存在dst中</span></span>
<span>  <span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_resize</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="fu">Size</span><span class="op">(</span><span class="op">)</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">INTER_CUBIC</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#将dst显示在window_name指定的标题的图形窗口中</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">dst</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#创建以window_name取值为标题的图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#在图形窗口中创建控制Canny算子下阈值的滑动条（滑动条的位置先至于1处）</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"Ratio:"</span>,<span class="va">window_name</span>,<span class="fl">1</span>,<span class="va">max_size</span>,<span class="va">imgResize</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#调用imgResize函数</span></span>
<span><span class="fu">imgResize</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/resizedemo.png" width="70%" style="display: block; margin: auto;"></div>
</div>
<div id="仿射变换" class="section level2" number="6.3">
<h2>
<span class="header-section-number">6.3</span> 仿射变换<a class="anchor" aria-label="anchor" href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><i class="fas fa-link"></i></a>
</h2>
<p>仿射变换是一种线性变换，可以保持二维图形在变换前后的“平直性”和“平行性”，即直线经过变换之后仍然是直线，两条平行线经变换之后仍然是平行线。</p>
<p>仿射变换的公式为：</p>
<p><span class="math display">\[
\begin{aligned}
x&amp;=au+bv+m \\
y&amp;=cu+dv+n
\end{aligned}
\]</span></p>
<p>其中，<span class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>为仿射变换前的二维图形中某点的横、纵坐标，<span class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>则是该点经仿射变换后得到的新的横、纵坐标。</p>
<p>写成矩阵形式为：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x \\
y
\end{matrix}
\right]
=
\left[
\begin{matrix}
a&amp;b&amp;m \\
c&amp;d&amp;n
\end{matrix}
\right]
\left[
\begin{matrix}
u \\
v \\
1
\end{matrix}
\right]
\]</span></p>
<p>其中：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
a&amp;b&amp;m \\
c&amp;d&amp;n
\end{matrix}
\right]
\]</span>
就是仿射矩阵。</p>
<p>在OpenCV中，可以通过<strong>getAffineTransform</strong>函数计算三对不共线的对应点 — 即两组控点，每组控点个数为3个 — 所确定的仿射变换，比如：</p>
<div class="sourceCode" id="cb843"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#先确定一组控点（用列表pts1来表示这组控点的坐标）</span></span>
<span><span class="va">pts1</span> <span class="op">=</span> <span class="fu">stdVecOfPoint2f</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">50</span>,<span class="fl">50</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">50</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">50</span>,<span class="fl">200</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#再确定另一组对应的控点（用列表pts2来表示其中的三点的坐标）</span></span>
<span><span class="va">pts2</span> <span class="op">=</span> <span class="fu">stdVecOfPoint2f</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">100</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">50</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">250</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#依据pts1和pts2计算仿射矩阵M</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">cv_getAffineTransform</span><span class="op">(</span><span class="va">pts1</span>,<span class="va">pts2</span><span class="op">)</span></span>
<span><span class="co">#查看M的元素值</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">M</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code>##        [,1] [,2]    [,3]
## [1,]  1.267  0.6 -83.333
## [2,] -0.333  1.0  66.667
## attr(,"depth")
## [1] 6</code></pre>
<p>两组控点形成的位置关系如下：</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-17-1.png" width="672"></div>
<p>仿射矩阵<span class="math inline">\(M\)</span>的求解方式实质上就是求解方程组：</p>
<p>将蓝色点1的横、纵坐标(u,v)和对应的红色点1的横纵坐标(x,y)代入仿射变换公式，就可以得到两个方程；同理，将蓝色点2、3的横、纵坐标(u,v)和对应的红色点2、3的横纵坐标(x,y)代入公式，又可以分别得到两个方程。这样一来，就会形成一个包含6个方程的方程组：</p>
<p><span class="math display">\[
\begin{cases}
50a + 50b + m+0c+0d+0n = 10 \\
0a+0b+0m+50c + 50d + n = 100 \\
200a + 50b + m+0c+0d+0n = 200 \\
0a+0b+0m+200c + 50d + n = 50 \\
50a + 200b + m+0c+0d+0n = 100 \\
0a+0b+0m+50c + 200d + n = 250
\end{cases}
\]</span></p>
<p>由于三个蓝色点不共线（且经仿射变换后，相应的三个红色点也不共线），所以通过6个方程形成的方程组，就可以确定a、b、c、d、m和n的唯一解，进而也就确立了仿射矩阵。</p>
<div class="sourceCode" id="cb845"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#方程组的系数矩阵</span></span>
<span><span class="va">A</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">50</span>,<span class="fl">50</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,</span>
<span>             <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">50</span>,<span class="fl">50</span>,<span class="fl">1</span>, </span>
<span>             <span class="fl">200</span>,<span class="fl">50</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,</span>
<span>             <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">200</span>,<span class="fl">50</span>,<span class="fl">1</span>, </span>
<span>             <span class="fl">50</span>,<span class="fl">200</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,</span>
<span>             <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">50</span>,<span class="fl">200</span>,<span class="fl">1</span><span class="op">)</span>,</span>
<span>           nr<span class="op">=</span><span class="fl">6</span>,nc<span class="op">=</span><span class="fl">6</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="co">#方程组各等式右边的值所形成的向量</span></span>
<span><span class="va">B</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>,<span class="fl">100</span>,<span class="fl">200</span>,<span class="fl">50</span>,<span class="fl">100</span>,<span class="fl">250</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#求解方程组</span></span>
<span><span class="va">sol</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html">solve</a></span><span class="op">(</span><span class="va">A</span>,<span class="va">B</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">sol</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">'a'</span>,<span class="st">'b'</span>,<span class="st">'m'</span>,<span class="st">'c'</span>,<span class="st">'d'</span>,<span class="st">'n'</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">sol</span>,<span class="fl">3</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">2</span>,nc<span class="op">=</span><span class="fl">3</span>,byrow<span class="op">=</span><span class="cn">T</span><span class="op">)</span></span></code></pre></div>
<pre><code>##        [,1] [,2]    [,3]
## [1,]  1.267  0.6 -83.333
## [2,] -0.333  1.0  66.667</code></pre>
<p>另外，也可以直接使用<strong>getRotationMatrix2D</strong>函数得到仿射矩阵。比如可以生成一个只是将图像放大2倍的仿射变换矩阵：</p>
<div class="sourceCode" id="cb847"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用getRotationMatrix2D函数：</span></span>
<span><span class="co">#旋转中心为(0,0)点，</span></span>
<span><span class="co">#旋转角度为0度（即不旋转）,</span></span>
<span><span class="co">#缩放因子为2</span></span>
<span><span class="va">warp</span> <span class="op">=</span> <span class="fu">cv_getRotationMatrix2D</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">0</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">warp</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2    0    0
## [2,]    0    2    0
## attr(,"depth")
## [1] 6</code></pre>
<p>或者生成一个只是将图像旋转45度的仿射变换矩阵：</p>
<div class="sourceCode" id="cb849"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用getRotationMatrix2D函数：</span></span>
<span><span class="co">#旋转中心为(0,0)点，</span></span>
<span><span class="co">#旋转角度为45度,</span></span>
<span><span class="co">#缩放因子为0</span></span>
<span><span class="va">warp</span> <span class="op">=</span> <span class="fu">cv_getRotationMatrix2D</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">45</span>,<span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">warp</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##            [,1]      [,2] [,3]
## [1,]  0.7071068 0.7071068    0
## [2,] -0.7071068 0.7071068    0
## attr(,"depth")
## [1] 6</code></pre>
<p>再或者生成一个以100行100列像素为旋转中心，旋转角度为30，缩放因子为0.5的仿射变换矩阵：</p>
<div class="sourceCode" id="cb851"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用getRotationMatrix2D函数：</span></span>
<span><span class="co">#旋转中心为(99,99)点，</span></span>
<span><span class="co">#旋转角度为30度,</span></span>
<span><span class="co">#缩放因子为0.5</span></span>
<span><span class="va">warp</span> <span class="op">=</span> <span class="fu">cv_getRotationMatrix2D</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">99</span>,<span class="fl">99</span><span class="op">)</span>,<span class="fl">30</span>,<span class="fl">0.5</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">warp</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code>##        [,1]  [,2] [,3]
## [1,]  0.433 0.250    0
## [2,] -0.250 0.433    0
## attr(,"depth")
## [1] 6</code></pre>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb853"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">bayer</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/bayer.png"</span><span class="op">)</span></span>
<span><span class="co">#获得图像矩阵的行数、列数和通道数</span></span>
<span><span class="va">rows_</span> <span class="op">=</span> <span class="va">bayer</span><span class="op">$</span><span class="va">rows</span></span>
<span><span class="va">cols_</span> <span class="op">=</span> <span class="va">bayer</span><span class="op">$</span><span class="va">cols</span></span>
<span><span class="va">cns_</span> <span class="op">=</span> <span class="va">bayer</span><span class="op">$</span><span class="fu">channels</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#形成两个点坐标列表pts1和pts2</span></span>
<span><span class="va">pts1</span> <span class="op">=</span> <span class="fu">stdVecOfPoint2f</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">50</span>,<span class="fl">50</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">50</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">50</span>,<span class="fl">200</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># pts2 = list(c(10,100),c(200,50),c(100,250))</span></span>
<span><span class="va">pts2</span> <span class="op">=</span> <span class="fu">stdVecOfPoint2f</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">100</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">50</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">250</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#依据pts1和pts2计算仿射矩阵M</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">cv_getAffineTransform</span><span class="op">(</span><span class="va">pts1</span>,<span class="va">pts2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#基于M对bayer进行仿射变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpAffine</span><span class="op">(</span><span class="va">bayer</span>,<span class="va">dst</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">cols_</span>,<span class="va">rows_</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示bayer和dst</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'ori'</span>,<span class="va">bayer</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'affine'</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-23-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>当仿射矩阵为如下形式时：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
a&amp;0&amp;0 \\
0&amp;d&amp;0
\end{matrix}
\right]
\]</span></p>
<p>其作用为：将图像在水平方向和垂直方向上分别缩放<span class="math inline">\(a\)</span>倍和<span class="math inline">\(d\)</span>倍。比如，当<span class="math inline">\(a=d=2\)</span>时，原图像第3行第3列位置的像素在目标像素的位置为：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x \\
y
\end{matrix}
\right]
=
\left[
\begin{matrix}
2&amp;0&amp;0 \\
0&amp;2&amp;0
\end{matrix}
\right]
\left[
\begin{matrix}
2 \\
2 \\
1
\end{matrix}
\right] =
\left[
\begin{matrix}
4 \\
4
\end{matrix}
\right]
\]</span></p>
<p>即在仿射变换<span class="math inline">\(\displaystyle \left[\begin{matrix}2&amp;0&amp;0 \\ 0&amp;2&amp;0 \end{matrix}\right]\)</span>下，原图像第3行第3列位置的像素会成为目标图像的第5行第5列位置的像素。这个结论可以通过如下代码来验证：</p>
<div class="sourceCode" id="cb854"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">9</span><span class="op">:</span><span class="fl">1</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将矩阵第3行第3列的元素更改为134，便于观察结果</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">]</span> <span class="op">=</span> <span class="fl">134</span></span>
<span><span class="co">#将img_mat转变为图像矩阵</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成仿射变换矩阵</span></span>
<span><span class="va">M_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">0</span>,<span class="fl">0</span>, <span class="fl">0</span>,<span class="fl">2</span>,<span class="fl">0</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">2</span>,nc<span class="op">=</span><span class="fl">3</span>,byrow<span class="op">=</span><span class="cn">T</span><span class="op">)</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">M_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">M</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">M</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">M_mat</span><span class="op">)</span></span>
<span><span class="co">#对img进行仿射变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpAffine</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">6</span>,<span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]    9    8    6    5    3    2
## [2,]    9    7    6    4    3    1
## [3,]    8    7    5    4    2    1
## [4,]    8    6    5   36   68   34
## [5,]    7    6    4   69  134   67
## [6,]    4    3    2   35   67   34
## attr(,"depth")
## [1] 0</code></pre>
<p><strong>示例</strong></p>
<p>当仿射矩阵为如下形式时：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
1&amp;0&amp;m \\
0&amp;1&amp;n
\end{matrix}
\right]
\]</span>
其作用为：将图像在水平方向和垂直方向上移动m和n个单位（像素）。</p>
<div class="sourceCode" id="cb856"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/HappyFish.jpg"</span><span class="op">)</span></span>
<span><span class="co">#获取图像矩阵的行数和列数</span></span>
<span><span class="co"># c(rows,cols) %&lt;-% c(img.cls$rows,img.cls$cols)</span></span>
<span><span class="va">rows_</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="va">rows</span></span>
<span><span class="va">cols_</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="va">cols</span></span>
<span><span class="co">#生成数组arr</span></span>
<span><span class="va">arr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html">array</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,dim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#查看arr</span></span>
<span><span class="va">arr</span></span></code></pre></div>
<pre><code>## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    0  100
## [2,]    0    1  100</code></pre>
<div class="sourceCode" id="cb858"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#将arr转变为32浮点类型的图像矩阵M</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">arr</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">M</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">M</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">arr</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#基于M对img进行仿射变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpAffine</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">cols_</span>,<span class="va">rows_</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示img和dst</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'ori'</span>,<span class="va">img</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'affine'</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-26-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>当仿射矩阵为如下形式时：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
cos(\theta)&amp;sin(\theta)&amp;m \\
-sin(\theta)&amp;cos(\theta)&amp;n
\end{matrix}
\right]
\]</span>
其作用为：将图像旋转<span class="math inline">\(\theta\)</span>角度，并在水平方向和垂直方向上移动m和n个单位（像素）。</p>
<div class="sourceCode" id="cb859"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/roi.jpg"</span><span class="op">)</span></span>
<span><span class="co">#获取图像矩阵的行数和列数</span></span>
<span><span class="va">rows_</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="va">rows</span></span>
<span><span class="va">cols_</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="va">cols</span></span>
<span><span class="co">#确定旋转角度（角度为负数，表示是逆时针旋转）</span></span>
<span><span class="va">theta</span> <span class="op">=</span> <span class="op">-</span><span class="va">pi</span><span class="op">/</span><span class="fl">4</span></span>
<span><span class="co">#生成数组arr</span></span>
<span><span class="va">arr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html">array</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">theta</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/Trig.html">sin</a></span><span class="op">(</span><span class="va">theta</span><span class="op">)</span>,</span>
<span>    <span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Trig.html">sin</a></span><span class="op">(</span><span class="va">theta</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="va">theta</span><span class="op">)</span>,</span>
<span>    <span class="fl">200</span>,<span class="fl">300</span><span class="op">)</span>,dim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#查看arr</span></span>
<span><span class="va">arr</span></span></code></pre></div>
<pre><code>## , , 1
## 
##            [,1]      [,2] [,3]
## [1,]  0.7071068 0.7071068  200
## [2,] -0.7071068 0.7071068  300</code></pre>
<div class="sourceCode" id="cb861"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#将arr转变为32浮点类型的图像矩阵M</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">arr</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">M</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">M</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">arr</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#基于M对img进行仿射变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpAffine</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cols_</span>,<span class="fl">2</span><span class="op">*</span><span class="va">rows_</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示img和dst</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'ori'</span>,<span class="va">img</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'affine'</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<p><img src="07-imgproc_files/figure-html/unnamed-chunk-28-1.png" width="672"><img src="07-imgproc_files/figure-html/unnamed-chunk-28-2.png" width="672"></p>
<p><strong>示例</strong></p>
<p>在对图像进行仿射变换时，可以指定边缘扩展方式。</p>
<div class="sourceCode" id="cb862"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/HappyFish.jpg"</span><span class="op">)</span></span>
<span><span class="co">#获取图像基本信息</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定仿射变换后的图像为源图像尺寸的1.5倍</span></span>
<span><span class="va">w</span> <span class="op">=</span> <span class="fl">1.5</span><span class="op">*</span><span class="va">img_info</span><span class="op">$</span><span class="va">width</span></span>
<span><span class="va">h</span> <span class="op">=</span> <span class="fl">1.5</span><span class="op">*</span><span class="va">img_info</span><span class="op">$</span><span class="va">height</span></span>
<span></span>
<span><span class="co">#生成仿射变换矩阵</span></span>
<span><span class="va">M_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.87</span>,<span class="fl">0.50</span>,<span class="op">-</span><span class="fl">36</span>, <span class="op">-</span><span class="fl">0.50</span>,<span class="fl">0.87</span>,<span class="fl">63</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">2</span>,nc<span class="op">=</span><span class="fl">3</span>,byrow<span class="op">=</span><span class="cn">T</span><span class="op">)</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">2</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">M</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">M_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行仿射变换，</span></span>
<span><span class="co">#边缘扩展方式为BORDER_CONSTANT，扩展像素的值都为(128,128,128)，</span></span>
<span><span class="co">#结果保存在warp_constant中</span></span>
<span><span class="va">warp_constant</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpAffine</span><span class="op">(</span><span class="va">img</span>,<span class="va">warp_constant</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">w</span>,<span class="va">h</span><span class="op">)</span>,<span class="va">INTER_LINEAR</span>,<span class="va">BORDER_CONSTANT</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">128</span>,<span class="fl">128</span>,<span class="fl">128</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行仿射变换，边缘扩展方式为BORDER_REPLICATE，结果保存在warp_replicate中</span></span>
<span><span class="va">warp_replicate</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpAffine</span><span class="op">(</span><span class="va">img</span>,<span class="va">warp_replicate</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">w</span>,<span class="va">h</span><span class="op">)</span>,<span class="va">INTER_LINEAR</span>,<span class="va">BORDER_REPLICATE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行仿射变换，边缘扩展方式为BORDER_WRAP，结果保存在warp_wrap中</span></span>
<span><span class="va">warp_wrap</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpAffine</span><span class="op">(</span><span class="va">img</span>,<span class="va">warp_wrap</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">w</span>,<span class="va">h</span><span class="op">)</span>,<span class="va">INTER_LINEAR</span>,<span class="va">BORDER_WRAP</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行仿射变换，边缘扩展方式为BORDER_DEFAULT，结果保存在warp_default中</span></span>
<span><span class="va">warp_default</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpAffine</span><span class="op">(</span><span class="va">img</span>,<span class="va">warp_default</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">w</span>,<span class="va">h</span><span class="op">)</span>,<span class="va">INTER_LINEAR</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-30-1.png" width="672"></div>
</div>
<div id="透视变换" class="section level2" number="6.4">
<h2>
<span class="header-section-number">6.4</span> 透视变换<a class="anchor" aria-label="anchor" href="#%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2"><i class="fas fa-link"></i></a>
</h2>
<p>透视变换较之于仿射变换，要复杂一些，其变换公式的矩阵形式为：</p>
<p><span class="math display">\[w\left[\begin{matrix}x \\y \\1\end{matrix}\right] =\left[\begin{matrix}a_{11}&amp;a_{12}&amp;a_{13} \\a_{21}&amp;a_{22}&amp;a_{23} \\a_{31}&amp;a_{32}&amp;a_{33} \end{matrix}\right] \left[\begin{matrix}u \\v \\1\end{matrix}\right] \]</span></p>
<p>其中，<span class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>为透视变换前的二维图形中某点的横、纵坐标，<span class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>则是该点经透视变换后得到的新的横、纵坐标。而矩阵：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
a_{11}&amp;a_{12}&amp;a_{13} \\
a_{21}&amp;a_{22}&amp;a_{23} \\
a_{31}&amp;a_{32}&amp;a_{33}
\end{matrix}
\right]
\]</span></p>
<p>就是透视矩阵。在透视矩阵中：</p>
<ul>
<li>
<span class="math inline">\(\displaystyle \left[ \begin{matrix} a_{11}&amp;a_{12} \\ a_{21}&amp;a_{22} \end{matrix} \right]\)</span>表示线性变换；</li>
<li>
<span class="math inline">\(\displaystyle \left[ \begin{matrix} a_{13}&amp;a_{23} \end{matrix} \right]\)</span>表示透视变换；</li>
<li>
<span class="math inline">\(\displaystyle \left[ \begin{matrix} a_{31}&amp;a_{32} \end{matrix} \right]\)</span>表示图像平移。</li>
</ul>
<p>在OpenCV中，可以通过<strong>getPerspectiveTransform</strong>函数计算四对不共线的对应点 — 即两组控点，每组控点个数为4个 — 所确定的透视变换，比如：</p>
<div class="sourceCode" id="cb863"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#先确定一组控点（用列表pts1来表示这组控点的坐标）</span></span>
<span><span class="co"># pts1 = list(c(57,40),c(329,23),c(374,407),c(15,407))</span></span>
<span><span class="va">pts1</span> <span class="op">=</span> <span class="fu">stdVecOfPoint2f</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">57</span>,<span class="fl">40</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">329</span>,<span class="fl">23</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">374</span>,<span class="fl">407</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">15</span>,<span class="fl">407</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#再确定另一组对应的控点（用列表pts2来表示其中的三点的坐标）</span></span>
<span><span class="co"># pts2 = list(c(20,20),c(380,20),c(380,430),c(20,430))</span></span>
<span><span class="va">pts2</span> <span class="op">=</span> <span class="fu">stdVecOfPoint2f</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">20</span>,<span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">380</span>,<span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">380</span>,<span class="fl">430</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">20</span>,<span class="fl">430</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#依据pts1和pts2计算透视矩阵M</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">cv_getPerspectiveTransform</span><span class="op">(</span><span class="va">pts1</span>,<span class="va">pts2</span><span class="op">)</span></span>
<span><span class="co">#查看M的内容</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">M</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<pre><code>##         [,1]    [,2]     [,3]
## [1,] 1.46933 0.18591 -70.1872
## [2,] 0.10148 1.56639 -47.4388
## [3,] 0.00024 0.00091   1.0000
## attr(,"depth")
## [1] 6</code></pre>
<p>两组控点形成的位置关系如下：</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-34-1.png" width="672"></div>
<p>透视矩阵<span class="math inline">\(M\)</span>的求解方式实质上就是求解方程组。首先依据如下公式计算：</p>
<p><span class="math display">\[w\left[\begin{matrix}x \\y \\1\end{matrix}\right] =\left[\begin{matrix}a_{11}&amp;a_{12}&amp;a_{13} \\a_{21}&amp;a_{22}&amp;a_{23} \\a_{31}&amp;a_{32}&amp;a_{33} \end{matrix}\right] \left[\begin{matrix}u \\v \\1\end{matrix}\right] \]</span></p>
<p>得到：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
wx \\
wy \\
w
\end{matrix}
\right]
=
\left[
\begin{matrix}
a_{11}u+a_{12}v+a_{13} \\
a_{21}u+a_{22}v+a_{23} \\
a_{31}u+a_{32}v+a_{33}
\end{matrix}
\right]
\]</span></p>
<p>则有：</p>
<p><span class="math display">\[
\begin{cases}
wx&amp;=a_{11}u+a_{12}v+a_{13} \\
wy&amp;=a_{21}u+a_{22}v+a_{23} \\
w&amp;=a_{31}u+a_{32}v+a_{33}
\end{cases}
\]</span></p>
<p>将第三个方程确定的<span class="math inline">\(w\)</span>代入第一个和第二方程：</p>
<p><span class="math display">\[
\begin{aligned}
(a_{31}u+a_{32}v+a_{33})x &amp;= a_{11}u+a_{12}v+a_{13} \\
(a_{31}u+a_{32}v+a_{33})y &amp;= a_{21}u+a_{22}v+a_{23}
\end{aligned}
\]</span></p>
<p>进一步变形可得如下方程组（这里称之为可算计透视变换公式）：</p>
<p><span class="math display">\[
\begin{cases}
\begin{aligned}
a_{11}u+a_{12}v+a_{13} - a_{31}ux-a_{32}vx &amp;= a_{33}x\\
a_{21}u+a_{22}v+a_{23}-a_{31}uy-a_{32}vy &amp;= a_{33}y
\end{aligned}
\end{cases}
\]</span></p>
<p>将蓝色点1的横、纵坐标(u,v)和对应的红色点1的横纵坐标(x,y)代入可计算透视变化公式，就可以得到两个方程；同理，将蓝色点2、3、4的横、纵坐标(u,v)和对应的红色点2、3、4的横纵坐标(x,y)代入可计算透视变换公式，又可以分别得到两个方程。这样一来，就会形成一个包含8个方程的方程组：</p>
<p><span class="math display">\[
\begin{cases}
57a_{11} + 40a_{12} + a_{13} +0a_{21}+0a_{22}+0a_{23} - 1140a_{31} - 800a_{32} = 20a_{33} \\
0a_{11}+0a_{12}+0a_{13}+57a_{21} + 40a_{22} + a_{23} - 1140a_{31} - 800a_{32} = 20a_{33} \\
329a_{11} + 23a_{12} + a_{13}+0a_{21}+0a_{22}+0a_{23} - 125020a_{31} - 8740a_{32} = 380a_{33} \\
0a_{11}+0a_{12}+0a_{13}+329a_{21} + 23a_{22} + a_{23} - 6580a_{31} - 460a_{32} = 20a_{33} \\
374a_{11} + 407a_{12} + a_{13} +0a_{21}+0a_{22}+0a_{23}- 142120a_{31} - 154660a_{32} = 380a_{33} \\
0a_{11}+0a_{12}+0a_{13}+374a_{21} + 407a_{22} + a_{23} - 160820a_{31} - 175010a_{32} = 430a_{33} \\
15a_{11} + 407a_{12} + a_{13} +0a_{21}+0a_{22}+0a_{23}- 300a_{31} - 8140a_{32} = 20a_{33} \\
0a_{11}+0a_{12}+0a_{13}+15a_{21} + 407a_{22} + a_{23} - 6450a_{31} - 175010a_{32} = 430a_{33}
\end{cases}
\]</span></p>
<p>由于四个蓝色点不共线（且经透视变换后，相应的四个红色点也不共线），所以这8个方程形成的方程组，就可以确定<span class="math inline">\(a_{11},a_{12},a_{13},a_{21},a_{22},a_{23},a_{31},a_{32}\)</span>的解，至于<span class="math inline">\(a_{33}\)</span>，不妨设定其值为1。</p>
<div class="sourceCode" id="cb865"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">A</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span></span>
<span>    <span class="fl">57</span>,<span class="fl">40</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="op">-</span><span class="fl">1140</span>,<span class="op">-</span><span class="fl">800</span>,</span>
<span>    <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">57</span>,<span class="fl">40</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">1140</span>,<span class="op">-</span><span class="fl">800</span>,</span>
<span>    <span class="fl">329</span>,<span class="fl">23</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="op">-</span><span class="fl">125020</span>,<span class="op">-</span><span class="fl">8740</span>,</span>
<span>    <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">329</span>,<span class="fl">23</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">6580</span>,<span class="op">-</span><span class="fl">460</span>,</span>
<span>    <span class="fl">374</span>,<span class="fl">407</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="op">-</span><span class="fl">142120</span>,<span class="op">-</span><span class="fl">154660</span>,</span>
<span>    <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">374</span>,<span class="fl">407</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">160820</span>,<span class="op">-</span><span class="fl">175010</span>,</span>
<span>    <span class="fl">15</span>,<span class="fl">407</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="op">-</span><span class="fl">300</span>,<span class="op">-</span><span class="fl">8140</span>,</span>
<span>    <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">15</span>,<span class="fl">407</span>,<span class="fl">1</span>,<span class="op">-</span><span class="fl">6450</span>,<span class="op">-</span><span class="fl">175010</span></span>
<span>  <span class="op">)</span>,</span>
<span>  nr<span class="op">=</span><span class="fl">8</span>,nc<span class="op">=</span><span class="fl">8</span>,byrow <span class="op">=</span> <span class="cn">T</span></span>
<span><span class="op">)</span></span>
<span><span class="va">b</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">20</span>,<span class="fl">20</span>,<span class="fl">380</span>,<span class="fl">20</span>,<span class="fl">380</span>,<span class="fl">430</span>,<span class="fl">20</span>,<span class="fl">430</span><span class="op">)</span></span>
<span><span class="va">sol</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/solve.html">solve</a></span><span class="op">(</span><span class="va">A</span>,<span class="va">b</span><span class="op">)</span>,<span class="fl">5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">sol</span>,<span class="fl">1</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span></code></pre></div>
<pre><code>##         [,1]    [,2]     [,3]
## [1,] 1.46933 0.18591 -70.1872
## [2,] 0.10148 1.56639 -47.4388
## [3,] 0.00024 0.00091   1.0000</code></pre>
<p>在OpenCV中，<strong>warpPerspective</strong>函数可以基于透视矩阵对图像进行透视变换。</p>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb867"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/calib_radial.jpg"</span><span class="op">)</span></span>
<span><span class="co">#显示img</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"原始图像"</span>,<span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#指定图像中棋盘区域的四个顶点坐标，保存在pts1中</span></span>
<span><span class="va">pts1</span> <span class="op">=</span> <span class="fu">stdVecOfPoint2f</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">57</span>,<span class="fl">40</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">329</span>,<span class="fl">23</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">374</span>,<span class="fl">407</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">15</span>,<span class="fl">407</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#指定棋盘区域要映射到的区域（通过四个顶点坐标指定，保存在pts2中）</span></span>
<span><span class="va">pts2</span> <span class="op">=</span> <span class="fu">stdVecOfPoint2f</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">20</span>,<span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">380</span>,<span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">380</span>,<span class="fl">430</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">20</span>,<span class="fl">430</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#依据pts1和pts2进行透视变换，获得变换矩阵M</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">cv_getPerspectiveTransform</span><span class="op">(</span><span class="va">pts1</span>,<span class="va">pts2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#依据M对img.test进行透视变换，结果保存在img.pers中</span></span>
<span><span class="va">img_pers</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_warpPerspective</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_pers</span>,<span class="va">M</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">420</span>,<span class="fl">450</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#显示img_pers</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"透视变换结果"</span>,<span class="va">img_pers</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-37-1.png" width="672"></div>
</div>
<div id="基础绘图-1" class="section level2" number="6.5">
<h2>
<span class="header-section-number">6.5</span> 基础绘图<a class="anchor" aria-label="anchor" href="#%E5%9F%BA%E7%A1%80%E7%BB%98%E5%9B%BE-1"><i class="fas fa-link"></i></a>
</h2>
<div id="point与scalar" class="section level3" number="6.5.1">
<h3>
<span class="header-section-number">6.5.1</span> Point与Scalar<a class="anchor" aria-label="anchor" href="#point%E4%B8%8Escalar"><i class="fas fa-link"></i></a>
</h3>
<p>在绘图操作中，会经常使用两种结构：<strong>Point</strong>和<strong>Scalar</strong>。</p>
<p><strong>Point</strong></p>
<p><strong>Point</strong>表示一个二维点，由其图像坐标<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>指定。比如，生成一个横坐标为0，纵坐标也为0的点：</p>
<div class="sourceCode" id="cb868"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pt</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pt</span><span class="op">$</span><span class="fu">outToConsole</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [0, 0]</code></pre>
<p>再比如，生成一个横坐标为10，纵坐标为8的点：</p>
<div class="sourceCode" id="cb870"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pt</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">8</span><span class="op">)</span></span>
<span><span class="va">pt</span><span class="op">$</span><span class="fu">outToConsole</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [10, 8]</code></pre>
<p>也可以使用如下代码生成一个横坐标为10，纵坐标为8的点：</p>
<div class="sourceCode" id="cb872"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成一个point</span></span>
<span><span class="va">pt</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="op">)</span> </span>
<span><span class="co">#修改横纵坐标值</span></span>
<span><span class="va">pt</span><span class="op">$</span><span class="va">x</span> <span class="op">=</span> <span class="fl">10</span></span>
<span><span class="va">pt</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fl">8</span></span>
<span></span>
<span><span class="va">pt</span><span class="op">$</span><span class="fu">outToConsole</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [10, 8]</code></pre>
<p><strong>Scalar</strong></p>
<p><strong>Scalar</strong>表示一个4维向量，在OpenCV中常被用于表示像素值。比如，生成一个蓝色、绿色和红色分量都为0的像素值：</p>
<div class="sourceCode" id="cb874"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sca</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">sca</span><span class="op">$</span><span class="fu">outToConsole</span><span class="op">(</span><span class="op">)</span> </span></code></pre></div>
<pre><code>## [0, 0, 0, 0]</code></pre>
<p>再比如，生成一个蓝色、绿色和红色分量分别为100、20和30的像素值：</p>
<div class="sourceCode" id="cb876"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sca</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">20</span>,<span class="fl">230</span><span class="op">)</span></span>
<span><span class="va">sca</span><span class="op">$</span><span class="fu">outToConsole</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [100, 20, 230, 0]</code></pre>
<!-- 也可以使用如下代码生成蓝色、绿色和红色分量分别为100、20和30的像素值： -->
<!-- ```{r echo=FALSE,eval=FALSE} -->
<!-- #一下代码为何达不到预期（更改不成功呢） -->
<!-- #生成一个scalar指针sca -->
<!-- sca = cv.scalar.Scalar01()  -->
<!-- #通过sca获取scalar类 -->
<!-- sca.cls = cv.Scalar(sca) -->
<!-- #通过sca.cls修改三个颜色值 -->
<!-- sca.cls[[0]] = 100.1 -->
<!-- sca.cls[[1]] = 20 -->
<!-- sca.cls[[2]] = 30 -->
<!-- cv.scalar.cv2r(sca) -->
<!-- ``` -->
<p>也可以随机生成一个像素值的蓝色、绿色和红色分量，比如：</p>
<div class="sourceCode" id="cb878"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成随机颜色的函数radomColor</span></span>
<span><span class="va">randomColor</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#从0到255的数中随机有放回取出3个数，形成一个3维向量作为函数的返回值</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,<span class="fl">3</span>,replace <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#设定随机数种子</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="co">#执行radomColor函数返回一个3维向量rndCol</span></span>
<span><span class="va">rndCol</span> <span class="op">=</span> <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#将rndCol的值依次作为蓝色、绿色、红色分量，生成一个像素值</span></span>
<span><span class="va">sca</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="va">rndCol</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">rndCol</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">rndCol</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看生成的像素值</span></span>
<span><span class="va">sca</span><span class="op">$</span><span class="fu">outToConsole</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [158, 206, 178, 0]</code></pre>
</div>
<div id="绘制直线段" class="section level3" number="6.5.2">
<h3>
<span class="header-section-number">6.5.2</span> 绘制直线（段）<a class="anchor" aria-label="anchor" href="#%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF%E6%AE%B5"><i class="fas fa-link"></i></a>
</h3>
<p>使用<strong>line</strong>函数可以绘制直线（段）。</p>
<p><strong>在灰度图上绘制直线</strong></p>
<div class="sourceCode" id="cb880"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="co"># 指定两个端点，一个坐标为(120,100)，一个坐标为(160,100)</span></span>
<span><span class="va">pt1</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">120</span>,<span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">pt2</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">160</span>,<span class="fl">100</span><span class="op">)</span></span>
<span><span class="co"># 在img上绘制端点为pt1和pt2的直线（段），颜色为白色(255)，线的粗细度为2</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="va">pt1</span>,<span class="va">pt2</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Line"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-45-1.png" width="672"></div>
<p>类似地，可以绘制如下数据框确定的8条直线：每条直线的第一个端点坐标为(x1,y1)，第二个端点坐标为(x2,y2)</p>
<div class="inline-table"><table class="table table-sm">
<thead><tr class="header">
<th align="right">x1</th>
<th align="right">y1</th>
<th align="right">x2</th>
<th align="right">y2</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">120</td>
<td align="right">100</td>
<td align="right">160</td>
<td align="right">100</td>
</tr>
<tr class="even">
<td align="right">114</td>
<td align="right">114</td>
<td align="right">142</td>
<td align="right">142</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">120</td>
<td align="right">100</td>
<td align="right">160</td>
</tr>
<tr class="even">
<td align="right">86</td>
<td align="right">114</td>
<td align="right">58</td>
<td align="right">142</td>
</tr>
<tr class="odd">
<td align="right">80</td>
<td align="right">100</td>
<td align="right">40</td>
<td align="right">100</td>
</tr>
<tr class="even">
<td align="right">86</td>
<td align="right">86</td>
<td align="right">58</td>
<td align="right">58</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">80</td>
<td align="right">100</td>
<td align="right">40</td>
</tr>
<tr class="even">
<td align="right">114</td>
<td align="right">86</td>
<td align="right">142</td>
<td align="right">58</td>
</tr>
</tbody>
</table></div>
<div class="sourceCode" id="cb881"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 在img上绘制数据框第一行数据确定的直线（段），颜色为白色(255)，线的粗细度为2</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">120</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">160</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="co"># 在img上绘制数据框第二行数据确定的直线（段），颜色为白色(255)，线的粗细度为2</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">114</span>,<span class="fl">114</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">142</span>,<span class="fl">142</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="co"># 类似地，绘制剩下的6条直线</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">120</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">160</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">86</span>,<span class="fl">114</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">58</span>,<span class="fl">142</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">80</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">40</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">86</span>,<span class="fl">86</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">58</span>,<span class="fl">58</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">80</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">40</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">114</span>,<span class="fl">86</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">142</span>,<span class="fl">58</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Line"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-48-1.png" width="672"></div>
<p><strong>在彩色图上绘制直线</strong></p>
<p>在全黑的彩色图形上绘制一条红色直线（段）：</p>
<div class="sourceCode" id="cb882"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span><span class="co"># 指定两个端点，一个坐标为(120,100)，一个坐标为(160,100)</span></span>
<span><span class="va">pt1</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">120</span>,<span class="fl">100</span><span class="op">)</span></span>
<span><span class="va">pt2</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">160</span>,<span class="fl">100</span><span class="op">)</span></span>
<span><span class="co"># 在img上绘制端点为pt1和pt2的直线（段），颜色为红色(255)，线的粗细度为2</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="va">pt1</span>,<span class="va">pt2</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Line"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-50-1.png" width="672"></div>
<p>在全黑的彩色图形上绘制多条随机彩色直线（段）：</p>
<div class="sourceCode" id="cb883"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成随机颜色的函数radomColor</span></span>
<span><span class="va">randomColor</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#从0到255的数中随机有放回取出3个数，形成一个3维向量作为函数的返回值</span></span>
<span>  <span class="va">tmp</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,<span class="fl">3</span>,replace <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span>  <span class="fu">Scalar</span><span class="op">(</span><span class="va">tmp</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">tmp</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">tmp</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 在img上绘制数据框第一行数据确定的直线（段），颜色为随机取值，线的粗细度为2</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">120</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">160</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="co"># 在img上绘制数据框第二行数据确定的直线（段），颜色为随机取值，线的粗细度为2</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">114</span>,<span class="fl">114</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">142</span>,<span class="fl">142</span><span class="op">)</span>,<span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="co"># 类似地，绘制剩下的6条直线</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">120</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">160</span><span class="op">)</span>,<span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">86</span>,<span class="fl">114</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">58</span>,<span class="fl">142</span><span class="op">)</span>,<span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">80</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">40</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">86</span>,<span class="fl">86</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">58</span>,<span class="fl">58</span><span class="op">)</span>,<span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">80</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">40</span><span class="op">)</span>,<span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">114</span>,<span class="fl">86</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">142</span>,<span class="fl">58</span><span class="op">)</span>,<span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Line"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-52-1.png" width="672"></div>
</div>
<div id="绘制矩形" class="section level3" number="6.5.3">
<h3>
<span class="header-section-number">6.5.3</span> 绘制矩形<a class="anchor" aria-label="anchor" href="#%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2"><i class="fas fa-link"></i></a>
</h3>
<p>可以使用<strong>rectangle</strong>函数绘制矩形。在OpenCV中，<strong>rectangle</strong>函数有两种重载形式，第一种是通过指定两个对角定点来确定矩形，第二种是通过指定左上角顶点以及宽度、高度来确定矩形。</p>
<p><strong>在灰度图上绘制矩形</strong></p>
<div class="sourceCode" id="cb884"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以第一种方式绘制矩形：两个对角顶点的坐标分别为(30,30)和(70,90)，</span></span>
<span><span class="co"># 线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">30</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">90</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以第二种方式绘制矩形：左上角顶点的坐标(100,100)，宽度为40，高度为60，</span></span>
<span><span class="co"># 线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Rect</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span>,<span class="fl">40</span>,<span class="fl">60</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Rect"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-54-1.png" width="672"></div>
<p>当要绘制填充矩形的时候，可以将线条粗细值设置为-1。</p>
<div class="sourceCode" id="cb885"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以第一种方式绘制矩形：两个对角顶点的坐标分别为(30,30)和(70,90)，</span></span>
<span><span class="co"># 填充色为白色(255)</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">30</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">90</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以第二种方式绘制矩形：左上角顶点的坐标(100,100)，宽度为40，高度为60，</span></span>
<span><span class="co"># 填充色为白色(255)</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Rect</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span>,<span class="fl">40</span>,<span class="fl">60</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Rect"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-56-1.png" width="672"></div>
<p><strong>在彩色图上绘制矩形</strong></p>
<p>在彩色图上绘制两个线条颜色分别为红色和蓝色的矩形</p>
<div class="sourceCode" id="cb886"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以第一种方式绘制矩形：两个对角顶点的坐标分别为(30,30)和(70,90)，</span></span>
<span><span class="co"># 线条颜色为红色(0,0,255)，线条粗细为2</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">30</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">90</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以第二种方式绘制矩形：左上角顶点的坐标(100,100)，宽度为40，高度为60，</span></span>
<span><span class="co"># 线条颜色为蓝色(255,0,0)，线条粗细为2</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Rect</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span>,<span class="fl">40</span>,<span class="fl">60</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Rect"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-58-1.png" width="672"></div>
<p>在彩色图上绘制一个红色填充矩形和一个蓝色填充矩形</p>
<div class="sourceCode" id="cb887"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以第一种方式绘制矩形：两个对角顶点的坐标分别为(30,30)和(70,90)，</span></span>
<span><span class="co"># 填充色为红色(0,0,255)</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">30</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">90</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以第二种方式绘制矩形：左上角顶点的坐标(100,100)，宽度为40，高度为60，</span></span>
<span><span class="co"># 填充色为蓝色(255,0,0)</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Rect</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span>,<span class="fl">40</span>,<span class="fl">60</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Rect"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-60-1.png" width="672"></div>
</div>
<div id="绘制圆" class="section level3" number="6.5.4">
<h3>
<span class="header-section-number">6.5.4</span> 绘制圆<a class="anchor" aria-label="anchor" href="#%E7%BB%98%E5%88%B6%E5%9C%86"><i class="fas fa-link"></i></a>
</h3>
<p>可以使用<strong>circle</strong>函数绘制圆。</p>
<p><strong>在灰度图上绘制圆</strong></p>
<div class="sourceCode" id="cb888"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(100,100)，半径为60，线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fl">60</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Circle"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-62-1.png" width="672"></div>
<p>当要绘制填充圆的时候，可以将线条粗细值设置为-1。</p>
<div class="sourceCode" id="cb889"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(100,100)，半径为60，填充颜色为白色(255)</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fl">60</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Circle"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-64-1.png" width="672"></div>
<p><strong>在彩色图上绘制圆</strong></p>
<p>在彩色图上绘制四个圆，线条颜色分别为白色、蓝色、蓝色和红色</p>
<div class="sourceCode" id="cb890"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(100,100)，半径为60，线条颜色为白色(255,255,255)，线条粗细度为2</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fl">60</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(70,70)，半径为10，线条颜色为蓝色(255,0,0)，线条粗细度为2</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">70</span><span class="op">)</span>,<span class="fl">10</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(130,70)，半径为10，线条颜色为蓝色(255,0,0)，线条粗细度为2</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">130</span>,<span class="fl">70</span><span class="op">)</span>,<span class="fl">10</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(100,130)，半径为10，线条颜色为红色(0,0,255)，线条粗细度为2</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">130</span><span class="op">)</span>,<span class="fl">10</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Circle"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-66-1.png" width="672"></div>
<p>在彩色图上绘制四个填充圆，填充颜色分别为白色、蓝色、蓝色和红色</p>
<div class="sourceCode" id="cb891"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(100,100)，半径为60，填充颜色为白色(255,255,255)</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fl">60</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(70,70)，半径为10，填充颜色为蓝色(255,0,0)</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">70</span><span class="op">)</span>,<span class="fl">10</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(130,70)，半径为10，填充颜色为蓝色(255,0,0)</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">130</span>,<span class="fl">70</span><span class="op">)</span>,<span class="fl">10</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 圆心坐标为(100,130)，半径为10，填充颜色为红色(0,0,255)</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">130</span><span class="op">)</span>,<span class="fl">10</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Circle"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-68-1.png" width="672"></div>
</div>
<div id="绘制椭圆弧" class="section level3" number="6.5.5">
<h3>
<span class="header-section-number">6.5.5</span> 绘制椭圆弧<a class="anchor" aria-label="anchor" href="#%E7%BB%98%E5%88%B6%E6%A4%AD%E5%9C%86%E5%BC%A7"><i class="fas fa-link"></i></a>
</h3>
<p>可以使用<strong>ellipse</strong>函数绘制椭圆弧。在OpenCV中，<strong>ellipse</strong>函数有两种重载形式：</p>
<ul>
<li>第一种是通过指定椭圆圆心、轴半径、旋转角度、起始角度和终止角度来确定椭圆，当旋转角为正数时，表明是按顺时针旋转，为负数时，则按逆时针旋转；<br>
</li>
<li>第二种是通过指定旋转矩形RoundedRect来确定椭圆，其中旋转矩形则是通过一个中心点、矩形尺寸和一个旋转角度来确定。</li>
</ul>
<p>这里是否需要椭圆弧的图形示意图？</p>
<p><strong>在灰度图上绘制椭圆弧</strong></p>
<div class="sourceCode" id="cb892"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为60和30，旋转角为0度，起始角为0度，终止角为90度，</span></span>
<span><span class="co"># 线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">60</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Ellipse"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-70-1.png" width="672"></div>
<p>类似地，可以绘制不同旋转角、不同起始角和不同终止角的椭圆弧：</p>
<div class="sourceCode" id="cb893"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为60和30，旋转角为0度，起始角为0度，终止角为90度，</span></span>
<span><span class="co"># 线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">60</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为70和40，旋转角为90度，起始角为0度，终止角为90度，</span></span>
<span><span class="co"># 线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">40</span><span class="op">)</span>,<span class="fl">90</span>,<span class="fl">0</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为80和50，旋转角为180度，起始角为45度，终止角为90度，</span></span>
<span><span class="co"># 线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">80</span>,<span class="fl">50</span><span class="op">)</span>,<span class="fl">180</span>,<span class="fl">45</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Ellipse"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-72-1.png" width="672"></div>
<p>当设置起始角为0，终止角为360时，可以绘制完成的椭圆曲线。</p>
<div class="sourceCode" id="cb894"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为60和30，旋转角为0度，起始角为0度，终止角为360度，</span></span>
<span><span class="co"># 线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">60</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">360</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为为70和40，旋转角为45度，起始角为0度，终止角为360度，</span></span>
<span><span class="co"># 线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">40</span><span class="op">)</span>,<span class="fl">45</span>,<span class="fl">0</span>,<span class="fl">360</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Ellipse"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-74-1.png" width="672"></div>
<p>当线条粗细度设置为-1时，可以绘制填充椭圆：</p>
<div class="sourceCode" id="cb895"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为80和40，旋转角为45度，起始角为0度，终止角为360度，</span></span>
<span><span class="co"># 填充颜色为白色(255)</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">80</span>,<span class="fl">40</span><span class="op">)</span>,<span class="fl">45</span>,<span class="fl">0</span>,<span class="fl">360</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Ellipse"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-76-1.png" width="672"></div>
<p><strong>在彩色图上绘制椭圆弧</strong></p>
<p>在彩色图上绘制四个圆，线条颜色分别为白色、蓝色、蓝色和红色</p>
<div class="sourceCode" id="cb896"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为60和30，旋转角为0度，起始角为0度，终止角为90度，</span></span>
<span><span class="co"># 线条颜色为红色(0,0,255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">60</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为70和40，旋转角为90度，起始角为0度，终止角为90度，</span></span>
<span><span class="co"># 线条颜色为绿色(0,255,0)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">40</span><span class="op">)</span>,<span class="fl">90</span>,<span class="fl">0</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">255</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为80和50，旋转角为180度，起始角为45度，终止角为90度，</span></span>
<span><span class="co"># 线条颜色为蓝色(255,0,0)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">80</span>,<span class="fl">50</span><span class="op">)</span>,<span class="fl">180</span>,<span class="fl">45</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Ellipse"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-78-1.png" width="672"></div>
<p>在彩色图上绘制三个填充椭圆扇形区域，填充颜色分别为红色、绿色和蓝色：</p>
<div class="sourceCode" id="cb897"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为60和30，旋转角为0度，起始角为0度，终止角为90度，</span></span>
<span><span class="co"># 填充色为红色</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">60</span>,<span class="fl">30</span><span class="op">)</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为70和40，旋转角为90度，起始角为0度，终止角为90度，</span></span>
<span><span class="co"># 填充色为绿色(0,255,0)</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">40</span><span class="op">)</span>,<span class="fl">90</span>,<span class="fl">0</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">255</span>,<span class="fl">0</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 椭圆心坐标为(100,100)，轴半径分别为80和50，旋转角为180度，起始角为45度，终止角为90度，</span></span>
<span><span class="co"># 填充色为蓝色(255,0,0)</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">80</span>,<span class="fl">50</span><span class="op">)</span>,<span class="fl">180</span>,<span class="fl">45</span>,<span class="fl">90</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Ellipse"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-80-1.png" width="672"></div>
<p><strong>通过RoundedRect绘制椭圆</strong></p>
<p>在灰度图上绘制：</p>
<div class="sourceCode" id="cb898"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#RoundedRect的中心坐标为(100,100)，矩形尺寸为120与60，旋转角为45度，</span></span>
<span><span class="co">#线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">RotatedRect</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size2f</span><span class="op">(</span><span class="fl">120</span>,<span class="fl">60</span><span class="op">)</span>,<span class="fl">45</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Ellipse"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-82-1.png" width="672"></div>
<p>也可以先生成指向RotatedRect类实例的XPtr指针，再作为参数传递给椭圆绘图函数：</p>
<div class="sourceCode" id="cb899"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="st">"CV_8UC1"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成RotatedRect，中心坐标为(100,100)，矩形尺寸为120与60，</span></span>
<span><span class="co">#旋转角为45度</span></span>
<span><span class="va">rc</span> <span class="op">=</span> <span class="fu">RotatedRect</span><span class="op">(</span><span class="fu">Point2f</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Size2f</span><span class="op">(</span><span class="fl">120</span>,<span class="fl">60</span><span class="op">)</span>,<span class="fl">45</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 绘制rc确定的椭圆，线条颜色为白色(255)，线条粗细为2</span></span>
<span><span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="va">rc</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Ellipse"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-84-1.png" width="672"></div>
</div>
<div id="绘制多边形" class="section level3" number="6.5.6">
<h3>
<span class="header-section-number">6.5.6</span> 绘制多边形<a class="anchor" aria-label="anchor" href="#%E7%BB%98%E5%88%B6%E5%A4%9A%E8%BE%B9%E5%BD%A2"><i class="fas fa-link"></i></a>
</h3>
<p>可以使用<strong>polylines</strong>函数绘制折线段。在OpenCV中，<strong>polylines</strong>函数有两种重载形式，主要区别在于：</p>
<ul>
<li>第一种需要指定一组或者多组折线段顶点集合、明确每组折线段顶点个数、且明确需要绘制的折线段个数；<br>
</li>
<li>第二种只需要指定一组或者多组折线段顶点集合即可。</li>
</ul>
<p>在绘制直线段时，若指定isClosed参数为TRUE，即可自动连接每组折线段的第一个顶点和最后一个顶点，进而形成多边形。</p>
<p><strong>在灰度图上绘制多边形</strong></p>
<div class="sourceCode" id="cb900"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成两个点列表（每个点代表着待绘制的多边形的一个顶点）</span></span>
<span><span class="va">pnts1</span> <span class="op">=</span> <span class="fu">stdVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pnts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">50</span>,<span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pnts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">20</span>,<span class="fl">80</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pnts1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">80</span>,<span class="fl">80</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pnts2</span> <span class="op">=</span> <span class="fu">stdVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pnts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">120</span>,<span class="fl">120</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pnts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">120</span>,<span class="fl">180</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pnts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">180</span>,<span class="fl">180</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pnts2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">180</span>,<span class="fl">120</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#将两个点列表合并成一个列表</span></span>
<span><span class="va">pts</span> <span class="op">=</span> <span class="fu">stdVecOfVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pts</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">pnts1</span><span class="op">)</span></span>
<span><span class="va">pts</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">pnts2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">npts</span> <span class="op">=</span> <span class="fu">stdVecOfint</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">npts</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">npts</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用polylines的第二个重载形式绘制两个多边形</span></span>
<span><span class="fu">cv_polylines</span><span class="op">(</span><span class="va">img</span>,<span class="va">pts</span>,<span class="cn">TRUE</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"FillPoly"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-86-1.png" width="672"></div>
<p><strong>在彩色图上绘制多边形</strong></p>
<div class="sourceCode" id="cb901"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用polylines的第二个重载形式绘制两个多边形</span></span>
<span><span class="fu">cv_polylines</span><span class="op">(</span><span class="va">img</span>,<span class="va">pts</span>,<span class="cn">TRUE</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"FillPoly"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-88-1.png" width="672"></div>
</div>
<div id="绘制填充多边形" class="section level3" number="6.5.7">
<h3>
<span class="header-section-number">6.5.7</span> 绘制填充多边形<a class="anchor" aria-label="anchor" href="#%E7%BB%98%E5%88%B6%E5%A1%AB%E5%85%85%E5%A4%9A%E8%BE%B9%E5%BD%A2"><i class="fas fa-link"></i></a>
</h3>
<p>可以使用<strong>fillPoly</strong>函数绘制填充多边形。在OpenCV中，<strong>fillPoly</strong>函数有两种重载形式，主要区别在于：</p>
<ul>
<li>第一种需要指定一组或者多组填充多边形顶点集合、明确每组填充多边形顶点个数、且明确需要绘制的填充多边形个数；<br>
</li>
<li>第二种只需要指定一组或者多组折线段顶点集合即可。</li>
</ul>
<p><strong>在灰度图上绘制填充多边形</strong></p>
<div class="sourceCode" id="cb902"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#或者使用fillPoly第二个重载形式绘制两个填充多边形</span></span>
<span><span class="fu">cv_fillPoly</span><span class="op">(</span><span class="va">img</span>,<span class="va">pts</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">150</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"FillPoly"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-90-1.png" width="672"></div>
<p><strong>在彩色图上绘制填充多边形</strong></p>
<div class="sourceCode" id="cb903"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用fillPoly第二个重载形式绘制两个填充多边形</span></span>
<span><span class="fu">cv_fillPoly</span><span class="op">(</span><span class="va">img</span>,<span class="va">pts</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以(100,100)为交点绘制一条水平线和竖直线，便于观察绘制的椭圆弧形状</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">200</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,lineType <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"FillPoly"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-92-1.png" width="672"></div>
</div>
<div id="绘制文本" class="section level3" number="6.5.8">
<h3>
<span class="header-section-number">6.5.8</span> 绘制文本<a class="anchor" aria-label="anchor" href="#%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC"><i class="fas fa-link"></i></a>
</h3>
<p>可以使用<strong>putText</strong>函数绘制文本。</p>
<p><strong>在灰度图上绘制文本</strong></p>
<div class="sourceCode" id="cb904"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 生成全黑的图像（宽度、高度都为200，类型为CV_8UC1）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以点(20,100)为文本Testing左下角位置，使用FONT_HERSHEY_SIMPLEX字体，放大系数为1.5，</span></span>
<span><span class="co"># 颜色为白色255，线条粗细度为2</span></span>
<span><span class="fu">cv_putText</span><span class="op">(</span> <span class="va">img</span>, <span class="st">"Testing"</span>, <span class="fu">Point</span><span class="op">(</span><span class="fl">20</span>,<span class="fl">100</span><span class="op">)</span>, </span>
<span>            <span class="va">FONT_HERSHEY_SIMPLEX</span>,<span class="fl">1.5</span>, <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Text"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-94-1.png" width="672"></div>
<p><strong>在彩色图上绘制文本</strong></p>
<div class="sourceCode" id="cb905"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全黑的图像（宽度、高度都为200，类型为CV_8UC3）</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 以点(20,100)为文本Testing左下角位置，使用FONT_HERSHEY_SIMPLEX字体，放大系数为1.5，</span></span>
<span><span class="co"># 颜色为红色(0,0,255)，线条粗细度为2</span></span>
<span><span class="fu">cv_putText</span><span class="op">(</span> <span class="va">img</span>, <span class="st">"Testing"</span>, <span class="fu">Point</span><span class="op">(</span><span class="fl">20</span>,<span class="fl">100</span><span class="op">)</span>, </span>
<span>            <span class="va">FONT_HERSHEY_SIMPLEX</span>,<span class="fl">1.5</span>, <span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"Text"</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-96-1.png" width="672"></div>
<p>以下是综合了一些基础绘图操作形成的两个综合示例：</p>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb906"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定w=400, 作为图像的高度和宽度</span></span>
<span><span class="va">w</span> <span class="op">=</span> <span class="fl">400</span></span>
<span></span>
<span><span class="co">#形成绘制椭圆的函数MyEllipse：</span></span>
<span><span class="co">#圆心位于图像中心点，</span></span>
<span><span class="co">#长轴半径为w/4，短轴半径为w/16，</span></span>
<span><span class="co">#旋转角为函数参数angle（在调用函数的时候指定），</span></span>
<span><span class="co">#线条颜色为蓝色，线条粗细度为2，线条类型指定为8，即LINE_8</span></span>
<span><span class="va">MyEllipse</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">img</span>,<span class="va">angle</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">thickness</span> <span class="op">=</span> <span class="fl">2</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fl">8</span></span>
<span>  <span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="va">w</span><span class="op">/</span><span class="fl">2</span>,<span class="va">w</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>,<span class="va">w</span><span class="op">/</span><span class="fl">16</span><span class="op">)</span>,<span class="va">angle</span>,<span class="fl">0</span>,<span class="fl">360</span>,</span>
<span>               <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="va">thickness</span>,<span class="va">lineType</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#形成绘制填充圆的函数MyFilledCircle：</span></span>
<span><span class="co">#圆心为函数参数center（在调用函数的时候指定），</span></span>
<span><span class="co">#圆半径为w/32，</span></span>
<span><span class="co">#线条颜色为红色，线条类型为LINE_8</span></span>
<span><span class="va">MyFilledCircle</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">img</span>,<span class="va">center</span> <span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="va">center</span>,<span class="va">w</span><span class="op">/</span><span class="fl">32</span>,<span class="fu">Scalar</span><span class="op">(</span> <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">255</span> <span class="op">)</span>,<span class="op">-</span><span class="fl">1</span>,<span class="va">LINE_8</span><span class="op">)</span>;</span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#形成绘制填充多边形的函数MyPolygon：</span></span>
<span><span class="co">#线条类型为Line_8</span></span>
<span><span class="va">MyPolygon</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">LINE_8</span><span class="op">)</span></span>
<span>  <span class="co">#形成填充多边形顶点列表</span></span>
<span>  </span>
<span>  <span class="va">poly1</span> <span class="op">=</span> <span class="fu">stdVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>    <span class="va">w</span><span class="op">/</span><span class="fl">4</span>,   <span class="fl">7</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>  <span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>,   <span class="fl">7</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>  <span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>,  <span class="fl">13</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">16</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">11</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">16</span>, <span class="fl">13</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">16</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">19</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">32</span>,  <span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>  <span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>,   <span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>  <span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>,     <span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">26</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">40</span>,    <span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">26</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">40</span>,    <span class="va">w</span><span class="op">/</span><span class="fl">4</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">22</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">40</span>,    <span class="va">w</span><span class="op">/</span><span class="fl">4</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">22</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">40</span>,    <span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">18</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">40</span>,    <span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">18</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">40</span>,    <span class="va">w</span><span class="op">/</span><span class="fl">4</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">14</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">40</span>,    <span class="va">w</span><span class="op">/</span><span class="fl">4</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">14</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">40</span>,    <span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>    <span class="va">w</span><span class="op">/</span><span class="fl">4</span>,     <span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>    <span class="va">w</span><span class="op">/</span><span class="fl">4</span>,   <span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span> <span class="fl">13</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">32</span>,  <span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>  <span class="fl">5</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">16</span>, <span class="fl">13</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">16</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">poly1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span>    <span class="va">w</span><span class="op">/</span><span class="fl">4</span>,  <span class="fl">13</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">16</span> <span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">rook_points</span> <span class="op">=</span> <span class="fu">stdVecOfVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">rook_points</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">poly1</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="fu">cv_fillPoly</span><span class="op">(</span> <span class="va">img</span>,<span class="va">rook_points</span>,<span class="fu">Scalar</span><span class="op">(</span> <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">255</span> <span class="op">)</span>,<span class="va">lineType</span> <span class="op">)</span>;</span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#形成绘制直线的函数MyLine：</span></span>
<span><span class="co">#直线的两个端点为函数参数start和end（在调用函数的时候指定），</span></span>
<span><span class="co">#线条类型为LINE_8，线条粗细度为2</span></span>
<span><span class="va">MyLine</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">img</span>, <span class="va">start</span>, <span class="va">end</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="va">thickness</span> <span class="op">=</span> <span class="fl">2</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">LINE_8</span><span class="op">)</span></span>
<span>  <span class="fu">cv_line</span><span class="op">(</span><span class="va">img</span>,<span class="va">start</span>,<span class="va">end</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="va">thickness</span>,<span class="va">lineType</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#生成全黑的图像atom_img（宽度、高度都为400，类型为CV_8UC3）</span></span>
<span><span class="va">atom_image</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="va">w</span>,<span class="va">w</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span><span class="co">#生成全黑的图像rook_image（宽度、高度都为400，类型为CV_8UC3）</span></span>
<span><span class="va">rook_image</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="va">w</span>,<span class="va">w</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#在atom_image上绘制旋转角为90度的蓝色椭圆</span></span>
<span><span class="fu">MyEllipse</span><span class="op">(</span> <span class="va">atom_image</span>, <span class="fl">90</span> <span class="op">)</span></span>
<span><span class="co">#在atom_image上绘制旋转角为0度的蓝色椭圆</span></span>
<span><span class="fu">MyEllipse</span><span class="op">(</span> <span class="va">atom_image</span>, <span class="fl">0</span> <span class="op">)</span></span>
<span><span class="co">#在atom_image上绘制旋转角为45度的蓝色椭圆</span></span>
<span><span class="fu">MyEllipse</span><span class="op">(</span> <span class="va">atom_image</span>, <span class="fl">45</span> <span class="op">)</span></span>
<span><span class="co">#在atom_image上绘制旋转角为-45度的蓝色椭圆</span></span>
<span><span class="fu">MyEllipse</span><span class="op">(</span> <span class="va">atom_image</span>, <span class="op">-</span><span class="fl">45</span> <span class="op">)</span></span>
<span><span class="co">#在在atom_image上以中心点为圆心绘制红色填充圆</span></span>
<span><span class="fu">MyFilledCircle</span><span class="op">(</span> <span class="va">atom_image</span>, <span class="fu">Point</span><span class="op">(</span> <span class="va">w</span><span class="op">/</span><span class="fl">2</span>, <span class="va">w</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span> <span class="op">)</span></span>
<span></span>
<span><span class="co">#在rook_image上绘制白色填充多边形</span></span>
<span><span class="fu">MyPolygon</span><span class="op">(</span><span class="va">rook_image</span><span class="op">)</span></span>
<span><span class="co">#在rook_image底部绘制黄色填充矩形</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">rook_image</span>,</span>
<span>         <span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">7</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span><span class="op">)</span>,</span>
<span>         <span class="fu">Point</span><span class="op">(</span><span class="va">w</span>, <span class="va">w</span><span class="op">)</span>,</span>
<span>         <span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,</span>
<span>         <span class="op">-</span><span class="fl">1</span>,</span>
<span>         <span class="va">LINE_8</span> <span class="op">)</span></span>
<span><span class="co">#在rook_image底部绘制3条竖线和1条横线（每条直线的两个端点都通过MyLine函数的start参数和end参数指定）</span></span>
<span><span class="fu">MyLine</span><span class="op">(</span><span class="va">rook_image</span>, <span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">15</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">16</span><span class="op">)</span>, <span class="fu">Point</span><span class="op">(</span><span class="va">w</span>, <span class="fl">15</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">16</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">MyLine</span><span class="op">(</span><span class="va">rook_image</span>, <span class="fu">Point</span><span class="op">(</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>, <span class="fl">7</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span><span class="op">)</span>, <span class="fu">Point</span><span class="op">(</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>, <span class="va">w</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">MyLine</span><span class="op">(</span><span class="va">rook_image</span>, <span class="fu">Point</span><span class="op">(</span><span class="va">w</span><span class="op">/</span><span class="fl">2</span>, <span class="fl">7</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span><span class="op">)</span>, <span class="fu">Point</span><span class="op">(</span><span class="va">w</span><span class="op">/</span><span class="fl">2</span>, <span class="va">w</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">MyLine</span><span class="op">(</span><span class="va">rook_image</span>, <span class="fu">Point</span><span class="op">(</span><span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>, <span class="fl">7</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">8</span><span class="op">)</span>, <span class="fu">Point</span><span class="op">(</span><span class="fl">3</span><span class="op">*</span><span class="va">w</span><span class="op">/</span><span class="fl">4</span>, <span class="va">w</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'atom_image'</span>,<span class="va">atom_image</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'rook_image'</span>,<span class="va">rook_image</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-98-1.png" width="672"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb907"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#确定循环次数</span></span>
<span><span class="va">NUMBER</span> <span class="op">=</span> <span class="fl">100</span></span>
<span><span class="co">#确定延时秒数</span></span>
<span><span class="va">DELAY</span> <span class="op">=</span> <span class="fl">5</span></span>
<span></span>
<span><span class="co">#设定图像宽为900像素，高度为600像素</span></span>
<span><span class="va">window_width</span> <span class="op">=</span> <span class="fl">900</span></span>
<span><span class="va">window_height</span> <span class="op">=</span> <span class="fl">600</span></span>
<span></span>
<span><span class="co">#以x_1和x_2确定随机生成的点的横坐标范围</span></span>
<span><span class="va">x_1</span> <span class="op">=</span> <span class="op">-</span><span class="va">window_width</span><span class="op">/</span><span class="fl">2</span></span>
<span><span class="va">x_2</span> <span class="op">=</span> <span class="va">window_width</span><span class="op">*</span><span class="fl">3</span><span class="op">/</span><span class="fl">2</span></span>
<span><span class="co">#以y_1和y_2确定随机生成的点的纵坐标范围</span></span>
<span><span class="va">y_1</span> <span class="op">=</span> <span class="op">-</span><span class="va">window_width</span><span class="op">/</span><span class="fl">2</span></span>
<span><span class="va">y_2</span> <span class="op">=</span> <span class="va">window_width</span><span class="op">*</span><span class="fl">3</span><span class="op">/</span><span class="fl">2</span></span>
<span></span>
<span><span class="co">#生成随机颜色的函数</span></span>
<span><span class="va">randomColor</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#从0到255的数中随机有放回取出3个数，形成一个3维向量作为函数的返回值</span></span>
<span>  <span class="va">samp</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,<span class="fl">3</span>,replace <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span>  <span class="fu">Scalar</span><span class="op">(</span><span class="va">samp</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>,<span class="va">samp</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>,<span class="va">samp</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#绘制随机直线的函数</span></span>
<span><span class="va">Drawing_Random_Lines</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#初始化两个点：pt1和pt2，使其横纵坐标都为0</span></span>
<span>  <span class="va">pt1</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="va">pt2</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#循环NUMBER次，每次都绘制一条直线</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">NUMBER</span><span class="op">)</span></span>
<span>  <span class="op">{</span></span>
<span>    <span class="co">#随机生成直线的一个端点</span></span>
<span>    <span class="va">pt1</span><span class="op">$</span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span> <span class="op">)</span></span>
<span>    <span class="va">pt1</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span> <span class="op">)</span></span>
<span>    <span class="co">#随机生成直线的另一个端点</span></span>
<span>    <span class="va">pt2</span><span class="op">$</span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span> <span class="op">)</span></span>
<span>    <span class="va">pt2</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span> <span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#随机确定线条颜色</span></span>
<span>    <span class="va">cl</span> <span class="op">=</span> <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定线条粗细度（在1到10之间）</span></span>
<span>    <span class="va">thickness</span> <span class="op">=</span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">10</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#在image上绘制直线</span></span>
<span>    <span class="fu">cv_line</span><span class="op">(</span> <span class="va">image</span>, <span class="va">pt1</span>, <span class="va">pt2</span>, <span class="va">cl</span>,<span class="va">thickness</span>, <span class="fl">8</span><span class="op">)</span></span>
<span>    <span class="co">#在图形窗口上展示图像image</span></span>
<span>    <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">image</span><span class="op">)</span></span>
<span>    <span class="co">#延时5秒，如果用户按下键盘上的按钮，将终止循环。</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="fu">cv_waitKey</span><span class="op">(</span> <span class="va">DELAY</span> <span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>      <span class="kw">break</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#绘制随机矩形（或者随机填充矩形）的函数</span></span>
<span><span class="va">Drawing_Random_Rectangles</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#初始化两个点：pt1和pt2，使其横纵坐标都为0</span></span>
<span>  <span class="va">pt1</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="va">pt2</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="co">#指定线条类型为8，即LINE_8</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fl">8</span></span>
<span>  </span>
<span>  <span class="co">#循环NUMBER次，每次都绘制一个矩形（或者填充矩形）</span></span>
<span>  <span class="kw">for</span><span class="op">(</span> <span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">NUMBER</span> <span class="op">)</span></span>
<span>  <span class="op">{</span></span>
<span>    <span class="co">#随机生成矩形的两个对角顶点</span></span>
<span>    <span class="va">pt1</span><span class="op">$</span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span> <span class="op">)</span></span>
<span>    <span class="va">pt1</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span> <span class="op">)</span></span>
<span>    <span class="va">pt2</span><span class="op">$</span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span> <span class="op">)</span></span>
<span>    <span class="va">pt2</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span> <span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#随机确定线条颜色</span></span>
<span>    <span class="va">cl</span> <span class="op">=</span> <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定线条粗细度（在-3到10之间）</span></span>
<span>    <span class="va">thickness</span> <span class="op">=</span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">3</span>, <span class="fl">10</span> <span class="op">)</span></span>
<span>    <span class="co">#当thickness小于-1时，取-1（即形成填充矩形）</span></span>
<span>    <span class="va">thickness</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">thickness</span>, <span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#在image上绘制矩形</span></span>
<span>    <span class="fu">cv_rectangle</span><span class="op">(</span> <span class="va">image</span>, <span class="va">pt1</span>, <span class="va">pt2</span>, <span class="va">cl</span>, <span class="va">thickness</span>, <span class="va">lineType</span> <span class="op">)</span></span>
<span></span>
<span>    <span class="co">#在图形窗口上展示图像image</span></span>
<span>    <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">image</span><span class="op">)</span></span>
<span>    <span class="co">#延时5秒，如果用户按下键盘上的按钮，将终止循环。</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="fu">cv_waitKey</span><span class="op">(</span> <span class="va">DELAY</span> <span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>      <span class="kw">break</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#绘制随机椭圆弧（或者随机填充椭圆弧）的函数</span></span>
<span><span class="va">Drawing_Random_Ellipses</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span> <span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#指定线条类型为8，即LINE_8</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fl">8</span></span>
<span></span>
<span>  <span class="co">#循环NUMBER次，每次都绘制一个椭圆弧（或者填充椭圆弧）</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">NUMBER</span><span class="op">)</span></span>
<span>  <span class="op">{</span></span>
<span>    <span class="co">#随机生成椭圆弧圆心的横、纵坐标</span></span>
<span>    <span class="va">center</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">center</span><span class="op">$</span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span></span>
<span>    <span class="va">center</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co">#随机生成椭圆弧的长、短半径</span></span>
<span>    <span class="va">axes</span> <span class="op">=</span> <span class="fu">Size</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">axes</span><span class="op">$</span><span class="va">width</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">200</span><span class="op">)</span></span>
<span>    <span class="va">axes</span><span class="op">$</span><span class="va">height</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">200</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#随机生成椭圆弧的旋转角</span></span>
<span>    <span class="va">angle</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">180</span><span class="op">)</span></span>
<span>    <span class="co">#依据angle确定椭圆弧的startAngle和endAngle</span></span>
<span>    <span class="va">startAngle</span> <span class="op">=</span> <span class="va">angle</span><span class="op">-</span><span class="fl">100</span></span>
<span>    <span class="va">endAngle</span> <span class="op">=</span> <span class="va">angle</span><span class="op">+</span><span class="fl">200</span></span>
<span>    </span>
<span>    <span class="co">#随机确定线条颜色</span></span>
<span>    <span class="va">cl</span> <span class="op">=</span> <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定线条粗细度（在-1到9之间）</span></span>
<span>    <span class="va">thickness</span> <span class="op">=</span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>, <span class="fl">9</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co">#在image上绘制椭圆弧</span></span>
<span>    <span class="fu">cv_ellipse</span><span class="op">(</span><span class="va">image</span>, <span class="va">center</span>, <span class="va">axes</span>, <span class="va">angle</span>, <span class="va">angle</span> <span class="op">-</span> <span class="fl">100</span>, <span class="va">angle</span> <span class="op">+</span> <span class="fl">200</span>,</span>
<span>             <span class="va">cl</span>, <span class="va">thickness</span>, <span class="va">lineType</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co">#在图形窗口上展示图像image</span></span>
<span>    <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">image</span><span class="op">)</span></span>
<span>    <span class="co">#延时5秒，如果用户按下键盘上的按钮，将终止循环。</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="fu">cv_waitKey</span><span class="op">(</span> <span class="va">DELAY</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>      <span class="kw">break</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#绘制随机三角形的函数</span></span>
<span><span class="va">Drawing_Random_Polylines</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">image</span>, <span class="va">window_name</span> <span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#指定线条类型为8，即LINE_8</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fl">8</span></span>
<span>  </span>
<span>  <span class="co">#循环NUMBER次，每次都绘制两个三角形</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">NUMBER</span><span class="op">)</span></span>
<span>  <span class="op">{</span></span>
<span>    <span class="co">#随机生成两个三角形的顶点</span></span>
<span>    <span class="va">triangle1</span> <span class="op">=</span> <span class="fu">stdVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">triangle1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle2</span> <span class="op">=</span> <span class="fu">stdVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">triangle2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">ppt</span> <span class="op">=</span> <span class="fu">stdVecOfVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">ppt</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">triangle1</span><span class="op">)</span></span>
<span>    <span class="va">ppt</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">triangle2</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#随机确定线条颜色</span></span>
<span>    <span class="va">cl</span> <span class="op">=</span> <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定线条粗细度（在1到10之间）</span></span>
<span>    <span class="va">thickness</span> <span class="op">=</span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">10</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#在image上绘制两个三角形</span></span>
<span>    <span class="fu">cv_polylines</span><span class="op">(</span><span class="va">image</span>, <span class="va">ppt</span>, <span class="cn">TRUE</span>,<span class="va">cl</span>, <span class="va">thickness</span>, <span class="va">lineType</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co">#在图形窗口上展示图像image</span></span>
<span>    <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">image</span><span class="op">)</span></span>
<span>    <span class="co">#延时5秒，如果用户按下键盘上的按钮，将终止循环。</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="fu">cv_waitKey</span><span class="op">(</span> <span class="va">DELAY</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>      <span class="kw">break</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#绘制随机填充三角形的函数</span></span>
<span><span class="va">Drawing_Random_Filled_Polygons</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span> <span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#指定线条类型为8，即LINE_8</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fl">8</span></span>
<span>  </span>
<span>  <span class="co">#循环NUMBER次，每次都绘制两个三角形</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">NUMBER</span><span class="op">)</span></span>
<span>  <span class="op">{</span></span>
<span>    <span class="co">#随机生成两个三角形的顶点</span></span>
<span>    <span class="va">triangle1</span> <span class="op">=</span> <span class="fu">stdVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">triangle1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle1</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle2</span> <span class="op">=</span> <span class="fu">stdVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">triangle2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">triangle2</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">ppt</span> <span class="op">=</span> <span class="fu">stdVecOfVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">ppt</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">triangle1</span><span class="op">)</span></span>
<span>    <span class="va">ppt</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">triangle2</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co">#随机确定线条颜色</span></span>
<span>    <span class="va">cl</span> <span class="op">=</span> <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#在image上绘制两个填充三角形</span></span>
<span>    <span class="fu">cv_fillPoly</span><span class="op">(</span> <span class="va">image</span>, <span class="va">ppt</span>, <span class="va">cl</span>, <span class="va">lineType</span> <span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#在图形窗口上展示图像image</span></span>
<span>    <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">image</span><span class="op">)</span></span>
<span>    <span class="co">#延时5秒，如果用户按下键盘上的按钮，将终止循环。</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="fu">cv_waitKey</span><span class="op">(</span> <span class="va">DELAY</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>      <span class="kw">break</span></span>
<span>    <span class="op">}</span></span>
<span>    </span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#绘制随机圆（或者随机填充圆）的函数</span></span>
<span><span class="va">Drawing_Random_Circles</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#指定线条类型为8，即LINE_8</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fl">8</span></span>
<span>  </span>
<span>  <span class="co">#循环NUMBER次，每次都绘制一个圆（或者填充圆）</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">NUMBER</span><span class="op">)</span></span>
<span>  <span class="op">{</span></span>
<span>    <span class="co">#随机生成圆心的横、纵坐标</span></span>
<span>    <span class="va">center</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">center</span><span class="op">$</span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span></span>
<span>    <span class="va">center</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span></span>
<span>    <span class="co">#随机生成圆半径(0到300之间)</span></span>
<span>    <span class="va">radius</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">300</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定线条颜色</span></span>
<span>    <span class="va">cl</span> <span class="op">=</span> <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定线条粗细度（在-1到9之间）</span></span>
<span>    <span class="va">thickness</span> <span class="op">=</span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>, <span class="fl">9</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#在image上绘制圆</span></span>
<span>    <span class="fu">cv_circle</span><span class="op">(</span> <span class="va">image</span>, <span class="va">center</span>, <span class="va">radius</span>, <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span>,</span>
<span>            <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>, <span class="fl">9</span><span class="op">)</span>, <span class="va">lineType</span> <span class="op">)</span></span>
<span></span>
<span>    <span class="co">#在图形窗口上展示图像image</span></span>
<span>    <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">image</span><span class="op">)</span></span>
<span>    <span class="co">#延时5秒，如果用户按下键盘上的按钮，将终止循环。</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="fu">cv_waitKey</span><span class="op">(</span> <span class="va">DELAY</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>      <span class="kw">break</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#在随机位置上绘制文本的函数</span></span>
<span><span class="va">Displaying_Random_Text</span><span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#指定线条类型为8，即LINE_8</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fl">8</span></span>
<span></span>
<span>  <span class="co">#循环NUMBER次，每次都绘制一个文本</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">NUMBER</span> <span class="op">)</span></span>
<span>  <span class="op">{</span></span>
<span>    <span class="co">#随机生成文本的左下角定位点</span></span>
<span>    <span class="va">org</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">org</span><span class="op">$</span><span class="va">x</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">x_1</span>, <span class="va">x_2</span><span class="op">)</span></span>
<span>    <span class="va">org</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">y_1</span>, <span class="va">y_2</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定文本的字体类型</span></span>
<span>    <span class="va">fontType</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">8</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定文本的放缩系数</span></span>
<span>    <span class="va">fontScale</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">100</span><span class="op">)</span><span class="op">*</span><span class="fl">0.05</span><span class="op">+</span><span class="fl">0.1</span></span>
<span>    <span class="co">#随机确定文本颜色</span></span>
<span>    <span class="va">cl</span> <span class="op">=</span> <span class="fu">randomColor</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="co">#随机确定线条粗细度（在1到10之间）</span></span>
<span>    <span class="va">thickness</span> <span class="op">=</span>  <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">10</span><span class="op">)</span></span>
<span>    </span>
<span>    <span class="co">#在image上绘文本</span></span>
<span>    <span class="fu">cv_putText</span><span class="op">(</span> <span class="va">image</span>, <span class="st">"Testing text rendering"</span>, <span class="va">org</span>, <span class="va">fontType</span>,</span>
<span>             <span class="va">fontScale</span>, <span class="va">cl</span>, <span class="va">thickness</span>, <span class="va">lineType</span><span class="op">)</span></span>
<span></span>
<span>    <span class="co">#在图形窗口上展示图像image</span></span>
<span>    <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">image</span><span class="op">)</span></span>
<span>    <span class="co">#延时5秒，如果用户按下键盘上的按钮，将终止循环。</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="fu">cv_waitKey</span><span class="op">(</span> <span class="va">DELAY</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>      <span class="kw">break</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#显示大型结束文本的函数</span></span>
<span><span class="va">Displaying_Big_End</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span> <span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#获取包含文本的矩形尺寸textSize以及文本基准线的纵坐标baseLine</span></span>
<span>  <span class="va">baseLine</span> <span class="op">=</span> <span class="fl">0</span></span>
<span>  <span class="va">textsize</span> <span class="op">=</span> <span class="fu">cv_getTextSize</span><span class="op">(</span><span class="st">"OpenCV forever!"</span>, <span class="va">FONT_HERSHEY_COMPLEX</span>, <span class="fl">3</span>, <span class="fl">5</span>, <span class="va">baseLine</span><span class="op">)</span></span>
<span>  <span class="co"># baseLine = uncloseRef(baseLine.ref)</span></span>
<span>  </span>
<span>  <span class="co">#确定文本的左下角定位点</span></span>
<span>  <span class="va">org</span> <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="op">(</span><span class="va">window_width</span> <span class="op">-</span> <span class="va">textsize</span><span class="op">$</span><span class="va">width</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span>, <span class="op">(</span><span class="va">window_height</span> <span class="op">-</span> <span class="va">textsize</span><span class="op">$</span><span class="va">height</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="co">#指定线条类型为8，即LINE_8</span></span>
<span>  <span class="va">lineType</span> <span class="op">=</span> <span class="fl">8</span></span>
<span>  </span>
<span>  <span class="co">#利用cv2r函数将image转变为R语言的数组</span></span>
<span>  <span class="va">image_arr</span> <span class="op">=</span> <span class="va">image</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co">#通过循环，不断将图像的各个灰度值都变为0</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">255</span>,by<span class="op">=</span><span class="fl">2</span><span class="op">)</span> <span class="op">)</span></span>
<span>  <span class="op">{</span></span>
<span>    <span class="co">#依据image.arr生成尺寸相同的数组tmp，所有元素值都为i</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="va">i</span>,<span class="fu"><a href="https://rdrr.io/r/base/prod.html">prod</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">image_arr</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">tmp</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">image_arr</span><span class="op">)</span></span>
<span>    <span class="co">#将image_arr减去tmp，结果保存在image2_arr中，则image2_arr中对应于image_arr元素值为i的部分都是0</span></span>
<span>    <span class="va">image2_arr</span> <span class="op">=</span> <span class="va">image_arr</span> <span class="op">-</span> <span class="va">tmp</span></span>
<span>    <span class="co">#将image2.arr转变为图像矩阵image2</span></span>
<span>    <span class="va">image2</span> <span class="op">=</span> <span class="va">image</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">image2_arr</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">image2</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="va">image2</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">image2_arr</span><span class="op">)</span></span>
<span>    <span class="co">#在image2上绘制文本</span></span>
<span>    <span class="fu">cv_putText</span><span class="op">(</span> <span class="va">image2</span>, <span class="st">"OpenCV forever!"</span>, <span class="va">org</span>, <span class="va">FONT_HERSHEY_COMPLEX</span>, <span class="fl">3</span>,</span>
<span>             <span class="fu">Scalar</span><span class="op">(</span><span class="va">i</span>, <span class="va">i</span>, <span class="fl">255</span><span class="op">)</span>, <span class="fl">5</span>, <span class="va">lineType</span> <span class="op">)</span>;</span>
<span></span>
<span>    <span class="co">#在图形窗口上展示图像image</span></span>
<span>    <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">image2</span><span class="op">)</span></span>
<span>    <span class="co">#延时5秒，如果用户按下键盘上的按钮，将终止循环。</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="fu">cv_waitKey</span><span class="op">(</span> <span class="va">DELAY</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>      <span class="kw">break</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#指定图像窗口的标题为Drawing_2 Tutorial</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Drawing_2 Tutorial"</span></span>
<span><span class="co">#生成全黑图像（高度为window_height，宽度为window_width，类型为CV_8UC3）</span></span>
<span><span class="va">image</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="va">window_height</span>,<span class="va">window_width</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span><span class="co">#显示图像并进行一定延迟</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">image</span><span class="op">)</span></span>
<span><span class="fu">cv_waitKey</span><span class="op">(</span><span class="va">DELAY</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] -1</code></pre>
<div class="sourceCode" id="cb909"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#绘制随机直线</span></span>
<span><span class="fu">Drawing_Random_Lines</span><span class="op">(</span><span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#绘制随机矩形（或者填充矩形）</span></span>
<span><span class="fu">Drawing_Random_Rectangles</span><span class="op">(</span><span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#绘制随机椭圆弧（或者随机填充椭圆弧）</span></span>
<span><span class="fu">Drawing_Random_Ellipses</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#绘制随机三角形的函数</span></span>
<span><span class="fu">Drawing_Random_Polylines</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span> <span class="op">)</span></span>
<span></span>
<span><span class="co">#绘制随机填充三角形</span></span>
<span><span class="fu">Drawing_Random_Filled_Polygons</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#绘制随机圆（或者随机填充圆）</span></span>
<span><span class="fu">Drawing_Random_Circles</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#在随机位置上绘制文本</span></span>
<span><span class="fu">Displaying_Random_Text</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示大型结束文本</span></span>
<span><span class="fu">Displaying_Big_End</span><span class="op">(</span> <span class="va">image</span>, <span class="va">window_name</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div id="基本阈值运算" class="section level2" number="6.6">
<h2>
<span class="header-section-number">6.6</span> 基本阈值运算<a class="anchor" aria-label="anchor" href="#%E5%9F%BA%E6%9C%AC%E9%98%88%E5%80%BC%E8%BF%90%E7%AE%97"><i class="fas fa-link"></i></a>
</h2>
<p>OpenCV提供<strong>threshold</strong>函数来执行阈值操作。利用该函数可以实现5种阈值运算。</p>
<p>假设一个图像的强度值函数<span class="math inline">\(src(x,y)\)</span>如下图中形成红色区域的折线所示，而其中水平蓝线则表示一个阈值。</p>
<div class="inline-figure"><img src="images/tutorial/Threshold_Tutorial_Theory_Base_Figure.png"></div>
<div id="二值化阈值" class="section level3" number="6.6.1">
<h3>
<span class="header-section-number">6.6.1</span> 二值化阈值<a class="anchor" aria-label="anchor" href="#%E4%BA%8C%E5%80%BC%E5%8C%96%E9%98%88%E5%80%BC"><i class="fas fa-link"></i></a>
</h3>
<p>该阈值运算可以表示为：</p>
<p><span class="math display">\[dst(x,y) = \begin{cases} maxVal &amp; if \; src(x,y)&gt;thresh \\0 &amp; otherwise \end{cases}\]</span></p>
<p>因此，如果像素<span class="math inline">\(src(x,y)\)</span>的强度高于thresh，则新的像素强度被设置为maxVal。否则，像素设置为0。</p>
<div class="inline-figure"><img src="images/tutorial/Threshold_Tutorial_Theory_Binary.png"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb910"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定一个随机种子</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="co">#生成一个10行10列的随机矩阵img_mat，随机数来自于服从均值为50，</span></span>
<span><span class="co">#标准差为20的正态分布</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">100</span>,mean<span class="op">=</span><span class="fl">50</span>,sd<span class="op">=</span><span class="fl">20</span><span class="op">)</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">10</span>,nc<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="co">#通过r2cv函数，将img_mat转为opencv图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">10</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用threshold函数对img进行二值化阈值操作：</span></span>
<span><span class="co">#超过50的像素值取255，小于等于50的像素值取0，</span></span>
<span><span class="co">#阈值化结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_threshold</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="fl">50</span>,<span class="fl">255</span>,<span class="va">THRESH_BINARY</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 50</code></pre>
<div class="sourceCode" id="cb912"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#通过cv2r函数，输出dst的像素矩阵dst_mat</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>原像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">39</td>
<td align="right">74</td>
<td align="right">29</td>
<td align="right">59</td>
<td align="right">36</td>
<td align="right">55</td>
<td align="right">58</td>
<td align="right">40</td>
<td align="right">50</td>
<td align="right">70</td>
</tr>
<tr class="even">
<td align="right">45</td>
<td align="right">57</td>
<td align="right">46</td>
<td align="right">44</td>
<td align="right">46</td>
<td align="right">49</td>
<td align="right">40</td>
<td align="right">4</td>
<td align="right">58</td>
<td align="right">61</td>
</tr>
<tr class="odd">
<td align="right">81</td>
<td align="right">58</td>
<td align="right">29</td>
<td align="right">68</td>
<td align="right">25</td>
<td align="right">49</td>
<td align="right">43</td>
<td align="right">70</td>
<td align="right">43</td>
<td align="right">55</td>
</tr>
<tr class="even">
<td align="right">51</td>
<td align="right">52</td>
<td align="right">35</td>
<td align="right">68</td>
<td align="right">93</td>
<td align="right">77</td>
<td align="right">30</td>
<td align="right">36</td>
<td align="right">63</td>
<td align="right">37</td>
</tr>
<tr class="odd">
<td align="right">53</td>
<td align="right">39</td>
<td align="right">37</td>
<td align="right">66</td>
<td align="right">74</td>
<td align="right">45</td>
<td align="right">29</td>
<td align="right">36</td>
<td align="right">46</td>
<td align="right">77</td>
</tr>
<tr class="even">
<td align="right">84</td>
<td align="right">86</td>
<td align="right">16</td>
<td align="right">64</td>
<td align="right">28</td>
<td align="right">80</td>
<td align="right">56</td>
<td align="right">71</td>
<td align="right">57</td>
<td align="right">38</td>
</tr>
<tr class="odd">
<td align="right">59</td>
<td align="right">60</td>
<td align="right">67</td>
<td align="right">61</td>
<td align="right">42</td>
<td align="right">19</td>
<td align="right">59</td>
<td align="right">44</td>
<td align="right">72</td>
<td align="right">94</td>
</tr>
<tr class="even">
<td align="right">25</td>
<td align="right">11</td>
<td align="right">53</td>
<td align="right">49</td>
<td align="right">41</td>
<td align="right">62</td>
<td align="right">51</td>
<td align="right">26</td>
<td align="right">59</td>
<td align="right">81</td>
</tr>
<tr class="odd">
<td align="right">36</td>
<td align="right">64</td>
<td align="right">27</td>
<td align="right">44</td>
<td align="right">66</td>
<td align="right">52</td>
<td align="right">68</td>
<td align="right">54</td>
<td align="right">43</td>
<td align="right">45</td>
</tr>
<tr class="even">
<td align="right">41</td>
<td align="right">41</td>
<td align="right">75</td>
<td align="right">42</td>
<td align="right">48</td>
<td align="right">54</td>
<td align="right">91</td>
<td align="right">47</td>
<td align="right">73</td>
<td align="right">29</td>
</tr>
</tbody></table></div>
<p>二值化后的像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
</tr>
<tr class="odd">
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
</tr>
<tr class="even">
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
</tr>
<tr class="even">
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
</tr>
</tbody></table></div>
</div>
<div id="逆二值化阈值" class="section level3" number="6.6.2">
<h3>
<span class="header-section-number">6.6.2</span> 逆二值化阈值<a class="anchor" aria-label="anchor" href="#%E9%80%86%E4%BA%8C%E5%80%BC%E5%8C%96%E9%98%88%E5%80%BC"><i class="fas fa-link"></i></a>
</h3>
<p>该阈值运算可以表示为：</p>
<p><span class="math display">\[
dst(x,y) = \begin{cases} 0 &amp; if \; src(x,y)&gt;thresh \\maxVal &amp; otherwise \end{cases}
\]</span></p>
<p>因此，如果像素<span class="math inline">\(src(x,y)\)</span>的强度高于thresh，则新的像素强度被设置为0。否则，像素设置为maxVal。</p>
<div class="inline-figure"><img src="images/tutorial/Threshold_Tutorial_Theory_Binary_Inverted.png"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb913"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 设定一个随机种子</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="co">#生成一个10行10列的随机矩阵img_mat，随机数来自于服从均值为50，</span></span>
<span><span class="co">#标准差为20的正态分布</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">100</span>,mean<span class="op">=</span><span class="fl">50</span>,sd<span class="op">=</span><span class="fl">20</span><span class="op">)</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">10</span>,nc<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="co"># 通过r2cv函数，将img.mat转为opencv图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">10</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用threshold函数对img进行逆二值化阈值操作：</span></span>
<span><span class="co">#超过50的像素值取0，小于等于50的像素值取255，</span></span>
<span><span class="co">#阈值化结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_threshold</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="fl">50</span>,<span class="fl">255</span>,<span class="va">THRESH_BINARY_INV</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 50</code></pre>
<div class="sourceCode" id="cb915"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#通过cv2r函数，输出dst的像素矩阵dst.mat</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>原像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">39</td>
<td align="right">74</td>
<td align="right">29</td>
<td align="right">59</td>
<td align="right">36</td>
<td align="right">55</td>
<td align="right">58</td>
<td align="right">40</td>
<td align="right">50</td>
<td align="right">70</td>
</tr>
<tr class="even">
<td align="right">45</td>
<td align="right">57</td>
<td align="right">46</td>
<td align="right">44</td>
<td align="right">46</td>
<td align="right">49</td>
<td align="right">40</td>
<td align="right">4</td>
<td align="right">58</td>
<td align="right">61</td>
</tr>
<tr class="odd">
<td align="right">81</td>
<td align="right">58</td>
<td align="right">29</td>
<td align="right">68</td>
<td align="right">25</td>
<td align="right">49</td>
<td align="right">43</td>
<td align="right">70</td>
<td align="right">43</td>
<td align="right">55</td>
</tr>
<tr class="even">
<td align="right">51</td>
<td align="right">52</td>
<td align="right">35</td>
<td align="right">68</td>
<td align="right">93</td>
<td align="right">77</td>
<td align="right">30</td>
<td align="right">36</td>
<td align="right">63</td>
<td align="right">37</td>
</tr>
<tr class="odd">
<td align="right">53</td>
<td align="right">39</td>
<td align="right">37</td>
<td align="right">66</td>
<td align="right">74</td>
<td align="right">45</td>
<td align="right">29</td>
<td align="right">36</td>
<td align="right">46</td>
<td align="right">77</td>
</tr>
<tr class="even">
<td align="right">84</td>
<td align="right">86</td>
<td align="right">16</td>
<td align="right">64</td>
<td align="right">28</td>
<td align="right">80</td>
<td align="right">56</td>
<td align="right">71</td>
<td align="right">57</td>
<td align="right">38</td>
</tr>
<tr class="odd">
<td align="right">59</td>
<td align="right">60</td>
<td align="right">67</td>
<td align="right">61</td>
<td align="right">42</td>
<td align="right">19</td>
<td align="right">59</td>
<td align="right">44</td>
<td align="right">72</td>
<td align="right">94</td>
</tr>
<tr class="even">
<td align="right">25</td>
<td align="right">11</td>
<td align="right">53</td>
<td align="right">49</td>
<td align="right">41</td>
<td align="right">62</td>
<td align="right">51</td>
<td align="right">26</td>
<td align="right">59</td>
<td align="right">81</td>
</tr>
<tr class="odd">
<td align="right">36</td>
<td align="right">64</td>
<td align="right">27</td>
<td align="right">44</td>
<td align="right">66</td>
<td align="right">52</td>
<td align="right">68</td>
<td align="right">54</td>
<td align="right">43</td>
<td align="right">45</td>
</tr>
<tr class="even">
<td align="right">41</td>
<td align="right">41</td>
<td align="right">75</td>
<td align="right">42</td>
<td align="right">48</td>
<td align="right">54</td>
<td align="right">91</td>
<td align="right">47</td>
<td align="right">73</td>
<td align="right">29</td>
</tr>
</tbody></table></div>
<p>逆二值化后的像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
</tr>
<tr class="even">
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">255</td>
<td align="right">0</td>
<td align="right">255</td>
</tr>
</tbody></table></div>
</div>
<div id="截断" class="section level3" number="6.6.3">
<h3>
<span class="header-section-number">6.6.3</span> 截断<a class="anchor" aria-label="anchor" href="#%E6%88%AA%E6%96%AD"><i class="fas fa-link"></i></a>
</h3>
<p>该阈值运算可以表示为：</p>
<p><span class="math display">\[
dst(x,y) = \begin{cases} thresh &amp; if \; src(x,y)&gt;thresh \\src(x,y) &amp; otherwise \end{cases}
\]</span></p>
<p>因此，如果像素<span class="math inline">\(src(x,y)\)</span>的强度高于thresh，则新的像素强度被截断为thresh。</p>
<div class="inline-figure"><img src="images/tutorial/Threshold_Tutorial_Theory_Truncate.png"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb916"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 设定一个随机种子</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="co">#生成一个10行10列的随机矩阵img.mat，随机数来自于服从均值为50，</span></span>
<span><span class="co">#标准差为20的正态分布</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">100</span>,mean<span class="op">=</span><span class="fl">50</span>,sd<span class="op">=</span><span class="fl">20</span><span class="op">)</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">10</span>,nc<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="co"># 通过r2cv函数，将img.mat转为opencv图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">10</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用threshold函数对img进行上截断阈值操作：</span></span>
<span><span class="co">#超过50的像素值取50，小于等于50的像素值保持不变，</span></span>
<span><span class="co">#阈值化结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_threshold</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="fl">50</span>,<span class="fl">255</span>,<span class="va">THRESH_TRUNC</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 50</code></pre>
<div class="sourceCode" id="cb918"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 通过cv2r函数，输出dst的像素矩阵dst.mat</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>原像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">39</td>
<td align="right">74</td>
<td align="right">29</td>
<td align="right">59</td>
<td align="right">36</td>
<td align="right">55</td>
<td align="right">58</td>
<td align="right">40</td>
<td align="right">50</td>
<td align="right">70</td>
</tr>
<tr class="even">
<td align="right">45</td>
<td align="right">57</td>
<td align="right">46</td>
<td align="right">44</td>
<td align="right">46</td>
<td align="right">49</td>
<td align="right">40</td>
<td align="right">4</td>
<td align="right">58</td>
<td align="right">61</td>
</tr>
<tr class="odd">
<td align="right">81</td>
<td align="right">58</td>
<td align="right">29</td>
<td align="right">68</td>
<td align="right">25</td>
<td align="right">49</td>
<td align="right">43</td>
<td align="right">70</td>
<td align="right">43</td>
<td align="right">55</td>
</tr>
<tr class="even">
<td align="right">51</td>
<td align="right">52</td>
<td align="right">35</td>
<td align="right">68</td>
<td align="right">93</td>
<td align="right">77</td>
<td align="right">30</td>
<td align="right">36</td>
<td align="right">63</td>
<td align="right">37</td>
</tr>
<tr class="odd">
<td align="right">53</td>
<td align="right">39</td>
<td align="right">37</td>
<td align="right">66</td>
<td align="right">74</td>
<td align="right">45</td>
<td align="right">29</td>
<td align="right">36</td>
<td align="right">46</td>
<td align="right">77</td>
</tr>
<tr class="even">
<td align="right">84</td>
<td align="right">86</td>
<td align="right">16</td>
<td align="right">64</td>
<td align="right">28</td>
<td align="right">80</td>
<td align="right">56</td>
<td align="right">71</td>
<td align="right">57</td>
<td align="right">38</td>
</tr>
<tr class="odd">
<td align="right">59</td>
<td align="right">60</td>
<td align="right">67</td>
<td align="right">61</td>
<td align="right">42</td>
<td align="right">19</td>
<td align="right">59</td>
<td align="right">44</td>
<td align="right">72</td>
<td align="right">94</td>
</tr>
<tr class="even">
<td align="right">25</td>
<td align="right">11</td>
<td align="right">53</td>
<td align="right">49</td>
<td align="right">41</td>
<td align="right">62</td>
<td align="right">51</td>
<td align="right">26</td>
<td align="right">59</td>
<td align="right">81</td>
</tr>
<tr class="odd">
<td align="right">36</td>
<td align="right">64</td>
<td align="right">27</td>
<td align="right">44</td>
<td align="right">66</td>
<td align="right">52</td>
<td align="right">68</td>
<td align="right">54</td>
<td align="right">43</td>
<td align="right">45</td>
</tr>
<tr class="even">
<td align="right">41</td>
<td align="right">41</td>
<td align="right">75</td>
<td align="right">42</td>
<td align="right">48</td>
<td align="right">54</td>
<td align="right">91</td>
<td align="right">47</td>
<td align="right">73</td>
<td align="right">29</td>
</tr>
</tbody></table></div>
<p>上截断后的像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">39</td>
<td align="right">50</td>
<td align="right">29</td>
<td align="right">50</td>
<td align="right">36</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">40</td>
<td align="right">50</td>
<td align="right">50</td>
</tr>
<tr class="even">
<td align="right">45</td>
<td align="right">50</td>
<td align="right">46</td>
<td align="right">44</td>
<td align="right">46</td>
<td align="right">49</td>
<td align="right">40</td>
<td align="right">4</td>
<td align="right">50</td>
<td align="right">50</td>
</tr>
<tr class="odd">
<td align="right">50</td>
<td align="right">50</td>
<td align="right">29</td>
<td align="right">50</td>
<td align="right">25</td>
<td align="right">49</td>
<td align="right">43</td>
<td align="right">50</td>
<td align="right">43</td>
<td align="right">50</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">50</td>
<td align="right">35</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">30</td>
<td align="right">36</td>
<td align="right">50</td>
<td align="right">37</td>
</tr>
<tr class="odd">
<td align="right">50</td>
<td align="right">39</td>
<td align="right">37</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">45</td>
<td align="right">29</td>
<td align="right">36</td>
<td align="right">46</td>
<td align="right">50</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">50</td>
<td align="right">16</td>
<td align="right">50</td>
<td align="right">28</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">38</td>
</tr>
<tr class="odd">
<td align="right">50</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">42</td>
<td align="right">19</td>
<td align="right">50</td>
<td align="right">44</td>
<td align="right">50</td>
<td align="right">50</td>
</tr>
<tr class="even">
<td align="right">25</td>
<td align="right">11</td>
<td align="right">50</td>
<td align="right">49</td>
<td align="right">41</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">26</td>
<td align="right">50</td>
<td align="right">50</td>
</tr>
<tr class="odd">
<td align="right">36</td>
<td align="right">50</td>
<td align="right">27</td>
<td align="right">44</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">43</td>
<td align="right">45</td>
</tr>
<tr class="even">
<td align="right">41</td>
<td align="right">41</td>
<td align="right">50</td>
<td align="right">42</td>
<td align="right">48</td>
<td align="right">50</td>
<td align="right">50</td>
<td align="right">47</td>
<td align="right">50</td>
<td align="right">29</td>
</tr>
</tbody></table></div>
</div>
<div id="下折断阈值以下为0" class="section level3" number="6.6.4">
<h3>
<span class="header-section-number">6.6.4</span> 下折断（阈值以下为0）<a class="anchor" aria-label="anchor" href="#%E4%B8%8B%E6%8A%98%E6%96%AD%E9%98%88%E5%80%BC%E4%BB%A5%E4%B8%8B%E4%B8%BA0"><i class="fas fa-link"></i></a>
</h3>
<p>此操作可以表示为：</p>
<p><span class="math display">\[
dst(x,y) = \begin{cases} src(x,y) &amp; if \; src(x,y)&gt;thresh \\0 &amp; otherwise \end{cases}
\]</span></p>
<p>因此，如果像素<span class="math inline">\(src(x,y)\)</span>的强度低于thresh，则新的像素强度被截断为0。</p>
<div class="inline-figure"><img src="images/tutorial/Threshold_Tutorial_Theory_Zero.png"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb919"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定一个随机种子</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="co">#生成一个10行10列的随机矩阵img_mat，随机数来自于服从均值为50，</span></span>
<span><span class="co">#标准差为20的正态分布</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">100</span>,mean<span class="op">=</span><span class="fl">50</span>,sd<span class="op">=</span><span class="fl">20</span><span class="op">)</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">10</span>,nc<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="co"># 通过r2cv函数，将img_mat转为opencv图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">10</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用threshold函数对img进行下折断阈值操作：</span></span>
<span><span class="co">#超过50的像素值保持不变，小于等于50的像素值取0，</span></span>
<span><span class="co">#阈值化结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_threshold</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="fl">50</span>,<span class="fl">255</span>,<span class="va">THRESH_TOZERO</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 50</code></pre>
<div class="sourceCode" id="cb921"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 通过cv2r函数，输出dst的像素矩阵dst.mat</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>原像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">39</td>
<td align="right">74</td>
<td align="right">29</td>
<td align="right">59</td>
<td align="right">36</td>
<td align="right">55</td>
<td align="right">58</td>
<td align="right">40</td>
<td align="right">50</td>
<td align="right">70</td>
</tr>
<tr class="even">
<td align="right">45</td>
<td align="right">57</td>
<td align="right">46</td>
<td align="right">44</td>
<td align="right">46</td>
<td align="right">49</td>
<td align="right">40</td>
<td align="right">4</td>
<td align="right">58</td>
<td align="right">61</td>
</tr>
<tr class="odd">
<td align="right">81</td>
<td align="right">58</td>
<td align="right">29</td>
<td align="right">68</td>
<td align="right">25</td>
<td align="right">49</td>
<td align="right">43</td>
<td align="right">70</td>
<td align="right">43</td>
<td align="right">55</td>
</tr>
<tr class="even">
<td align="right">51</td>
<td align="right">52</td>
<td align="right">35</td>
<td align="right">68</td>
<td align="right">93</td>
<td align="right">77</td>
<td align="right">30</td>
<td align="right">36</td>
<td align="right">63</td>
<td align="right">37</td>
</tr>
<tr class="odd">
<td align="right">53</td>
<td align="right">39</td>
<td align="right">37</td>
<td align="right">66</td>
<td align="right">74</td>
<td align="right">45</td>
<td align="right">29</td>
<td align="right">36</td>
<td align="right">46</td>
<td align="right">77</td>
</tr>
<tr class="even">
<td align="right">84</td>
<td align="right">86</td>
<td align="right">16</td>
<td align="right">64</td>
<td align="right">28</td>
<td align="right">80</td>
<td align="right">56</td>
<td align="right">71</td>
<td align="right">57</td>
<td align="right">38</td>
</tr>
<tr class="odd">
<td align="right">59</td>
<td align="right">60</td>
<td align="right">67</td>
<td align="right">61</td>
<td align="right">42</td>
<td align="right">19</td>
<td align="right">59</td>
<td align="right">44</td>
<td align="right">72</td>
<td align="right">94</td>
</tr>
<tr class="even">
<td align="right">25</td>
<td align="right">11</td>
<td align="right">53</td>
<td align="right">49</td>
<td align="right">41</td>
<td align="right">62</td>
<td align="right">51</td>
<td align="right">26</td>
<td align="right">59</td>
<td align="right">81</td>
</tr>
<tr class="odd">
<td align="right">36</td>
<td align="right">64</td>
<td align="right">27</td>
<td align="right">44</td>
<td align="right">66</td>
<td align="right">52</td>
<td align="right">68</td>
<td align="right">54</td>
<td align="right">43</td>
<td align="right">45</td>
</tr>
<tr class="even">
<td align="right">41</td>
<td align="right">41</td>
<td align="right">75</td>
<td align="right">42</td>
<td align="right">48</td>
<td align="right">54</td>
<td align="right">91</td>
<td align="right">47</td>
<td align="right">73</td>
<td align="right">29</td>
</tr>
</tbody></table></div>
<p>下折断后的像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">74</td>
<td align="right">0</td>
<td align="right">59</td>
<td align="right">0</td>
<td align="right">55</td>
<td align="right">58</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">70</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">57</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">58</td>
<td align="right">61</td>
</tr>
<tr class="odd">
<td align="right">81</td>
<td align="right">58</td>
<td align="right">0</td>
<td align="right">68</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">70</td>
<td align="right">0</td>
<td align="right">55</td>
</tr>
<tr class="even">
<td align="right">51</td>
<td align="right">52</td>
<td align="right">0</td>
<td align="right">68</td>
<td align="right">93</td>
<td align="right">77</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">63</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">53</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">66</td>
<td align="right">74</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">77</td>
</tr>
<tr class="even">
<td align="right">84</td>
<td align="right">86</td>
<td align="right">0</td>
<td align="right">64</td>
<td align="right">0</td>
<td align="right">80</td>
<td align="right">56</td>
<td align="right">71</td>
<td align="right">57</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">59</td>
<td align="right">60</td>
<td align="right">67</td>
<td align="right">61</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">59</td>
<td align="right">0</td>
<td align="right">72</td>
<td align="right">94</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">53</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">62</td>
<td align="right">51</td>
<td align="right">0</td>
<td align="right">59</td>
<td align="right">81</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">64</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">66</td>
<td align="right">52</td>
<td align="right">68</td>
<td align="right">54</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">75</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">54</td>
<td align="right">91</td>
<td align="right">0</td>
<td align="right">73</td>
<td align="right">0</td>
</tr>
</tbody></table></div>
</div>
<div id="上折断阈值以上为0" class="section level3" number="6.6.5">
<h3>
<span class="header-section-number">6.6.5</span> 上折断（阈值以上为0）<a class="anchor" aria-label="anchor" href="#%E4%B8%8A%E6%8A%98%E6%96%AD%E9%98%88%E5%80%BC%E4%BB%A5%E4%B8%8A%E4%B8%BA0"><i class="fas fa-link"></i></a>
</h3>
<p>此操作可以表示为：</p>
<p><span class="math display">\[
dst(x,y) = \begin{cases} 0 &amp; if \; src(x,y)&gt;thresh \\src(x,y) &amp; otherwise \end{cases}
\]</span></p>
<p>因此，如果像素<span class="math inline">\(src(x,y)\)</span>的强度高于thresh，则新的像素强度被阶段为0。</p>
<div class="inline-figure"><img src="images/tutorial/Threshold_Tutorial_Theory_Zero_Inverted.png"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb922"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定一个随机种子</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="co">#生成一个10行10列的随机矩阵img_mat，随机数来自于服从均值为50，</span></span>
<span><span class="co">#标准差为20的正态分布</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="fl">100</span>,mean<span class="op">=</span><span class="fl">50</span>,sd<span class="op">=</span><span class="fl">20</span><span class="op">)</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">10</span>,nc<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="co"># 通过r2cv函数，将img_mat转为opencv图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">10</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用threshold函数对img进行二值化阈值操作：</span></span>
<span><span class="co">#超过50的像素值取0，小于等于50的像素值保持不变，</span></span>
<span><span class="co">#阈值化结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_threshold</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="fl">50</span>,<span class="fl">255</span>,<span class="va">THRESH_TOZERO_INV</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 50</code></pre>
<div class="sourceCode" id="cb924"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 通过cv2r函数，输出dst的像素矩阵dst_mat</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>原像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">39</td>
<td align="right">74</td>
<td align="right">29</td>
<td align="right">59</td>
<td align="right">36</td>
<td align="right">55</td>
<td align="right">58</td>
<td align="right">40</td>
<td align="right">50</td>
<td align="right">70</td>
</tr>
<tr class="even">
<td align="right">45</td>
<td align="right">57</td>
<td align="right">46</td>
<td align="right">44</td>
<td align="right">46</td>
<td align="right">49</td>
<td align="right">40</td>
<td align="right">4</td>
<td align="right">58</td>
<td align="right">61</td>
</tr>
<tr class="odd">
<td align="right">81</td>
<td align="right">58</td>
<td align="right">29</td>
<td align="right">68</td>
<td align="right">25</td>
<td align="right">49</td>
<td align="right">43</td>
<td align="right">70</td>
<td align="right">43</td>
<td align="right">55</td>
</tr>
<tr class="even">
<td align="right">51</td>
<td align="right">52</td>
<td align="right">35</td>
<td align="right">68</td>
<td align="right">93</td>
<td align="right">77</td>
<td align="right">30</td>
<td align="right">36</td>
<td align="right">63</td>
<td align="right">37</td>
</tr>
<tr class="odd">
<td align="right">53</td>
<td align="right">39</td>
<td align="right">37</td>
<td align="right">66</td>
<td align="right">74</td>
<td align="right">45</td>
<td align="right">29</td>
<td align="right">36</td>
<td align="right">46</td>
<td align="right">77</td>
</tr>
<tr class="even">
<td align="right">84</td>
<td align="right">86</td>
<td align="right">16</td>
<td align="right">64</td>
<td align="right">28</td>
<td align="right">80</td>
<td align="right">56</td>
<td align="right">71</td>
<td align="right">57</td>
<td align="right">38</td>
</tr>
<tr class="odd">
<td align="right">59</td>
<td align="right">60</td>
<td align="right">67</td>
<td align="right">61</td>
<td align="right">42</td>
<td align="right">19</td>
<td align="right">59</td>
<td align="right">44</td>
<td align="right">72</td>
<td align="right">94</td>
</tr>
<tr class="even">
<td align="right">25</td>
<td align="right">11</td>
<td align="right">53</td>
<td align="right">49</td>
<td align="right">41</td>
<td align="right">62</td>
<td align="right">51</td>
<td align="right">26</td>
<td align="right">59</td>
<td align="right">81</td>
</tr>
<tr class="odd">
<td align="right">36</td>
<td align="right">64</td>
<td align="right">27</td>
<td align="right">44</td>
<td align="right">66</td>
<td align="right">52</td>
<td align="right">68</td>
<td align="right">54</td>
<td align="right">43</td>
<td align="right">45</td>
</tr>
<tr class="even">
<td align="right">41</td>
<td align="right">41</td>
<td align="right">75</td>
<td align="right">42</td>
<td align="right">48</td>
<td align="right">54</td>
<td align="right">91</td>
<td align="right">47</td>
<td align="right">73</td>
<td align="right">29</td>
</tr>
</tbody></table></div>
<p>上折断后的像素值：</p>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">39</td>
<td align="right">0</td>
<td align="right">29</td>
<td align="right">0</td>
<td align="right">36</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">40</td>
<td align="right">50</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">45</td>
<td align="right">0</td>
<td align="right">46</td>
<td align="right">44</td>
<td align="right">46</td>
<td align="right">49</td>
<td align="right">40</td>
<td align="right">4</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">29</td>
<td align="right">0</td>
<td align="right">25</td>
<td align="right">49</td>
<td align="right">43</td>
<td align="right">0</td>
<td align="right">43</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">35</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">30</td>
<td align="right">36</td>
<td align="right">0</td>
<td align="right">37</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">39</td>
<td align="right">37</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">45</td>
<td align="right">29</td>
<td align="right">36</td>
<td align="right">46</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">16</td>
<td align="right">0</td>
<td align="right">28</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">38</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">42</td>
<td align="right">19</td>
<td align="right">0</td>
<td align="right">44</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">25</td>
<td align="right">11</td>
<td align="right">0</td>
<td align="right">49</td>
<td align="right">41</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">26</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">36</td>
<td align="right">0</td>
<td align="right">27</td>
<td align="right">44</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">43</td>
<td align="right">45</td>
</tr>
<tr class="even">
<td align="right">41</td>
<td align="right">41</td>
<td align="right">0</td>
<td align="right">42</td>
<td align="right">48</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">47</td>
<td align="right">0</td>
<td align="right">29</td>
</tr>
</tbody></table></div>
</div>
<div id="应用示例" class="section level3" number="6.6.6">
<h3>
<span class="header-section-number">6.6.6</span> 应用示例<a class="anchor" aria-label="anchor" href="#%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><i class="fas fa-link"></i></a>
</h3>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb925"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#定义滑动条响应函数Threshold_Demo</span></span>
<span><span class="va">Threshold_Demo</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">param</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#阈值运算类型：</span></span>
<span>  <span class="co">#0: Binary（二值化）</span></span>
<span>  <span class="co">#1: Binary Inverted（逆二值化）</span></span>
<span>  <span class="co">#2: Threshold Truncated（截断）</span></span>
<span>  <span class="co">#3: Threshold to Zero（下折断）</span></span>
<span>  <span class="co">#4: Threshold to Zero Inverted（上折断）</span></span>
<span>  </span>
<span>  <span class="co">#获取控制阈值类型的滑动条的当前值</span></span>
<span>  <span class="va">threshold_type</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="va">trackbar_type</span>,<span class="va">window_name</span><span class="op">)</span></span>
<span>  <span class="co">#获取控制阈值的滑动条的当前值</span></span>
<span>  <span class="va">threshold_value</span> <span class="op">&lt;&lt;-</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="va">trackbar_value</span>,<span class="va">window_name</span><span class="op">)</span></span>
<span>  <span class="co">#对src进行相应的阈值运算，结果保存在dst中</span></span>
<span>  <span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_threshold</span><span class="op">(</span><span class="va">src</span>, <span class="va">dst</span>, <span class="va">threshold_value</span>, <span class="fl">255</span>, <span class="va">threshold_type</span> <span class="op">)</span></span>
<span>  <span class="co">#在图形窗口中显示dst</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span> <span class="va">window_name</span>, <span class="va">dst</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#设定图形窗口的标题</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Threshold Demo"</span></span>
<span><span class="co">#设定控制阈值类型的滑动条名称</span></span>
<span><span class="va">trackbar_type</span> <span class="op">=</span> <span class="st">"Type："</span></span>
<span><span class="co">#设定控制阈值的滑动条名称</span></span>
<span><span class="va">trackbar_value</span> <span class="op">=</span> <span class="st">"Value："</span></span>
<span></span>
<span><span class="co">#生成矩阵arr</span></span>
<span><span class="va">arr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">512</span>,nc<span class="op">=</span><span class="fl">512</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">256</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">arr</span><span class="op">[</span><span class="fl">2</span><span class="op">*</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span>,<span class="op">]</span> <span class="op">=</span> <span class="va">i</span><span class="op">-</span><span class="fl">1</span></span>
<span>  <span class="va">arr</span><span class="op">[</span><span class="fl">2</span><span class="op">*</span><span class="va">i</span>,<span class="op">]</span> <span class="op">=</span> <span class="va">i</span><span class="op">-</span><span class="fl">1</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#将arr转变为OpenCV的图像矩阵src</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">512</span>,<span class="fl">512</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">src</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">arr</span><span class="op">)</span></span>
<span><span class="co">#生成图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口创建控制阈值类型的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="va">trackbar_type</span>,<span class="va">window_name</span>,<span class="fl">3</span>,<span class="fl">4</span>,<span class="va">Threshold_Demo</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口中创建控制阈值的互动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="va">trackbar_value</span>,<span class="va">window_name</span>,<span class="fl">0</span>,<span class="fl">255</span>,<span class="va">Threshold_Demo</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#调用Threshold_Demo函数</span></span>
<span><span class="fu">Threshold_Demo</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>将上面代码中的：</p>
<pre><code>#生成矩阵arr
arr = matrix(0,nr=512,nc=512)
for(i in 1:256){
  arr[2*i-1,] = i-1
  arr[2*i,] = i-1
}
#将arr转变为OpenCV的图像矩阵src
src = Mat(512,512,CV_8UC1)
src$r2cv(arr)</code></pre>
<p>改成：</p>
<pre><code>src = cv_imread("images/chicky_512.png",IMREAD_GRAYSCALE)</code></pre>
<p>则可以看到用阈值运算对小狗图片形成的效果（如下图）：</p>
<div class="inline-figure"><img src="images/thresholdDemo.png"></div>
<p><strong>示例</strong></p>
<p>可以只对图像的部分区域进行阈值操作：</p>
<div class="sourceCode" id="cb928"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#定义滑动条响应函数Threshold_Demo</span></span>
<span><span class="va">Threshold_Demo</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">param</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#阈值运算类型：</span></span>
<span>  <span class="co">#0: Binary（二值化）</span></span>
<span>  <span class="co">#1: Binary Inverted（逆二值化）</span></span>
<span>  <span class="co">#2: Threshold Truncated（截断）</span></span>
<span>  <span class="co">#3: Threshold to Zero（下折断）</span></span>
<span>  <span class="co">#4: Threshold to Zero Inverted（上折断）</span></span>
<span>  </span>
<span>  <span class="co">#获取控制阈值类型的滑动条的当前值</span></span>
<span>  <span class="va">threshold_type</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="va">trackbar_type</span>,<span class="va">window_name</span><span class="op">)</span></span>
<span>  <span class="co">#获取控制阈值的滑动条的当前值</span></span>
<span>  <span class="va">threshold_value</span> <span class="op">&lt;&lt;-</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="va">trackbar_value</span>,<span class="va">window_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#从src生成拷贝体，并设定感兴趣区域roi为小狗的头部区域</span></span>
<span>  <span class="va">res</span> <span class="op">=</span> <span class="va">src</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">roi</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="va">res</span>,<span class="fu">Rect</span><span class="op">(</span><span class="fl">150</span>,<span class="fl">70</span>,<span class="fl">250</span>,<span class="fl">280</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#对roi区域进行相应的阈值运算，结果保存在dst中</span></span>
<span>  <span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_threshold</span><span class="op">(</span><span class="va">roi</span>, <span class="va">dst</span>, <span class="va">threshold_value</span>, <span class="fl">255</span>, <span class="va">threshold_type</span> <span class="op">)</span></span>
<span>  <span class="co">#将dst中的阈值化结果拷贝到roi区域中</span></span>
<span>  <span class="va">dst</span><span class="op">$</span><span class="fu">copyTo</span><span class="op">(</span><span class="va">roi</span><span class="op">)</span></span>
<span>  <span class="co">#显示结果</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span> <span class="va">window_name</span>, <span class="va">res</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#设定图形窗口的标题</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Threshold Demo"</span></span>
<span><span class="co">#设定控制阈值类型的滑动条名称</span></span>
<span><span class="va">trackbar_type</span> <span class="op">=</span> <span class="st">"Type："</span></span>
<span><span class="co">#设定控制阈值的滑动条名称</span></span>
<span><span class="va">trackbar_value</span> <span class="op">=</span> <span class="st">"Value："</span></span>
<span></span>
<span><span class="co">#以灰度图模式读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/chicky_512.png"</span>,<span class="va">IMREAD_GRAYSCALE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口创建控制阈值类型的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="va">trackbar_type</span>,<span class="va">window_name</span>,<span class="fl">3</span>,<span class="fl">4</span>,<span class="va">Threshold_Demo</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口中创建控制阈值的互动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="va">trackbar_value</span>,<span class="va">window_name</span>,<span class="fl">0</span>,<span class="fl">255</span>,<span class="va">Threshold_Demo</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#调用Threshold_Demo函数</span></span>
<span><span class="fu">Threshold_Demo</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/thresholdDemo1.png"></div>
</div>
</div>
<div id="使用inrange进行阈值运算" class="section level2" number="6.7">
<h2>
<span class="header-section-number">6.7</span> 使用inRange进行阈值运算<a class="anchor" aria-label="anchor" href="#%E4%BD%BF%E7%94%A8inrange%E8%BF%9B%E8%A1%8C%E9%98%88%E5%80%BC%E8%BF%90%E7%AE%97"><i class="fas fa-link"></i></a>
</h2>
<div id="hsv色彩空间" class="section level3" number="6.7.1">
<h3>
<span class="header-section-number">6.7.1</span> HSV色彩空间<a class="anchor" aria-label="anchor" href="#hsv%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4"><i class="fas fa-link"></i></a>
</h3>
<p>HSV（hue，saturation，value）颜色空间是一种表示颜色空间的模型，类似于RGB颜色模型。由于使用色调通道对颜色类型进行建模，因此在需要根据颜色分割对象的图像处理任务中非常有用。饱和度的变化从不饱和到表示灰度和完全饱和（无白色成分）。值通道描述颜色的亮度或强度。下一幅图显示了HSV柱体。</p>
<div class="inline-figure"><img src="images/tutorial/Threshold_inRange_HSV_colorspace.jpg"></div>
<p>由于RGB颜色空间中的颜色是使用三个通道进行编码的，因此基于颜色分割图像中的对象更加困难。</p>
<div class="inline-figure"><img src="images/tutorial/Threshold_inRange_RGB_colorspace.jpg"></div>
<p>关于于使用<strong>cvtColor</strong>函数从一个颜色空间转换到另一个颜色空间的公式在”颜色转换”中有说明。</p>
</div>
<div id="计算bgr颜色空间中指定颜色对应的hsv颜色值" class="section level3" number="6.7.2">
<h3>
<span class="header-section-number">6.7.2</span> 计算BGR颜色空间中指定颜色对应的HSV颜色值<a class="anchor" aria-label="anchor" href="#%E8%AE%A1%E7%AE%97bgr%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%8C%87%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%AF%B9%E5%BA%94%E7%9A%84hsv%E9%A2%9C%E8%89%B2%E5%80%BC"><i class="fas fa-link"></i></a>
</h3>
<p>BGR中的蓝色映射到HSV颜色空间：</p>
<div class="sourceCode" id="cb929"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成只含一个像素的OpenCV图像矩阵img</span></span>
<span><span class="va">img</span><span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span><span class="co">#将像素值设定为蓝色</span></span>
<span><span class="va">img</span><span class="op">[</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将img的颜色空间从BGR转为HSV，结果保存在res中</span></span>
<span><span class="va">res</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">img</span>,<span class="va">res</span>,<span class="va">COLOR_BGR2HSV</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看像素的值，结果表明：</span></span>
<span><span class="co">#BGR颜色空间中的蓝色映射到HSV颜色空间后为c(120,255,255)，</span></span>
<span><span class="co">#即H分量为120，S和V分量都为255</span></span>
<span><span class="va">res</span><span class="op">[</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">]</span></span></code></pre></div>
<pre><code>## [1] 120 255 255</code></pre>
<p>将上面代码中：</p>
<pre><code>#将像素值设定为蓝色
img[0,0] = c(255,0,0)</code></pre>
<p>改为：</p>
<div class="sourceCode" id="cb932"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#将像素值设定为绿色</span></span>
<span><span class="va">img</span><span class="op">[</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">255</span>,<span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>可以得到BGR中的绿色映射到HSV颜色空间后的值为(60,255,255)：</p>
<pre><code>## [1]  60 255 255</code></pre>
<p>若将上面代码中：</p>
<pre><code>#将像素值设定为蓝色
img[0,0] = c(255,0,0)</code></pre>
<p>改为：</p>
<div class="sourceCode" id="cb935"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#将像素值设定为红色</span></span>
<span><span class="va">img</span><span class="op">[</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span></span></code></pre></div>
<p>可以得到BGR中的红色映射到HSV颜色空间后的值为(0,255,255)：</p>
<pre><code>## [1]   0 255 255</code></pre>
<p>进一步，可以通过调用如下函数计算BGR颜色空间中任一颜色对应的HSV颜色值。</p>
<div class="sourceCode" id="cb937"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bgr2hsv</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">bgr_val</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">bgr_val</span><span class="op">)</span><span class="op">!=</span><span class="fl">3</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/stop.html">stop</a></span><span class="op">(</span><span class="st">"需要蓝色、绿色和红色三个颜色分量"</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#生成只含一个像素的OpenCV图像矩阵img</span></span>
<span>  <span class="va">img</span><span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span>  <span class="co">#将像素值设定函数参数对应的值</span></span>
<span>  <span class="va">img</span><span class="op">[</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">]</span> <span class="op">=</span> <span class="va">bgr_val</span></span>
<span>  </span>
<span>  <span class="co">#将img的颜色空间从BGR转为HSV，结果保存在res中</span></span>
<span>  <span class="va">res</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">img</span>,<span class="va">res</span>,<span class="va">COLOR_BGR2HSV</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#返回像素的值</span></span>
<span>  <span class="va">hsv</span> <span class="op">=</span> <span class="va">res</span><span class="op">[</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">]</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">hsv</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"H"</span>,<span class="st">"S"</span>,<span class="st">"V"</span><span class="op">)</span></span>
<span>  <span class="va">hsv</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#调用示例</span></span>
<span><span class="fu">bgr2hsv</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">60</span>,<span class="fl">120</span>,<span class="fl">90</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>##   H   S   V 
##  45 128 120</code></pre>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb939"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成尺寸为300 X 300的opencv全黑图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">300</span>,<span class="fl">300</span>,<span class="va">CV_8UC3</span><span class="op">)</span></span>
<span><span class="co">#绘制红色填充圆</span></span>
<span><span class="fu">cv_circle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">50</span>,<span class="fl">50</span><span class="op">)</span>,<span class="fl">45</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">255</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#绘制绿色填充矩形</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span><span class="va">img</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">100</span>,<span class="fl">100</span><span class="op">)</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">180</span>,<span class="fl">180</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">255</span>,<span class="fl">0</span><span class="op">)</span>,<span class="op">-</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#绘制蓝色填充三角形</span></span>
<span><span class="va">pnts</span> <span class="op">=</span> <span class="fu">stdVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">pnts</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">200</span>,<span class="fl">200</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pnts</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">280</span>,<span class="fl">280</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">pnts</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="fu">Point</span><span class="op">(</span><span class="fl">280</span>,<span class="fl">200</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">poly</span> <span class="op">=</span> <span class="fu">stdVecOfVecOfPoint</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">poly</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">pnts</span><span class="op">)</span></span>
<span><span class="fu">cv_fillPoly</span><span class="op">(</span><span class="va">img</span>,</span>
<span>              <span class="va">poly</span>,</span>
<span>              <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#显示img</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'img'</span>,<span class="va">img</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-126-1.png" width="672"></div>
<p>通过一下代码可以区别出图像中的红色填充圆：</p>
<div class="sourceCode" id="cb940"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定HSV颜色空间中待识别的颜色范围（是针对红色识别的范围）</span></span>
<span><span class="va">lower</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="op">-</span><span class="fl">10</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span></span>
<span><span class="va">upper</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="fl">10</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将img的颜色空间由BGR转为HSV，结果保存在hsv中</span></span>
<span><span class="va">hsv</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">img</span>,<span class="va">hsv</span>,<span class="va">COLOR_BGR2HSV</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#检查hsv的哪些像素的颜色介于待识别的颜色范围之中，结果保存在mask中</span></span>
<span><span class="va">mask</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_inRange</span><span class="op">(</span><span class="va">hsv</span>,<span class="va">lower</span>,<span class="va">upper</span>,<span class="va">mask</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#基于mask，让img与其自身进行按位与运算，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_and</span><span class="op">(</span><span class="va">img</span>,<span class="va">img</span>,<span class="va">dst</span>,<span class="va">mask</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb941"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">matImgPlot</span><span class="op">(</span><span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-128-1.png" width="672"></div>
<p>将代码中的</p>
<pre><code>#设定HSV颜色空间中待识别的颜色范围（是针对红色识别的范围）
lower = c(-10,255,255)
upper = c(10,255,255)</code></pre>
<p>改为：</p>
<div class="sourceCode" id="cb943"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定HSV颜色空间中待识别的颜色范围（是针对绿色识别的范围）</span></span>
<span><span class="va">lower</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="fl">50</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span></span>
<span><span class="va">upper</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="fl">70</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span></span></code></pre></div>
<p>可以区别出图像中的绿色填充矩形：</p>
<div class="sourceCode" id="cb944"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">matImgPlot</span><span class="op">(</span><span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-131-1.png" width="672"></div>
<p>将代码中的</p>
<pre><code>#设定HSV颜色空间中待识别的颜色范围（是针对红色识别的范围）
lower = Scalar(-10,255,255)
upper = Scalar(10,255,255)</code></pre>
<p>改为：</p>
<div class="sourceCode" id="cb946"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定HSV颜色空间中待识别的颜色范围（是针对蓝色识别的范围）</span></span>
<span><span class="va">lower</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="fl">110</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span></span>
<span><span class="va">upper</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="fl">130</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span></span></code></pre></div>
<p>可以区别出图像中的蓝色填充三角形：</p>
<div class="sourceCode" id="cb947"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">matImgPlot</span><span class="op">(</span><span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-134-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>改造上例，通过滑动条实现交互性控制：</p>
<div class="inline-figure"><img src="images/hsvInRange.png"></div>
<div class="sourceCode" id="cb948"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定图形窗口标题</span></span>
<span><span class="va">win_name</span> <span class="op">=</span> <span class="st">"Object Detection"</span></span>
<span></span>
<span><span class="co">#定义滑动条响应函数OnScroll</span></span>
<span><span class="va">onScroll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">param</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#获取控制H分量下界的滑动条的当前值</span></span>
<span>  <span class="va">low_H</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"LowH"</span>,<span class="va">win_name</span><span class="op">)</span></span>
<span>  <span class="co">#获取控制H分量上界的滑动条的当前值</span></span>
<span>  <span class="va">high_H</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"HighH"</span>,<span class="va">win_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#检查frame_HSV的哪些像素的颜色介于待识别的颜色范围之中，结果保存在mask中</span></span>
<span>  <span class="va">mask</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">lower</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="va">low_H</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span></span>
<span>  <span class="va">upper</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="va">high_H</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span></span>
<span>  <span class="fu">cv_inRange</span><span class="op">(</span><span class="va">frame_HSV</span>,<span class="va">lower</span>,<span class="va">upper</span>,<span class="va">mask</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#基于mask，让frame与其自身进行按位与运算，结果保存在dst中</span></span>
<span>  <span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_bitwise_and</span><span class="op">(</span><span class="va">frame</span>,<span class="va">frame</span>,<span class="va">dst</span>,<span class="va">mask</span><span class="op">)</span></span>
<span>  <span class="co">#显示dst</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">win_name</span>,<span class="va">dst</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#创建图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="va">win_name</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制H分量下界的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"LowH"</span>,<span class="va">win_name</span>,<span class="fl">0</span>,<span class="fl">180</span>,<span class="va">onScroll</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制H分量上界的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"HighH"</span>,<span class="va">win_name</span>,<span class="fl">10</span>,<span class="fl">180</span>,<span class="va">onScroll</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#读取图像文件，结果保存在frame中</span></span>
<span><span class="va">frame</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/multicolorobj.png"</span><span class="op">)</span></span>
<span><span class="co">#将frame显示在图形窗口中</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="va">win_name</span>,<span class="va">frame</span><span class="op">)</span></span>
<span><span class="co">#将图像的颜色空间由BGR转变为HSV，结果保存在frame_HsV中</span></span>
<span><span class="va">frame_HSV</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">frame</span>,<span class="va">frame_HSV</span>,<span class="va">COLOR_BGR2HSV</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#调用onScroll函数</span></span>
<span><span class="fu">onScroll</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>进一步，还可以增加S、V分量的控制条来实现更精细的颜色识别效果：</p>
<div class="inline-figure"><img src="images/hsvInRange1.png"></div>
<div class="sourceCode" id="cb949"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设定图形窗口标题</span></span>
<span><span class="va">win_name</span> <span class="op">=</span> <span class="st">"Object Detection"</span></span>
<span></span>
<span><span class="co">#定义滑动条响应函数OnScroll</span></span>
<span><span class="va">onScroll</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">param</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#获取控制H分量下界的滑动条的当前值</span></span>
<span>  <span class="va">low_H</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"LowH"</span>,<span class="va">win_name</span><span class="op">)</span></span>
<span>  <span class="co">#获取控制H分量上界的滑动条的当前值</span></span>
<span>  <span class="va">high_H</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"HighH"</span>,<span class="va">win_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#获取控制S分量下界的滑动条的当前值</span></span>
<span>  <span class="va">low_S</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"LowS"</span>,<span class="va">win_name</span><span class="op">)</span></span>
<span>  <span class="co">#获取控制S分量上界的滑动条的当前值</span></span>
<span>  <span class="va">high_S</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"HighS"</span>,<span class="va">win_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#获取控制V分量下界的滑动条的当前值</span></span>
<span>  <span class="va">low_V</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"LowV"</span>,<span class="va">win_name</span><span class="op">)</span></span>
<span>  <span class="co">#获取控制V分量上界的滑动条的当前值</span></span>
<span>  <span class="va">high_V</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"HighV"</span>,<span class="va">win_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#检查frame_HSV的哪些像素的颜色介于待识别的颜色范围之中，</span></span>
<span>  <span class="co">#结果保存在mask中</span></span>
<span>  <span class="va">mask</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_inRange</span><span class="op">(</span><span class="va">frame_HSV</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="va">low_H</span>,<span class="va">low_S</span>,<span class="va">low_V</span><span class="op">)</span>,</span>
<span>             <span class="fu">Scalar</span><span class="op">(</span><span class="va">high_H</span>,<span class="va">high_S</span>,<span class="va">high_V</span><span class="op">)</span>,<span class="va">mask</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#基于mask，让frame与其自身进行按位与运算，结果保存在dst中</span></span>
<span>  <span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_bitwise_and</span><span class="op">(</span><span class="va">frame</span>,<span class="va">frame</span>,<span class="va">dst</span>,<span class="va">mask</span><span class="op">)</span></span>
<span>  <span class="co">#显示dst</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">win_name</span>,<span class="va">dst</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#创建图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="va">win_name</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制H分量下界的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"LowH"</span>,<span class="va">win_name</span>,<span class="fl">0</span>,<span class="fl">180</span>,<span class="va">onScroll</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制H分量上界的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"HighH"</span>,<span class="va">win_name</span>,<span class="fl">10</span>,<span class="fl">180</span>,<span class="va">onScroll</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制S分量下界的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"LowS"</span>,<span class="va">win_name</span>,<span class="fl">0</span>,<span class="fl">255</span>,<span class="va">onScroll</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制S分量上界的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"HighS"</span>,<span class="va">win_name</span>,<span class="fl">0</span>,<span class="fl">255</span>,<span class="va">onScroll</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制V分量下界的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"LowV"</span>,<span class="va">win_name</span>,<span class="fl">0</span>,<span class="fl">255</span>,<span class="va">onScroll</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制V分量上界的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"HighV"</span>,<span class="va">win_name</span>,<span class="fl">0</span>,<span class="fl">255</span>,<span class="va">onScroll</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#读取图像文件，结果保存在frame中</span></span>
<span><span class="co"># frame = cv.imread("images/multicolorobj.png")</span></span>
<span><span class="va">frame</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/balloon.png"</span><span class="op">)</span></span>
<span><span class="co">#将frame显示在图形窗口中</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="va">win_name</span>,<span class="va">frame</span><span class="op">)</span></span>
<span><span class="co">#将图像的颜色空间由BGR转变为HSV，结果保存在frame_HsV中</span></span>
<span><span class="va">frame_HSV</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">frame</span>,<span class="va">frame_HSV</span>,<span class="va">COLOR_BGR2HSV</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#调用onScroll函数</span></span>
<span><span class="fu">onScroll</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div id="漫水填充" class="section level2" number="6.8">
<h2>
<span class="header-section-number">6.8</span> 漫水填充<a class="anchor" aria-label="anchor" href="#%E6%BC%AB%E6%B0%B4%E5%A1%AB%E5%85%85"><i class="fas fa-link"></i></a>
</h2>
<p>漫水填充法是一种用特定的颜色填充联通区域，通过设置可连通像素的上下限以及连通方式来达到不同的填充效果的方法。漫水填充经常被用来标记或分离图像的一部分以便对其进行进一步处理或分析，也可以用来从输入图像获取掩码区域，掩码会加速处理过程，或只处理掩码指定的像素点，操作的结果总是某个连续的区域。</p>
<p><strong>示例</strong></p>
<p>对如下图像中的白色棋子、黑色棋子、硬币、铅笔和打火机进行漫水填充：</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-138-1.png" width="672"></div>
<div class="sourceCode" id="cb950"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件(以灰度图方式)</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/stuff.jpg"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="va">src</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#白色棋子</span></span>
<span><span class="fu">cv_floodFill</span><span class="op">(</span><span class="va">dst</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">390</span>,<span class="fl">180</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">128</span><span class="op">)</span>,loDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>,upDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 8402</code></pre>
<div class="sourceCode" id="cb952"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#黑色棋子</span></span>
<span><span class="fu">cv_floodFill</span><span class="op">(</span><span class="va">dst</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">230</span>,<span class="fl">60</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">128</span><span class="op">)</span>,loDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span>,upDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 2857</code></pre>
<div class="sourceCode" id="cb954"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#硬币</span></span>
<span><span class="fu">cv_floodFill</span><span class="op">(</span><span class="va">dst</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">203</span>,<span class="fl">308</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">128</span><span class="op">)</span>,loDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">4</span><span class="op">)</span>,upDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 916</code></pre>
<div class="sourceCode" id="cb956"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#铅笔</span></span>
<span><span class="fu">cv_floodFill</span><span class="op">(</span><span class="va">dst</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">196</span>,<span class="fl">174</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">128</span><span class="op">)</span>,loDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span>,upDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 2306</code></pre>
<div class="sourceCode" id="cb958"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#打火机</span></span>
<span><span class="fu">cv_floodFill</span><span class="op">(</span><span class="va">dst</span>,<span class="fu">Point</span><span class="op">(</span><span class="fl">336</span>,<span class="fl">386</span><span class="op">)</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">128</span><span class="op">)</span>,loDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span>,upDiff<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">3</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 2756</code></pre>
<div class="sourceCode" id="cb960"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看结果</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'res'</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-140-1.png" width="672"></div>
</div>
<div id="图像平滑" class="section level2" number="6.9">
<h2>
<span class="header-section-number">6.9</span> 图像平滑<a class="anchor" aria-label="anchor" href="#%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91"><i class="fas fa-link"></i></a>
</h2>
<p>图像平滑，也称为图像模糊，是一种简单而常用的图像处理操作。平滑的作用很多，包括减少噪声（其他用途将在后续内容中看到）。平滑操作涉及到应用滤波器——也常被叫做内核、卷积核、核矩阵、掩码矩阵，最常见的滤波器类型是线性的。</p>
<p>设滤波器<span class="math inline">\(M\)</span>的行数和列数分别为<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>，其锚点横坐标为<span class="math inline">\(anchor_x\)</span>，纵坐标为<span class="math inline">\(anchor_y\)</span>，则在图像<span class="math inline">\(I\)</span>上使用此滤波器时，相应的计算公式为：</p>
<p><span class="math display">\[
I_1(i,j) = \sum_{r=0} ^{m-1} \sum_{c=0}^{n-1} I(i-anchor_y+r,j-anchor_x+c) \times M(r,c)
\]</span>
公式中的输出像素值（<span class="math inline">\(I_1(i,j)\)</span>）是由输入像素值（例如<span class="math inline">\(I(i-anchor_x+r,j-anchor_y+c)\)</span>）以<span class="math inline">\(M\)</span>的对应元素为权重进行的加权求和。</p>
<p>平滑的具体操作是：首先依据滤波器尺寸以及锚点所在的位置，扩展图像边缘，而后在（边缘扩展后的）图像矩阵上，按行按列移动滤波器，每次移动都让滤波器的锚点对准（边缘扩展前的）图像矩阵的一个像素，并对滤波器“掩盖住”的所有像素值与对应滤波器位置的权值相乘并求和，如此遍历完所有像素（这里的所有像素，指的是边缘扩展前的图像矩阵的所有像素）。每次移动，锚点对准的像素称为目标像素，滤波器“掩盖”住的像素都称为目标像素的领域像素，这些领域像素按原有位置形成的矩阵称为目标像素的领域像素矩阵，也可以称为滤波器的目标区域，每次的滤波计算结果称为目标像素的滤波输出值。</p>
<p>图像平滑其实是前面所讲的图像矩阵的掩码运算，所以上面的公式还可以表达成如下两种形式：</p>
<p><span class="math display">\[
I_1(i,j) = I_{neighbour} \otimes M
\]</span></p>
<p><span class="math display">\[
I_1 = I \otimes M
\]</span>
其中，<span class="math inline">\(I_{neighbour}\)</span>表示目标像素<span class="math inline">\((i,j)\)</span>的邻域像素矩阵。<span class="math inline">\(\otimes\)</span>符号表示两个矩阵对应元素相乘再求和</p>
<p><a href="https://blog.csdn.net/qq_36359022/article/details/80154900" class="uri">https://blog.csdn.net/qq_36359022/article/details/80154900</a></p>
<div id="常用滤波器" class="section level3" number="6.9.1">
<h3>
<span class="header-section-number">6.9.1</span> 常用滤波器<a class="anchor" aria-label="anchor" href="#%E5%B8%B8%E7%94%A8%E6%BB%A4%E6%B3%A2%E5%99%A8"><i class="fas fa-link"></i></a>
</h3>
<div id="归一化盒子滤波器" class="section level4" number="6.9.1.1">
<h4>
<span class="header-section-number">6.9.1.1</span> 归一化盒子滤波器<a class="anchor" aria-label="anchor" href="#%E5%BD%92%E4%B8%80%E5%8C%96%E7%9B%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E5%99%A8"><i class="fas fa-link"></i></a>
</h4>
<p>归一化盒子滤波器形状如下：</p>
<p><span class="math display">\[
M=\frac {1}{width \cdot height} \left[ \begin{matrix} 1  &amp; 1 &amp; \cdots &amp; 1 \\ 1 &amp; 1 &amp; \cdots &amp; 1 \\ \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\ 1 &amp; 1 &amp; \cdots &amp; 1  \end{matrix} \right]
\]</span></p>
<p>其中：<span class="math inline">\(width\)</span>和<span class="math inline">\(height\)</span>表示滤波器的宽度和高度（也即是相应滤波矩阵的列数和行数）。</p>
<p>在归一化盒子滤波器下，每个目标像素的输出值都是其领域像素值的平均值（目标像素的所有领域像素的权重相等）。</p>
<p>OpenCV将归一化盒子滤波器封装在了<strong>blur</strong>函数中：</p>
<div class="sourceCode" id="cb961"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用blur函数对img进行归一化盒子滤波，滤波器为3行3列矩阵，</span></span>
<span><span class="co">#滤波结果保存在blur_out中</span></span>
<span><span class="va">blur_out</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_blur</span><span class="op">(</span><span class="va">img</span>,<span class="va">blur_out</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看blur_out</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">blur_out</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,] 3.67 4.67 5.67
## [2,] 4.00 5.00 6.00
## [3,] 4.33 5.33 6.33
## attr(,"depth")
## [1] 5</code></pre>
<p>可以通过以下代码来验证这个结果：</p>
<div class="sourceCode" id="cb963"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#按BORDER_DEFAULT方式扩展图像边缘：</span></span>
<span><span class="co">#对于3行3列且锚点在中心位置的滤波器，只需上下各扩展1行，左右各扩展1列即可，</span></span>
<span><span class="co">#扩展结果保存在img_borderadded中</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用cv2r函数img_borderadded转变为R语言的矩阵img_borderadded_mat</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#res_mat先初始化为img_borderadded_mat</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span></span>
<span><span class="co">#设定滤波器的行数和列数</span></span>
<span><span class="va">m</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="va">n</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="co">#设定滤波器的锚点为其中心点</span></span>
<span><span class="va">anchor_x</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="va">anchor_y</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="co">#生成归一化盒子滤波器</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="op">(</span><span class="fl">3</span><span class="op">*</span><span class="fl">3</span><span class="op">)</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="va">m</span>,nc<span class="op">=</span><span class="va">n</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#移动滤波器，计算目标像素的输出值，并保存在res.mat的对应位置中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#取出目标像素的领域像素矩阵，保存在tmp中</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">m</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,<span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_x</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="co">#计算目标像素的滤波输出值</span></span>
<span>    <span class="va">res_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">tmp</span> <span class="op">*</span> <span class="va">M</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除扩展的边缘</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">res_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">res_mat</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,] 3.67 4.67 5.67
## [2,] 4.00 5.00 6.00
## [3,] 4.33 5.33 6.33</code></pre>
</div>
<div id="高斯滤波器" class="section level4" number="6.9.1.2">
<h4>
<span class="header-section-number">6.9.1.2</span> 高斯滤波器<a class="anchor" aria-label="anchor" href="#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%99%A8"><i class="fas fa-link"></i></a>
</h4>
<p>高斯滤波器的计算公式如下：</p>
<p><span class="math display">\[
\begin{aligned}
M_0(x,y) &amp;= e^{-\frac{(x-anchor_x)^2}{2\sigma_x^2} - \frac{(y-anchor_y)^2}{2\sigma_y^2}} \quad x,y=0,1,2,\dots,k-1 \\
M(x,y) &amp;= \frac {G_0(x,y)}{sum(M_0)}
\end{aligned}
\]</span>
其中<span class="math inline">\(k\)</span>为滤波器尺寸（即滤波器矩阵的行数和列数都为<span class="math inline">\(k\)</span>），<span class="math inline">\(anchor_x\)</span>和<span class="math inline">\(anchor_y\)</span>为滤波器锚点的横纵坐标，<span class="math inline">\(sigma_x\)</span>和<span class="math inline">\(sigma_y\)</span>分别为横向和纵向的标准差，<span class="math inline">\(sum(M_0)\)</span>为<span class="math inline">\(M_0\)</span>中所有元素之和。</p>
<p>参照公式，如下代码可以形成3行3列的高斯滤波器：</p>
<div class="sourceCode" id="cb965"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的全0矩阵</span></span>
<span><span class="va">M0</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#设定锚点横、纵坐标都为1</span></span>
<span><span class="va">anchor_x</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="va">anchor_y</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#设定横向、纵向标准差分别1.5和2.0</span></span>
<span><span class="va">sigma_x</span> <span class="op">=</span> <span class="fl">1.5</span></span>
<span><span class="va">sigma_y</span> <span class="op">=</span> <span class="fl">2.0</span></span>
<span><span class="co">#计算M0的各个元素</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">y</span> <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">x</span> <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">M0</span><span class="op">[</span><span class="va">y</span><span class="op">+</span><span class="fl">1</span>,<span class="va">x</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="op">(</span><span class="va">x</span><span class="op">-</span><span class="va">anchor_x</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">sigma_x</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">-</span><span class="op">(</span><span class="va">y</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">sigma_y</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#获得滤波器G</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="va">M0</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">M0</span><span class="op">)</span></span>
<span><span class="co">#查看滤波器</span></span>
<span><span class="va">M</span></span></code></pre></div>
<pre><code>##            [,1]      [,2]       [,3]
## [1,] 0.09824026 0.1226872 0.09824026
## [2,] 0.11132080 0.1390229 0.11132080
## [3,] 0.09824026 0.1226872 0.09824026</code></pre>
<p>可以通过矩阵运算代替循环：</p>
<div class="sourceCode" id="cb967"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成滤波器像素的列标矩阵</span></span>
<span><span class="va">xpos_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">2</span>,each<span class="op">=</span><span class="fl">3</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#生成滤波器像素的行标矩阵</span></span>
<span><span class="va">ypos_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">2</span>,times<span class="op">=</span><span class="fl">3</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定锚点横、纵坐标都为1</span></span>
<span><span class="va">anchor_x</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="va">anchor_y</span> <span class="op">=</span> <span class="fl">1</span></span>
<span></span>
<span><span class="va">M0</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="op">(</span><span class="va">xpos_mat</span> <span class="op">-</span> <span class="va">anchor_x</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="fl">1.5</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">-</span><span class="op">(</span><span class="va">ypos_mat</span> <span class="op">-</span> <span class="va">anchor_y</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="fl">2.0</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">M</span><span class="op">=</span><span class="va">M0</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">M0</span><span class="op">)</span></span>
<span><span class="va">M</span></span></code></pre></div>
<pre><code>##            [,1]      [,2]       [,3]
## [1,] 0.09824026 0.1226872 0.09824026
## [2,] 0.11132080 0.1390229 0.11132080
## [3,] 0.09824026 0.1226872 0.09824026</code></pre>
<p>依据指数函数的运算规律，可以对计算<span class="math inline">\(M_0\)</span>的公式进行变形：</p>
<p><span class="math display">\[
\begin{aligned}
M_0(x,y) &amp;= e^{-\frac{(x-anchor_x)^2}{2\sigma_x^2} - \frac{(y-anchor_y)^2}{2\sigma_y^2}} \quad x,y=0,1,2,\dots,k-1 \\
&amp;=e^{-\frac{(x-anchor_x)^2}{2\sigma_x^2}} \times e^{\frac{(y-anchor_y)^2}{2\sigma_y^2}}
\end{aligned}
\]</span>
即<span class="math inline">\(M_0\)</span>可以分解成两部分，而这两部分可以近似认为是横向和纵向的一维高斯滤波器。在OpenCV中，可以使用<strong>getGaussianKernel</strong>生成一维高斯滤波器，而两个一维高斯滤波器按矩阵乘法相乘后，可以得到二维高斯滤波器。</p>
<div class="sourceCode" id="cb969"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成一维（横向）高斯滤波器Gx</span></span>
<span><span class="va">Gx</span> <span class="op">=</span> <span class="fu">cv_getGaussianKernel</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">1.5</span><span class="op">)</span></span>
<span><span class="co">#生成一维（纵向）高斯滤波器Gy</span></span>
<span><span class="va">Gy</span> <span class="op">=</span> <span class="fu">cv_getGaussianKernel</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">2.0</span><span class="op">)</span></span>
<span><span class="co">#Gx和Gy按矩阵乘法相乘，可得到一个二维高斯滤波器</span></span>
<span><span class="va">G</span> <span class="op">=</span> <span class="va">Gy</span> <span class="op">*</span> <span class="va">Gx</span><span class="op">$</span><span class="fu">t</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">G</span><span class="op">$</span><span class="fu">outToConsole</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [0.0982402633434698, 0.1226872417669197, 0.0982402633434698;
##  0.1113208024365304, 0.1390228582192207, 0.1113208024365304;
##  0.0982402633434698, 0.1226872417669197, 0.0982402633434698]</code></pre>
<div class="sourceCode" id="cb971"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#或者</span></span>
<span><span class="va">Gy</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="va">Gx</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>##            [,1]      [,2]       [,3]
## [1,] 0.09824026 0.1226872 0.09824026
## [2,] 0.11132080 0.1390229 0.11132080
## [3,] 0.09824026 0.1226872 0.09824026</code></pre>
<p>OpenCV将高斯滤波器封装在了<strong>GaussianBlur</strong>函数中：</p>
<div class="sourceCode" id="cb973"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用GaussianBlur函数对img进行高斯滤波，滤波器为3行3列矩阵，</span></span>
<span><span class="co">#横向标准差为1.5，纵向标准差为2.0，</span></span>
<span><span class="co">#滤波结果保存在blur_out中</span></span>
<span><span class="va">blur_out</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_GaussianBlur</span><span class="op">(</span><span class="va">img</span>,<span class="va">blur_out</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span>,<span class="fl">1.5</span>,<span class="fl">2.0</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看blur_out</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">blur_out</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,] 3.49 4.64 5.79
## [2,] 3.85 5.00 6.15
## [3,] 4.21 5.36 6.51
## attr(,"depth")
## [1] 5</code></pre>
<p>可以通过以下代码来验证这个结果：</p>
<div class="sourceCode" id="cb975"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#按BORDER_DEFAULT方式扩展图像边缘：</span></span>
<span><span class="co">#对于3行3列且锚点在中心位置的滤波器，只需上下各扩展1行，左右各扩展1列即可，</span></span>
<span><span class="co">#扩展结果保存在img.borderadded中</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用cv2r函数img_borderadded转变为R语言的矩阵img_borderadded_mat</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#res_mat先初始化为img_borderadded_mat</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span></span>
<span><span class="co">#设定滤波器的行数和列数</span></span>
<span><span class="va">m</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="va">n</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="co">#设定滤波器的锚点为其中心点</span></span>
<span><span class="va">anchor_x</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="va">anchor_y</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="co">#生成高斯滤波器</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">cv_getGaussianKernel</span><span class="op">(</span><span class="va">m</span>,<span class="fl">2.0</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu">cv_getGaussianKernel</span><span class="op">(</span><span class="va">n</span>,<span class="fl">1.5</span><span class="op">)</span><span class="op">)</span><span class="op">$</span><span class="fu">t</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#移动滤波器，计算目标像素的滤波输出值，并保存在res_mat的对应位置中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#取出目标像素的领域像素矩阵，保存在tmp中</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">m</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                              <span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_x</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="co">#将tmp与滤波器ker的对应元素相乘再求和，得到目标像素的滤波输出值</span></span>
<span>    <span class="va">res_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">tmp</span> <span class="op">*</span> <span class="va">ker</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> </span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除扩展的边缘</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">res_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">res_mat</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,] 3.49 4.64 5.79
## [2,] 3.85 5.00 6.15
## [3,] 4.21 5.36 6.51</code></pre>
</div>
<div id="中值滤波器" class="section level4" number="6.9.1.3">
<h4>
<span class="header-section-number">6.9.1.3</span> 中值滤波器<a class="anchor" aria-label="anchor" href="#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E5%99%A8"><i class="fas fa-link"></i></a>
</h4>
<p>中值滤波器会把目标像素的邻域像素矩阵的中值作为滤波输出值。</p>
<p>OpenCV将中值滤波器封装在了<strong>medianBlur</strong>函数中：</p>
<div class="sourceCode" id="cb977"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用medianBlur函数对img进行高斯滤波，滤波器为3行3列矩阵，</span></span>
<span><span class="co">#滤波结果保存在blur.out中</span></span>
<span><span class="va">blur_out</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_medianBlur</span><span class="op">(</span><span class="va">img</span>,<span class="va">blur_out</span>,<span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看blur_out</span></span>
<span><span class="va">blur_out</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2    4    7
## [2,]    3    5    7
## [3,]    3    6    8
## attr(,"depth")
## [1] 0</code></pre>
<p>可以通过以下代码来验证这个结果：</p>
<div class="sourceCode" id="cb979"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#按BORDER_DEFAULT方式扩展图像边缘：</span></span>
<span><span class="co">#对于3行3列且锚点在中心位置的滤波器，只需上下各扩展1行，左右各扩展1列即可，</span></span>
<span><span class="co">#扩展结果保存在img_borderadded中</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_REPLICATE</span><span class="op">)</span> <span class="co">#注意这里的bordertype</span></span>
<span></span>
<span><span class="co">#利用cv2r函数img_borderadded转变为R语言的矩阵img_borderadded_mat</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#res_mat先初始化为img_borderadded_mat</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span></span>
<span><span class="co">#设定滤波器的行数和列数</span></span>
<span><span class="va">m</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="va">n</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="co">#设定滤波器的锚点为其中心点</span></span>
<span><span class="va">anchor_x</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="va">anchor_y</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="co">#移动滤波器，计算目标像素的滤波输出值，并保存在res_mat的对应位置中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#取出目标像素的领域像素矩阵，保存在tmp中</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">m</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                              <span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_x</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="co">#将tmp中的中位数作为目标像素的滤波输出值</span></span>
<span>    <span class="va">res_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/median.html">median</a></span><span class="op">(</span><span class="va">tmp</span><span class="op">)</span>  </span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除扩展的边缘</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">res_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_mat</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    2    4    7
## [2,]    3    5    7
## [3,]    3    6    8</code></pre>
</div>
<div id="双边滤波器" class="section level4" number="6.9.1.4">
<h4>
<span class="header-section-number">6.9.1.4</span> 双边滤波器<a class="anchor" aria-label="anchor" href="#%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2%E5%99%A8"><i class="fas fa-link"></i></a>
</h4>
<p>归一化盒子滤波器、高斯滤波器和中值滤波器等能消除噪声，也会模糊边缘。为了保留边缘（至少在一定程度上），可以使用双边滤波器。</p>
<p>类似于高斯滤波器的方式，双边滤波器也会考虑像素分配的权重。这些权重有两个分量，第一个分量与高斯滤波器使用的权重相同。第二分量考虑相邻像素和被评估像素之间的强度差。</p>
<p>双边滤波公式：</p>
<p><span class="math display">\[
g(i,j)=\frac{\sum_{(k,l) \in S(i,j)}f(k,l)w(i,j,k,l)}{\sum_{(k,l) \in S(i,j)}w(i,j,k,l)}
\]</span>
<span class="math inline">\(g(i, j)\)</span>代表输出点；<br><span class="math inline">\(S(i, j)\)</span>的是指以<span class="math inline">\((i,j)\)</span>为中心的<span class="math inline">\((2d+1) \times (2d+1)\)</span>的大小的范围；<br><span class="math inline">\(f(k, l)\)</span>代表(多个)输入点；<br><span class="math inline">\(w(i, j, k, l)\)</span>是两个高斯函数<span class="math inline">\(w_s\)</span>和<span class="math inline">\(w_r\)</span>的乘积，其中<span class="math inline">\(w_s\)</span>为空间临近高斯函数，<span class="math inline">\(w_r\)</span>为像素值相似度高斯函数：</p>
<p><span class="math display">\[
w=w_s \times w_r
\]</span></p>
<p><span class="math display">\[
w_s = e^{-\frac{(i-k)^2+(j-l)^2}{2 \sigma_s^2}}
\]</span></p>
<p><span class="math display">\[
w_r = e^{-\frac{|| f(i,j)-f(k,l) ||^2}{2 \sigma_r^2}}
\]</span>
OpenCV将双边滤波器封装在了<strong>bilateralFilter</strong>函数中：</p>
<div class="sourceCode" id="cb981"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用bilateralFilter函数对img进行高斯滤波，滤波器为3行3列矩阵，</span></span>
<span><span class="co">#色彩标准差为3，空间标准差为2</span></span>
<span><span class="co">#滤波结果保存在blur.out中</span></span>
<span><span class="va">blur_out</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bilateralFilter</span><span class="op">(</span><span class="va">img</span>,<span class="va">blur_out</span>,d<span class="op">=</span><span class="fl">1</span>,<span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="va">blur_out_mat</span> <span class="op">=</span> <span class="va">blur_out</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">blur_out_mat</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,] 2.33 4.45 6.58
## [2,] 2.87 5.00 7.13
## [3,] 3.42 5.55 7.67
## attr(,"depth")
## [1] 5</code></pre>
<p>可以通过如下基于双边滤波器原理的代码来验证：</p>
<div class="sourceCode" id="cb983"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#按BORDER_DEFAULT方式扩展图像边缘：</span></span>
<span><span class="co">#对于3行3列且锚点在中心位置的滤波器，只需上下各扩展1行，左右各扩展1列即可，</span></span>
<span><span class="co">#扩展结果保存在img_borderadded中</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span> <span class="co">#注意这里的bordertype</span></span>
<span></span>
<span><span class="co">#利用cv2r函数img_borderadded转变为R语言的矩阵img_borderadded_mat</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#res_mat先初始化为img_borderadded_mat</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span></span>
<span><span class="co">#设置邻域半径</span></span>
<span><span class="va">d</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="co">#设置滤波器的行数和列数</span></span>
<span><span class="va">m</span><span class="op">=</span><span class="fl">2</span><span class="op">*</span><span class="va">d</span><span class="op">+</span><span class="fl">1</span></span>
<span><span class="va">n</span><span class="op">=</span><span class="fl">2</span><span class="op">*</span><span class="va">d</span><span class="op">+</span><span class="fl">1</span></span>
<span></span>
<span><span class="co">#生成空间邻近高斯权重矩阵ws</span></span>
<span><span class="va">xpos_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="op">-</span><span class="va">d</span><span class="op">:</span><span class="va">d</span>,each<span class="op">=</span><span class="fl">2</span><span class="op">*</span><span class="va">d</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span>,nr<span class="op">=</span><span class="va">m</span>,nc<span class="op">=</span><span class="va">n</span><span class="op">)</span></span>
<span><span class="va">ypos_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="op">-</span><span class="va">d</span><span class="op">:</span><span class="va">d</span>,times<span class="op">=</span><span class="fl">2</span><span class="op">*</span><span class="va">d</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span>,nr<span class="op">=</span><span class="va">m</span>,nc<span class="op">=</span><span class="va">n</span><span class="op">)</span></span>
<span><span class="va">ws</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">(</span><span class="op">-</span><span class="op">(</span><span class="va">xpos_mat</span> <span class="op">-</span> <span class="va">anchor_x</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">-</span><span class="op">(</span><span class="va">ypos_mat</span> <span class="op">-</span> <span class="va">anchor_y</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="fl">3</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#由于d=1，所以将ws中距离中心点距离超过1的元素设置为0</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">ws</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">ws</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">dd</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="fl">2</span><span class="op">*</span><span class="va">d</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">+</span><span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="fl">2</span><span class="op">*</span><span class="va">d</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span>    <span class="kw">if</span><span class="op">(</span><span class="va">dd</span><span class="op">&gt;</span><span class="va">d</span><span class="op">)</span><span class="op">{</span></span>
<span>      <span class="va">ws</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span><span class="op">=</span><span class="fl">0</span></span>
<span>    <span class="op">}</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span></span>
<span><span class="co">#移动滤波器，计算目标像素的滤波输出值，并保存在res.mat的对应位置中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#取出目标像素的邻域像素矩阵，保存在tmp中</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">d</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">+</span><span class="va">d</span><span class="op">)</span>,</span>
<span>                              <span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">d</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">+</span><span class="va">d</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="co">#生成像素值相似度权重矩阵wr</span></span>
<span>    <span class="va">destPix</span> <span class="op">=</span> <span class="va">tmp</span><span class="op">[</span><span class="fl">2</span><span class="op">*</span><span class="va">d</span>, <span class="fl">2</span><span class="op">*</span><span class="va">d</span><span class="op">]</span> <span class="co">#取出中心元素</span></span>
<span>    <span class="va">wr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="op">(</span><span class="va">tmp</span><span class="op">-</span><span class="va">destPix</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span><span class="op">/</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="fl">3</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="co">#wr = wr[3:1,3:1] #当需要wr旋转180度时，执行此命令</span></span>
<span>    <span class="co">#计算滤波器w</span></span>
<span>    <span class="va">w</span> <span class="op">=</span> <span class="va">ws</span> <span class="op">*</span> <span class="va">wr</span></span>
<span>    <span class="va">w</span> <span class="op">=</span> <span class="va">w</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">w</span><span class="op">)</span></span>
<span>   </span>
<span>    <span class="va">res_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">tmp</span> <span class="op">*</span> <span class="va">w</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除扩展的边缘</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">res_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">res_mat</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,] 2.33 4.55 6.58
## [2,] 2.93 5.15 7.17
## [3,] 3.42 5.64 7.67</code></pre>
</div>
</div>
<div id="自定义滤波器" class="section level3" number="6.9.2">
<h3>
<span class="header-section-number">6.9.2</span> 自定义滤波器<a class="anchor" aria-label="anchor" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E6%B3%A2%E5%99%A8"><i class="fas fa-link"></i></a>
</h3>
<p>滤波器的形状可以是任意的，除以上常用的过滤器外，可以依据实际问题自定义各种滤波器，然后结合OpenCV的<strong>filter2D</strong>函数，实现相应的图像平滑效果。比如：</p>
<div class="sourceCode" id="cb985"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/apple.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#自定义滤波器</span></span>
<span><span class="va">kernel_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">0</span>, <span class="fl">1</span>,<span class="op">-</span><span class="fl">4</span>,<span class="fl">1</span>, <span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span>,byrow<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">kernel</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="va">kernel</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">kernel_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对src进行自定义滤波，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_filter2D</span><span class="op">(</span><span class="va">src</span>,<span class="va">dst</span>,<span class="op">-</span><span class="fl">1</span>,<span class="va">kernel</span><span class="op">)</span></span></code></pre></div>
<div class="inline-table"><table class="table table-sm"><tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">-4</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">0</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
</tbody></table></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-155-1.png" width="672"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb986"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设置标题显示时间为1500毫秒，即1.5秒</span></span>
<span><span class="va">DELAY_CAPTION</span> <span class="op">=</span> <span class="fl">1500</span></span>
<span><span class="co">#设置每次模糊效果的显示时间为500毫秒，即0.5秒</span></span>
<span><span class="va">DELAY_BLUR</span> <span class="op">=</span> <span class="fl">500</span></span>
<span><span class="co">#设置最大滤波器尺寸为31</span></span>
<span><span class="va">MAX_KERNEL_LENGTH</span> <span class="op">=</span> <span class="fl">31</span></span>
<span><span class="co">#设定图形窗口标题</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Smoothing Demo"</span></span>
<span></span>
<span><span class="co">#在黑色背景图片上显示标题文字，表明图像处理的状态</span></span>
<span><span class="va">display_caption</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">caption</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">dst</span> <span class="op">&lt;&lt;-</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="va">src_info</span><span class="op">$</span><span class="va">height</span>, <span class="va">src_info</span><span class="op">$</span><span class="va">width</span>, <span class="va">src_info</span><span class="op">$</span><span class="va">type</span><span class="op">)</span></span>
<span>  <span class="fu">cv_putText</span><span class="op">(</span></span>
<span>    <span class="va">dst</span>,</span>
<span>    <span class="va">caption</span>,</span>
<span>    <span class="fu">Point</span><span class="op">(</span><span class="va">src_info</span><span class="op">$</span><span class="va">width</span> <span class="op">/</span> <span class="fl">4</span>, <span class="va">src_info</span><span class="op">$</span><span class="va">height</span> <span class="op">/</span> <span class="fl">2</span><span class="op">)</span>,</span>
<span>    <span class="va">FONT_HERSHEY_COMPLEX</span>,</span>
<span>    <span class="fl">1</span>,</span>
<span>    <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">255</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="fu">display_dst</span><span class="op">(</span><span class="va">DELAY_CAPTION</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#显示图像处理结果</span></span>
<span><span class="va">display_dst</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">delay</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="fu">cv_waitKey</span><span class="op">(</span><span class="va">delay</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#读入图像，存放在src中</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/girl.png"</span><span class="op">)</span></span>
<span><span class="co"># 获取图像的基本信息，存放在src.info中</span></span>
<span><span class="va">src_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">src</span><span class="op">)</span></span>
<span><span class="co"># 显示文字标题Original Image</span></span>
<span><span class="fu">display_caption</span><span class="op">(</span><span class="st">"Original Image"</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] -1</code></pre>
<div class="sourceCode" id="cb988"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#将src克隆到dst</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="va">src</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#显示dst（现在dst存放的就是原始图像src）</span></span>
<span><span class="fu">display_dst</span><span class="op">(</span><span class="va">DELAY_CAPTION</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] -1</code></pre>
<div class="sourceCode" id="cb990"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#显示文字标题Homegeneous Blur</span></span>
<span><span class="fu">display_caption</span><span class="op">(</span><span class="st">"Homegeneous Blur"</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] -1</code></pre>
<div class="sourceCode" id="cb992"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用归一化盒子滤波器（滤波器的尺寸逐渐变大）</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">MAX_KERNEL_LENGTH</span>, by <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># 图像平滑，结果存放在dst中</span></span>
<span>  <span class="fu">cv_blur</span><span class="op">(</span><span class="va">src</span>, <span class="va">dst</span>, <span class="fu">Size</span><span class="op">(</span><span class="va">i</span>, <span class="va">i</span><span class="op">)</span>, <span class="fu">Point</span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="co"># 显示dst</span></span>
<span>  <span class="fu">display_dst</span><span class="op">(</span><span class="va">DELAY_BLUR</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#显示文字标题Gaussian Blur</span></span>
<span><span class="fu">display_caption</span><span class="op">(</span><span class="st">"Gaussian Blur"</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] -1</code></pre>
<div class="sourceCode" id="cb994"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用高斯滤波器（滤波器的尺寸逐渐变大）</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">MAX_KERNEL_LENGTH</span>, by <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co">#图像平滑，结果存放在dst中</span></span>
<span>  <span class="fu">cv_GaussianBlur</span><span class="op">(</span><span class="va">src</span>, <span class="va">dst</span>, <span class="fu">Size</span><span class="op">(</span><span class="va">i</span>, <span class="va">i</span><span class="op">)</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="co">#显示dst</span></span>
<span>  <span class="fu">display_dst</span><span class="op">(</span><span class="va">DELAY_BLUR</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#显示文字标题Median Blur</span></span>
<span><span class="kw">if</span> <span class="op">(</span><span class="fu">display_caption</span><span class="op">(</span><span class="st">"Median Blur"</span><span class="op">)</span> <span class="op">!=</span> <span class="fl">0</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">return</span></span>
<span><span class="op">}</span></span></code></pre></div>
<pre><code>## .Primitive("return")</code></pre>
<div class="sourceCode" id="cb996"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用中值滤波器（滤波器的尺寸逐渐变大）</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">MAX_KERNEL_LENGTH</span>, by <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co">#图像平滑，结果存放在dst中</span></span>
<span>  <span class="fu">cv_medianBlur</span><span class="op">(</span><span class="va">src</span>, <span class="va">dst</span>, <span class="va">i</span><span class="op">)</span></span>
<span>  <span class="co">#显示dst</span></span>
<span>  <span class="fu">display_dst</span><span class="op">(</span><span class="va">DELAY_BLUR</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#显示文字标题Bilateral Blur</span></span>
<span><span class="fu">display_caption</span><span class="op">(</span><span class="st">"Bilateral Blur"</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] -1</code></pre>
<div class="sourceCode" id="cb998"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用双边滤波器（滤波器的尺寸逐渐变大，sigmaSpace和sigmaColor也逐渐增大）</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">MAX_KERNEL_LENGTH</span>, by <span class="op">=</span> <span class="fl">2</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co">#图像平滑，结果存放在dst中</span></span>
<span>  <span class="fu">cv_bilateralFilter</span><span class="op">(</span><span class="va">src</span>, <span class="va">dst</span>, <span class="va">i</span>, <span class="va">i</span> <span class="op">*</span> <span class="fl">2</span>, <span class="va">i</span> <span class="op">/</span> <span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="co">#显示dst</span></span>
<span>  <span class="fu">display_dst</span><span class="op">(</span><span class="va">DELAY_BLUR</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#显示文字标题Done</span></span>
<span><span class="fu">display_caption</span><span class="op">(</span><span class="st">"Done!"</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] -1</code></pre>
<p><strong>示例</strong></p>
<p>以下代码演示了通过<strong>filter2D</strong>函数使用归一化盒子滤波器进行滤波的情况。</p>
<div class="sourceCode" id="cb1000"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/apple.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将滤波器尺寸存放在kernel_size中（初始值为1）</span></span>
<span><span class="va">kernel_size</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="kw">while</span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#如果kernel_size的值超过11，则重新设置为1</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">kernel_size</span><span class="op">&gt;</span><span class="fl">11</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">kernel_size</span> <span class="op">=</span> <span class="fl">1</span> </span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#kernel_size的值累加2</span></span>
<span>  <span class="va">kernel_size</span> <span class="op">=</span> <span class="va">kernel_size</span> <span class="op">+</span><span class="fl">2</span></span>
<span>  <span class="co">#生成高度和宽度都为kernel_size的归一化盒子滤波器</span></span>
<span>  <span class="va">kernel_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">/</span><span class="op">(</span><span class="va">kernel_size</span><span class="op">*</span><span class="va">kernel_size</span><span class="op">)</span>,</span>
<span>                  nr<span class="op">=</span><span class="va">kernel_size</span>,nc<span class="op">=</span><span class="va">kernel_size</span><span class="op">)</span></span>
<span>  <span class="va">kernel</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="va">kernel_size</span>,<span class="va">kernel_size</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span>  <span class="va">kernel</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">kernel_mat</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#对src进行滤波，结果保存在dst中</span></span>
<span>  <span class="va">c</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_filter2D</span><span class="op">(</span><span class="va">src</span>,<span class="va">dst</span>,<span class="op">-</span><span class="fl">1</span>,<span class="va">kernel</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#在标题为filter2D Demo的图形窗口中显示dst</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"filter2D Demo"</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#等待0.5秒，若用户按下esc键，则循环终止</span></span>
<span>  <span class="va">cc</span> <span class="op">=</span> <span class="fu">cv_waitKey</span><span class="op">(</span><span class="fl">500</span><span class="op">)</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">cc</span> <span class="op">==</span> <span class="fl">27</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="kw">break</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div id="形态学的结构核" class="section level2" number="6.10">
<h2>
<span class="header-section-number">6.10</span> 形态学的结构核<a class="anchor" aria-label="anchor" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E7%9A%84%E7%BB%93%E6%9E%84%E6%A0%B8"><i class="fas fa-link"></i></a>
</h2>
<p>形态学是一组基于预定义结构元素处理图像的操作。这里的预定义结构元素是一个向量或者矩阵，也常称为结构核，结构核的高度与宽度指的是相应矩阵的行数和列数——通常，结构核的尺寸都使用奇数。每个结构核都有一个锚点，默认情况下位于其中心点处，而锚点在矩阵中的行、列位置分别称为锚点的纵坐标和横坐标。结构核中的非零元素称为有效元素。</p>
<p>形态学的具体操作是：首先依据结构核尺寸以及锚点所在的位置，扩展图像边缘，而后在（边缘扩展后的）图像矩阵上，按行按列移动结构核，每次移动都让结构核的锚点对准（边缘扩展前的）图像矩阵的一个像素，并对结构核有效元素“掩盖住”的所有像素值进行对应的形态计算，如此遍历完所有像素（这里的所有像素，指的是边缘扩展前的图像矩阵的所有像素）。每次移动，锚点对准的像素称为目标像素，结构核“掩盖”住的像素都称为目标像素的邻域像素，这些邻域像素按原有位置形成的矩阵称为目标像素的邻域像素矩阵，也可以称为结构核的目标区域，每次的形态计算结果称为目标像素的形态输出值。</p>
<p>OpenCV的<strong>getStructuringElement</strong>函数可以生成矩形，十字形，椭圆盘（或者圆盘）等多种形状的结构核，并可以同时指定锚点位置：</p>
<div class="sourceCode" id="cb1001"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩形结构核</span></span>
<span><span class="va">ele_rect</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ele_rect</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    1
## [2,]    1    1    1
## [3,]    1    1    1
## [4,]    1    1    1
## [5,]    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb1003"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成十字形结构核</span></span>
<span><span class="va">ele_cross</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_CROSS</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ele_cross</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    0    1    0
## [2,]    0    1    0
## [3,]    1    1    1
## [4,]    0    1    0
## [5,]    0    1    0
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb1005"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成椭圆盘/圆盘结构核，且指定锚点位置为第2行第4列</span></span>
<span><span class="va">ele_ellipse</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_ELLIPSE</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span><span class="op">)</span>, anchor <span class="op">=</span> <span class="fu">Point</span><span class="op">(</span><span class="fl">1</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ele_ellipse</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    0    0    0    1    0    0    0
## [2,]    0    1    1    1    1    1    0
## [3,]    1    1    1    1    1    1    1
## [4,]    1    1    1    1    1    1    1
## [5,]    1    1    1    1    1    1    1
## [6,]    0    1    1    1    1    1    0
## [7,]    0    0    0    1    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>还可以按照实际需求，生成各种形状的结构核（比如后面的直线结构核）</p>
</div>
<div id="腐蚀与膨胀" class="section level2" number="6.11">
<h2>
<span class="header-section-number">6.11</span> 腐蚀与膨胀<a class="anchor" aria-label="anchor" href="#%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80"><i class="fas fa-link"></i></a>
</h2>
<p>腐蚀与膨胀是两个最基本的形态学操作，它们的结构核可以是如下<span class="math inline">\(m\)</span>行<span class="math inline">\(n\)</span>列的全1矩阵：</p>
<p><span class="math display">\[
S= \left[ \begin{matrix} 1  &amp; 1 &amp; \cdots &amp; 1 \\ 1 &amp; 1 &amp; \cdots &amp; 1 \\ \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\ 1 &amp; 1 &amp; \cdots &amp; 1  \end{matrix} \right]_{m\times n}
\]</span></p>
<p>膨胀会给图像中物体的边界增加像素，而腐蚀则恰恰相反。添加或移除的像素量分别取决于用于处理图像的结构核的大小和形状。一般来说，这两个操作遵循的规则如下：</p>
<div id="膨胀" class="section level3" number="6.11.1">
<h3>
<span class="header-section-number">6.11.1</span> 膨胀<a class="anchor" aria-label="anchor" href="#%E8%86%A8%E8%83%80"><i class="fas fa-link"></i></a>
</h3>
<p>膨胀操作的计算公式为：</p>
<p><span class="math display">\[
\begin{aligned}
I_1(i,j) &amp;= \max_{r,c} I(i-anchor_y+r,j-anchor_x+c) \\
&amp;r=0,1,\dots,m-1 ;c=0,1,\dots,n-1;S(r,c) \ne 0
\end{aligned}
\]</span></p>
<p>其中，<span class="math inline">\(I\)</span>为输入图像，<span class="math inline">\(S\)</span>为结构核，<span class="math inline">\(anchor_x\)</span>和<span class="math inline">\(anchor_y\)</span>和结构核锚点的横坐标和纵坐标，<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>为结构核的高度和宽度。从膨胀公式可以看出，目标像素的形态输出值是结构核有效元素所覆盖的图像像素的最大值。</p>
<p>以下图形展示了膨胀过程：</p>
<div class="float">
<img src="images/tutorial/morph21.gif" alt="Dilation on a Binary Image"><div class="figcaption">Dilation on a Binary Image</div>
</div>
<div class="float">
<img src="images/tutorial/morph6.gif" alt="Dilation on a Grayscale Image"><div class="figcaption">Dilation on a Grayscale Image</div>
</div>
<p>OpenCV将膨胀操作封装在了<strong>dilate</strong>函数中：</p>
<div class="sourceCode" id="cb1007"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全0矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的第1行第1列的值更改为</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成膨胀结构核：3行3列的全1矩阵</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用dilate函数对img进行膨胀操作，结果保存在img_dilate中</span></span>
<span><span class="va">img_dilate</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_dilate</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_dilate</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看膨胀操作前的img</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    0    0
## [3,]    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb1009"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看膨胀操作后得到的img.dilate</span></span>
<span><span class="va">img_dilate</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    0
## [2,]    1    1    0
## [3,]    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>可以通过以下代码来验证这个结果：</p>
<div class="sourceCode" id="cb1011"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的全0矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的第1行第1列的值更改为</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#按BORDER_CONSTANT方式扩展图像边缘：</span></span>
<span><span class="co">#对于3行3列且锚点在中心位置的滤波器，只需上下各扩展1行，左右各扩展1列即可，扩展像素的值都为0</span></span>
<span><span class="co">#扩展结果保存在img_borderadded中</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_CONSTANT</span>,value<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用cv2r函数img_borderadded转变为R语言的矩阵img_borderadded_mat</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#res.mat先初始化为img.borderadded.mat</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span></span>
<span><span class="co">#设定结构核的行数和列数</span></span>
<span><span class="va">m</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="va">n</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="co">#设定结构核的锚点为其中心点</span></span>
<span><span class="va">anchor_x</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="va">anchor_y</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="co">#生成结构核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="va">m</span>,nc<span class="op">=</span><span class="va">n</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#移动结构核，计算目标像素的形态输出值，并保存在res_mat的对应位置中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#取出目标像素的领域像素矩阵，保存在tmp中</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">m</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                              <span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_x</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="co">#将tmp与结构核ker的对应元素相乘再求最大值，得到目标像素的形体输出值</span></span>
<span>    <span class="va">res_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/bitwise.html">bitwAnd</a></span><span class="op">(</span><span class="va">tmp</span>,<span class="va">ker</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除扩展的边缘</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">res_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_mat</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    0
## [2,]    1    1    0
## [3,]    0    0    0</code></pre>
</div>
<div id="腐蚀" class="section level3" number="6.11.2">
<h3>
<span class="header-section-number">6.11.2</span> 腐蚀<a class="anchor" aria-label="anchor" href="#%E8%85%90%E8%9A%80"><i class="fas fa-link"></i></a>
</h3>
<p>腐蚀操作的计算公式为：</p>
<p><span class="math display">\[
\begin{aligned}
I_1(i,j) &amp;= \min_{r,c} I(i-anchor_y+r,j-anchor_x+c) \\
&amp;r=0,1,\dots,m-1 ;c=0,1,\dots,n-1;S(r,c) \ne 0
\end{aligned}
\]</span></p>
<p>其中，<span class="math inline">\(I\)</span>为输入图像，<span class="math inline">\(S\)</span>为结构核，<span class="math inline">\(anchor_x\)</span>和<span class="math inline">\(anchor_y\)</span>和结构核锚点的横坐标和纵坐标，<span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>为结构核的高度和宽度。从侵蚀公式可以看出，目标像素的形态输出值是结构核有效元素所覆盖的图像像素的最小值。</p>
<p>以下图形展示了侵蚀过程：</p>
<div class="float">
<img src="images/tutorial/morph211.png" alt="Erosion on a Binary Image"><div class="figcaption">Erosion on a Binary Image</div>
</div>
<div class="float">
<img src="images/tutorial/morph61.png" alt="Erosion on a Grayscale Image"><div class="figcaption">Erosion on a Grayscale Image</div>
</div>
<p>OpenCV将腐蚀操作封装在了<strong>erode</strong>函数中：</p>
<div class="sourceCode" id="cb1013"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生全0矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的左上角四个元素的值更改为1</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成腐蚀结构核：3行3列的全1矩阵</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用erode函数对img进行腐蚀操作，结果保存在img_erode中</span></span>
<span><span class="va">img_erode</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_erode</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_erode</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看腐蚀操作前的img</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    0
## [2,]    1    1    0
## [3,]    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb1015"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看腐蚀操作后得到的img_erode</span></span>
<span><span class="va">img_erode</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    0    0
## [3,]    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>可以通过以下代码来验证这个结果：</p>
<div class="sourceCode" id="cb1017"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生全0矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的左上角四个元素的值更改为1</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#按BORDER_CONSTANT方式扩展图像边缘：</span></span>
<span><span class="co">#对于3行3列且锚点在中心位置的滤波器，只需上下各扩展1行，左右各扩展1列即可，扩展像素的值都为1</span></span>
<span><span class="co">#扩展结果保存在img_borderadded中</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_CONSTANT</span>,value<span class="op">=</span><span class="fu">Scalar</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用cv2r函数img_borderadded转变为R语言的矩阵img_borderadded_mat</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#res.mat先初始化为img.borderadded.mat</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span></span>
<span><span class="co">#设定结构核的行数和列数</span></span>
<span><span class="va">m</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="va">n</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="co">#设定结构核的锚点为其中心点</span></span>
<span><span class="va">anchor_x</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="va">anchor_y</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="co">#生成结构核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="va">m</span>,nc<span class="op">=</span><span class="va">n</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#移动结构核，计算目标像素的形态输出值，并保存在res.mat的对应位置中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">res_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#取出目标像素的领域像素矩阵，保存在tmp中</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">m</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                              <span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_x</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="co">#将tmp与结构核ker的对应元素相乘再求最大值，得到目标像素的形体输出值</span></span>
<span>    <span class="va">res_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/bitwise.html">bitwAnd</a></span><span class="op">(</span><span class="va">tmp</span>,<span class="va">ker</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除扩展的边缘</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">res_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">5</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_mat</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    0    0
## [3,]    0    0    0</code></pre>
<p>以下的示例展示了腐蚀、膨胀运算的一些应用效果：</p>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb1019"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#加载图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/letterJ.jpg"</span><span class="op">)</span></span>
<span><span class="co">#生成腐蚀结构核：11行11列的圆盘</span></span>
<span><span class="va">kernel</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_ELLIPSE</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">11</span>,<span class="fl">11</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#对img进行腐蚀，腐蚀结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_erode</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">kernel</span><span class="op">)</span></span></code></pre></div>
<p>可以看到，腐蚀会使亮区域变小：</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-164-1.png" width="672"></div>
<div class="sourceCode" id="cb1020"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#加载图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/letterJ.jpg"</span><span class="op">)</span></span>
<span><span class="co">#生成膨胀结构核：11行11列的圆盘</span></span>
<span><span class="va">kernel</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_ELLIPSE</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">11</span>,<span class="fl">11</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#对img进行膨胀，膨胀结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_dilate</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">kernel</span><span class="op">)</span></span></code></pre></div>
<p>可以看到，膨胀会使亮区域变大：</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-166-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>识别五线谱中的水平直线：</p>
<div class="sourceCode" id="cb1021"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读入五线谱图像文件（按灰度图模式读入）</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/notes.png"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#对src进行逆二值化，结果保存在src_bin中</span></span>
<span><span class="va">src_bin</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">thresh_val</span> <span class="op">=</span> <span class="fu">cv_threshold</span><span class="op">(</span><span class="va">src</span>,<span class="va">src_bin</span>,<span class="fl">100</span>,<span class="fl">255</span>,</span>
<span>                          <span class="va">THRESH_BINARY_INV</span><span class="op">+</span></span>
<span>                            <span class="va">THRESH_OTSU</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成结构核，用来寻找水平线</span></span>
<span><span class="va">horizontalStructure</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>, <span class="fu">Size</span><span class="op">(</span><span class="fl">40</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用morphologyEx进行击中-击不中变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_erode</span><span class="op">(</span><span class="va">src_bin</span>,<span class="va">dst</span>,<span class="va">horizontalStructure</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#进行膨胀操作，增强水平线效果，结果保存在dst中</span></span>
<span><span class="co"># ker = matrix(1,nr=3,nc=1)</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">1</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="fu">cv_dilate</span><span class="op">(</span><span class="va">dst</span>,<span class="va">dst</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示dst</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'dst'</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-168-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>以下代码用两个滑动条分别控制腐蚀结构核的形状和尺寸，易于观察不同形状和尺寸的结构核所带来的腐蚀效果（见下图）。</p>
<div class="inline-figure"><img src="images/ErosionDemo.png"></div>
<div class="sourceCode" id="cb1022"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/baboon.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#定义两个滑动条滑动事件的响应函数Erosion</span></span>
<span><span class="va">Erosion</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">parm</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#获取控制结构核形状的滑动条的当前取值，存入erosion_elem中</span></span>
<span>  <span class="va">erosion_elem</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"Element:"</span>,<span class="st">"Erosion Demo"</span><span class="op">)</span></span>
<span>  <span class="co">#依据erosion_elem的取值情况，确定结构核的形状：</span></span>
<span>  <span class="co">#取0时为矩形，取1时为十字形，取2为椭圆盘或者圆盘</span></span>
<span>  <span class="va">erosion_type</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">MORPH_RECT</span><span class="op">)</span></span>
<span>  <span class="kw">if</span><span class="op">(</span> <span class="va">erosion_elem</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>    <span class="va">erosion_type</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">MORPH_RECT</span><span class="op">)</span> </span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span><span class="op">(</span> <span class="va">erosion_elem</span> <span class="op">==</span> <span class="fl">1</span> <span class="op">)</span><span class="op">{</span> </span>
<span>    <span class="va">erosion_type</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">MORPH_CROSS</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span><span class="op">(</span> <span class="va">erosion_elem</span> <span class="op">==</span> <span class="fl">2</span><span class="op">)</span> <span class="op">{</span> </span>
<span>    <span class="va">erosion_type</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">MORPH_ELLIPSE</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  </span>
<span>  <span class="co">#获取控制结构核尺寸的滑动条的当前取值，存入erosion_size中</span></span>
<span>  <span class="va">erosion_size</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"Kernel size:"</span>,<span class="st">"Erosion Demo"</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#生成相应形状和尺寸的结构核</span></span>
<span>  <span class="va">element</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">erosion_type</span>,</span>
<span>                       <span class="fu">Size</span><span class="op">(</span> <span class="fl">2</span><span class="op">*</span><span class="va">erosion_size</span> <span class="op">+</span> <span class="fl">1</span>, <span class="fl">2</span><span class="op">*</span><span class="va">erosion_size</span><span class="op">+</span><span class="fl">1</span> <span class="op">)</span>,</span>
<span>                       <span class="fu">Point</span><span class="op">(</span> <span class="va">erosion_size</span>, <span class="va">erosion_size</span> <span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#对图形src进行腐蚀，结果保存在erosion_dst中</span></span>
<span>  <span class="va">erosion_dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_erode</span><span class="op">(</span> <span class="va">src</span>, <span class="va">erosion_dst</span>, <span class="va">element</span> <span class="op">)</span></span>
<span></span>
<span>  <span class="co">#将erosion_dst显示在标题为Erosion Demo的图形窗口中</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span> <span class="st">"Erosion Demo"</span>, <span class="va">erosion_dst</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#生成标题为Erosion Demo的图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="st">"Erosion Demo"</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制结构核形状的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"Element:"</span>,<span class="st">"Erosion Demo"</span>,<span class="fl">0</span>,<span class="fl">2</span>,<span class="va">Erosion</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制结构核尺寸的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"Kernel size:"</span>,<span class="st">"Erosion Demo"</span>,<span class="fl">0</span>,<span class="fl">21</span>,<span class="va">Erosion</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#调用Erosion函数</span></span>
<span><span class="fu">Erosion</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><strong>示例</strong></p>
<p>以下代码用两个滑动条分别控制膨胀结构核的形状和尺寸，易于观察不同形状和尺寸的结构核所带来的膨胀效果（见下图）。</p>
<div class="inline-figure"><img src="images/DilationDemo.png"></div>
<div class="sourceCode" id="cb1023"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/cat.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#定义两个滑动条滑动事件的响应函数Dilation</span></span>
<span><span class="va">Dilation</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">voidP</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#获取控制结构核形状的滑动条的当前取值，存入dilation_elem中</span></span>
<span>  <span class="va">dilation_elem</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"Element:"</span>,<span class="st">"Dilation Demo"</span><span class="op">)</span></span>
<span>  <span class="co">#依据dilation_elem的取值情况，确定结构核的形状：</span></span>
<span>  <span class="co">#取0时为矩形，取1时为十字形，取2为椭圆盘或者圆盘</span></span>
<span>  <span class="va">dilation_type</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">MORPH_RECT</span><span class="op">)</span></span>
<span>  <span class="kw">if</span><span class="op">(</span> <span class="va">dilation_elem</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">)</span><span class="op">{</span> </span>
<span>    <span class="va">dilation_type</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">MORPH_RECT</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span><span class="op">(</span> <span class="va">dilation_elem</span> <span class="op">==</span> <span class="fl">1</span> <span class="op">)</span><span class="op">{</span> </span>
<span>    <span class="va">dilation_type</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">MORPH_CROSS</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span><span class="op">(</span> <span class="va">dilation_elem</span> <span class="op">==</span> <span class="fl">2</span><span class="op">)</span> <span class="op">{</span> </span>
<span>    <span class="va">dilation_type</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">MORPH_ELLIPSE</span><span class="op">)</span> </span>
<span>  <span class="op">}</span></span>
<span></span>
<span>  <span class="co">#获取控制结构核尺寸的滑动条的当前取值，存入dilation_size中</span></span>
<span>  <span class="va">dilation_size</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"Kernel size:"</span>,<span class="st">"Dilation Demo"</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#生成相应形状和尺寸的结构核</span></span>
<span>  <span class="va">element</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span> <span class="va">dilation_type</span>,</span>
<span>                       <span class="fu">Size</span><span class="op">(</span> <span class="fl">2</span><span class="op">*</span><span class="va">dilation_size</span> <span class="op">+</span> <span class="fl">1</span>, <span class="fl">2</span><span class="op">*</span><span class="va">dilation_size</span><span class="op">+</span><span class="fl">1</span> <span class="op">)</span>,</span>
<span>                       <span class="fu">Point</span><span class="op">(</span> <span class="va">dilation_size</span>, <span class="va">dilation_size</span> <span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#对图形src进行膨胀，结果保存在dilation_dst中</span></span>
<span>  <span class="va">dilation_dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_dilate</span><span class="op">(</span> <span class="va">src</span>, <span class="va">dilation_dst</span>, <span class="va">element</span> <span class="op">)</span></span>
<span></span>
<span>  <span class="co">#将dilation_dst显示在标题为Dilation Demo的图形窗口中</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span> <span class="st">"Dilation Demo"</span>, <span class="va">dilation_dst</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#生成标题为DilationDemo的图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="st">"Dilation Demo"</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制结构核形状的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"Element:"</span>,<span class="st">"Dilation Demo"</span>,<span class="fl">0</span>,<span class="fl">2</span>,<span class="va">Dilation</span><span class="op">)</span></span>
<span><span class="co">#在图形窗口上创建控制结构核尺寸的滑动条</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"Kernel size:"</span>,<span class="st">"Dilation Demo"</span>,<span class="fl">0</span>,<span class="fl">21</span>,<span class="va">Dilation</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#调用Dilation函数</span></span>
<span><span class="fu">Dilation</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div id="开运算闭运算和形态学梯度" class="section level2" number="6.12">
<h2>
<span class="header-section-number">6.12</span> 开运算、闭运算和形态学梯度<a class="anchor" aria-label="anchor" href="#%E5%BC%80%E8%BF%90%E7%AE%97%E9%97%AD%E8%BF%90%E7%AE%97%E5%92%8C%E5%BD%A2%E6%80%81%E5%AD%A6%E6%A2%AF%E5%BA%A6"><i class="fas fa-link"></i></a>
</h2>
<p>基于图像膨胀与腐蚀，使用OpenCV的<strong>morphologyEx</strong>函数能够实现图像的开运算、闭运算和形态学梯度等更多的形态学操作。</p>
<div id="开运算" class="section level3" number="6.12.1">
<h3>
<span class="header-section-number">6.12.1</span> 开运算<a class="anchor" aria-label="anchor" href="#%E5%BC%80%E8%BF%90%E7%AE%97"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li>它是通过对图像先腐蚀后膨胀来获得的，即：openning(src,element)=dilate(erode(src,element))</li>
<li>它有助于移除暗区域中的小白点</li>
</ul>
<div class="sourceCode" id="cb1024"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全0矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的中心元素的值更改为1，经开运算之后，这个1会变为0</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成开运算结构核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="co">#对img进行开运算，结果保存在img_open中</span></span>
<span><span class="va">img_open</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_open</span>,<span class="va">MORPH_OPEN</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看开运算之前的img</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    0    0    0
## [2,]    0    1    0
## [3,]    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb1026"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看开运算之后得到的img_open</span></span>
<span><span class="va">img_open</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    0    0    0
## [2,]    0    0    0
## [3,]    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>可以通过先执行腐蚀操作，再执行膨胀操作来验证结果：</p>
<div class="sourceCode" id="cb1028"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全0矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的中心元素的值更改为1</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成用于腐蚀和膨胀的结构核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#先进行腐蚀而后进行膨胀操作，最终结果放在img_open中</span></span>
<span><span class="va">img_open</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_erode</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_open</span>,<span class="va">ker</span><span class="op">)</span></span>
<span><span class="fu">cv_dilate</span><span class="op">(</span><span class="va">img_open</span>,<span class="va">img_open</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">img_open</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    0    0    0
## [2,]    0    0    0
## [3,]    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
</div>
<div id="闭运算" class="section level3" number="6.12.2">
<h3>
<span class="header-section-number">6.12.2</span> 闭运算<a class="anchor" aria-label="anchor" href="#%E9%97%AD%E8%BF%90%E7%AE%97"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li>它是通过图像先膨胀后腐蚀来获得的，即：closing(src,element)=erode(dilate(src,element))<br>
</li>
<li>它有助于消除亮区域中的小黑点。</li>
</ul>
<div class="sourceCode" id="cb1030"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全1矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的中心元素的值更改为0，经闭运算之后，这个0会变为1</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成闭运算核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="co">#对img进行闭运算，结果保存在img_close中</span></span>
<span><span class="va">img_close</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_close</span>,<span class="va">MORPH_CLOSE</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看闭运算之前的img</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    1
## [2,]    1    0    1
## [3,]    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb1032"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看闭运算之后得到的img_close</span></span>
<span><span class="va">img_close</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    1
## [2,]    1    1    1
## [3,]    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
<p>可以通过先执行膨胀操作，再执行腐蚀操作来验证结果：</p>
<div class="sourceCode" id="cb1034"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全1矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的中心元素的值更改为0</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#将img_mat转变为图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成用于腐蚀和膨胀的结构核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#先进行膨胀而后进行腐蚀操作，最终结果放在img_close中</span></span>
<span><span class="va">img_close</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_dilate</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_close</span>,<span class="va">ker</span><span class="op">)</span></span>
<span><span class="fu">cv_erode</span><span class="op">(</span><span class="va">img_close</span>,<span class="va">img_close</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">img_close</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    1
## [2,]    1    1    1
## [3,]    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
<p>基于开运算和闭运算，还可以实现礼帽与黑帽效果。</p>
</div>
<div id="礼帽" class="section level3" number="6.12.3">
<h3>
<span class="header-section-number">6.12.3</span> 礼帽<a class="anchor" aria-label="anchor" href="#%E7%A4%BC%E5%B8%BD"><i class="fas fa-link"></i></a>
</h3>
<p>它是输入图像和开运算之差。即：tophat(src,element)=src-openning(src,element)</p>
<div class="sourceCode" id="cb1036"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全1矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的2-6行、2-6列的值更改为0</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">6</span>,<span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#再将img_mat的3-5行、3-5列的值更改为1</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">5</span>,<span class="fl">3</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成开运算核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行开运算，结果保存在img_open中</span></span>
<span><span class="va">img_open</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_open</span>,<span class="va">MORPH_OPEN</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#原图像减去开运算结果，相减之后的结果保存在img_tophat中</span></span>
<span><span class="va">img_tophat</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_subtract</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_open</span>,<span class="va">img_tophat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">img_tophat</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    1    1    1    1    1    1    1
## [2,]    1    0    0    0    0    0    1
## [3,]    1    0    0    0    0    0    1
## [4,]    1    0    0    0    0    0    1
## [5,]    1    0    0    0    0    0    1
## [6,]    1    0    0    0    0    0    1
## [7,]    1    1    1    1    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
<p>也可以直接使用cv_morphologyEx函数进行tophat运算：</p>
<div class="sourceCode" id="cb1038"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全1矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的2-6行、2-6列的值更改为0</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">6</span>,<span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#再将img_mat的3-5行、3-5列的值更改为1</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">5</span>,<span class="fl">3</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成开运算核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行tophat运算，结果保存在img_tophat中</span></span>
<span><span class="va">img_tophat</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_tophat</span>,<span class="va">MORPH_TOPHAT</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">img_tophat</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    1    1    1    1    1    1    1
## [2,]    1    0    0    0    0    0    1
## [3,]    1    0    0    0    0    0    1
## [4,]    1    0    0    0    0    0    1
## [5,]    1    0    0    0    0    0    1
## [6,]    1    0    0    0    0    0    1
## [7,]    1    1    1    1    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
</div>
<div id="黑帽" class="section level3" number="6.12.4">
<h3>
<span class="header-section-number">6.12.4</span> 黑帽<a class="anchor" aria-label="anchor" href="#%E9%BB%91%E5%B8%BD"><i class="fas fa-link"></i></a>
</h3>
<p>它是闭运算和它的输入图像之间的差，即：balckhat(src,element)=closing(src,element)-src。</p>
<div class="sourceCode" id="cb1040"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全0矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将img.mat的2-6行、2-6列的值更改为1</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">6</span>,<span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#再将img_mat的3-5行、3-5列的值更改为0</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">5</span>,<span class="fl">3</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成闭运算核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行闭运算，结果保存在img_close中</span></span>
<span><span class="va">img_close</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_close</span>,<span class="va">MORPH_CLOSE</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#闭运算结果减去原图像，相减结果保存在img_blackhat中</span></span>
<span><span class="va">img_blackhat</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_subtract</span><span class="op">(</span><span class="va">img_close</span>,<span class="va">img</span>,<span class="va">img_blackhat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">img_blackhat</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    1    1    1    1    1    1    1
## [2,]    1    0    0    0    0    0    1
## [3,]    1    0    0    0    0    0    1
## [4,]    1    0    0    0    0    0    1
## [5,]    1    0    0    0    0    0    1
## [6,]    1    0    0    0    0    0    1
## [7,]    1    1    1    1    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
<p>可以直接使用cv.morphologyEx函数进行blackhat运算：</p>
<div class="sourceCode" id="cb1042"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全0矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的2-6行、2-6列的值更改为1</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">6</span>,<span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#再将img_mat的3-5行、3-5列的值更改为0</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">5</span>,<span class="fl">3</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成闭运算核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行blackhat运算，结果保存在img_blackhat中</span></span>
<span><span class="va">img_blackhat</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_blackhat</span>,<span class="va">MORPH_BLACKHAT</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">img_blackhat</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    1    1    1    1    1    1    1
## [2,]    1    0    0    0    0    0    1
## [3,]    1    0    0    0    0    0    1
## [4,]    1    0    0    0    0    0    1
## [5,]    1    0    0    0    0    0    1
## [6,]    1    0    0    0    0    0    1
## [7,]    1    1    1    1    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
</div>
<div id="形态学梯度" class="section level3" number="6.12.5">
<h3>
<span class="header-section-number">6.12.5</span> 形态学梯度<a class="anchor" aria-label="anchor" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E6%A2%AF%E5%BA%A6"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li>它是图像膨胀和腐蚀之后相减。 即：morph_grad(src,element)=dilate(src,element)-erode(src,element)<br>
</li>
<li>它有助于找到对象的轮廓。</li>
</ul>
<div class="sourceCode" id="cb1044"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全1矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的中心区域的元素值更改为0</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">5</span>,<span class="fl">3</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成形态学梯度运算结构核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行形态学梯度运算，结果保存在在img_grad中</span></span>
<span><span class="va">img_grad</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_grad</span>,<span class="va">MORPH_GRADIENT</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看形态学梯度运算之前的img</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    1    1    1    1    1    1    1
## [2,]    1    1    1    1    1    1    1
## [3,]    1    1    0    0    0    1    1
## [4,]    1    1    0    0    0    1    1
## [5,]    1    1    0    0    0    1    1
## [6,]    1    1    1    1    1    1    1
## [7,]    1    1    1    1    1    1    1
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb1046"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看形态学梯度运算之后得到的img_grad</span></span>
<span><span class="va">img_grad</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    0    0    0    0    0    0    0
## [2,]    0    1    1    1    1    1    0
## [3,]    0    1    1    1    1    1    0
## [4,]    0    1    1    0    1    1    0
## [5,]    0    1    1    1    1    1    0
## [6,]    0    1    1    1    1    1    0
## [7,]    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>可以通过先分别执行膨胀核腐蚀操作，然后再把结果相减，进而验证结果：</p>
<div class="sourceCode" id="cb1048"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成全1矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将img_mat的中心区域的元素值更改为0</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">3</span><span class="op">:</span><span class="fl">5</span>,<span class="fl">3</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#生成用于腐蚀和膨胀的结构核</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行分别进行膨胀和腐蚀运算，结果分别保存在img_dilate和img_erode中</span></span>
<span><span class="va">img_dilate</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_dilate</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_dilate</span>,<span class="va">ker</span><span class="op">)</span></span>
<span><span class="va">img_erode</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_erode</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_erode</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#膨胀结果减去腐蚀结果，相减结果存入img_grad中</span></span>
<span><span class="fu">cv_subtract</span><span class="op">(</span><span class="va">img_dilate</span>,<span class="va">img_erode</span>,<span class="va">img_grad</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">img_grad</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    0    0    0    0    0    0    0
## [2,]    0    1    1    1    1    1    0
## [3,]    0    1    1    1    1    1    0
## [4,]    0    1    1    0    1    1    0
## [5,]    0    1    1    1    1    1    0
## [6,]    0    1    1    1    1    1    0
## [7,]    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>以下示例展示了开运算、闭运算、礼帽、黑帽和形态学梯度等运算效果：</p>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb1050"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/letterJNoiseOuter.jpg"</span><span class="op">)</span></span>
<span><span class="co">#生成开运算结构核</span></span>
<span><span class="va">element</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">5</span>,<span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#进行开运算，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">MORPH_OPEN</span>,<span class="va">element</span><span class="op">)</span></span></code></pre></div>
<p>可以看到，经过开运算后，图像黑色区域的小白点被消除了。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-184-1.png" width="672"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb1051"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/letterJNoiseInner.jpg"</span><span class="op">)</span></span>
<span><span class="co">#生成闭运算结构核</span></span>
<span><span class="va">element</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">5</span>,<span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#对img进行闭运算，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">MORPH_CLOSE</span>,<span class="va">element</span><span class="op">)</span></span></code></pre></div>
<p>可以看到，经过开运算后，图像白色区域的小黑点被消除了。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-188-1.png" width="672"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb1052"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/letterJNoiseOuter.jpg"</span><span class="op">)</span></span>
<span><span class="co">#生成礼帽运算结构核</span></span>
<span><span class="va">element</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">15</span>,<span class="fl">15</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#对img进行礼帽运算，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">MORPH_TOPHAT</span>,<span class="va">element</span><span class="op">)</span></span></code></pre></div>
<p>可以看到，经过礼帽运算后，图像中出现了“礼帽”效果。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-191-1.png" width="672"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb1053"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/letterJNoiseInner.jpg"</span><span class="op">)</span></span>
<span><span class="co">#生成黑帽运算结构核</span></span>
<span><span class="va">element</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">15</span>,<span class="fl">15</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#对img进行黑帽运算，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">MORPH_BLACKHAT</span>,<span class="va">element</span><span class="op">)</span></span></code></pre></div>
<p>可以看到，经过礼帽运算后，图像中出现了“黑帽”效果。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-194-1.png" width="672"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb1054"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/letterJ.jpg"</span><span class="op">)</span></span>
<span><span class="co">#生成形态学梯度运算结构核</span></span>
<span><span class="va">element</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">5</span>,<span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#对img进行形态学梯度运算，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">MORPH_GRADIENT</span>,<span class="va">element</span><span class="op">)</span></span></code></pre></div>
<p>可以看到，经过形态学梯度运算后，图像中出现了“轮廓”效果。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-197-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>以下代码用三个滑动条分别控制形态学操作类型、结构核形状和结构核尺寸，便于观察在不同形态学操作、不同结构核形状和尺寸下相应的形态学效果。</p>
<div class="sourceCode" id="cb1055"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#控制形态学操作类型的滑动条的最大取值为6</span></span>
<span><span class="va">max_operator</span> <span class="op">=</span> <span class="fl">6</span></span>
<span><span class="co">#控制结构核新装的滑动条的最大取值为2</span></span>
<span><span class="va">max_elem</span> <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="co">#控制结构核尺寸的滑动条的最大取值为21</span></span>
<span><span class="va">max_kernel_size</span> <span class="op">=</span> <span class="fl">21</span></span>
<span></span>
<span><span class="co">#定义三个滑动条滑动事件的响应函数Morphology_Operations</span></span>
<span><span class="va">Morphology_Operations</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span> <span class="va">val</span>, <span class="va">param</span> <span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#获取控制形态学操作类型的滑动条的当前取值，存入morph_operator中，</span></span>
<span>  <span class="co">#morph_operator取0-5，依次表示：</span></span>
<span>  <span class="co">#腐蚀、膨胀、开运算、闭运算、形态学梯度、礼帽和黑帽操作</span></span>
<span>  <span class="va">morph_operator</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="va">operatorTrackname</span>,<span class="va">window_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#获取控制结构核形状的滑动条的当前取值，存入morph_elem中，</span></span>
<span>  <span class="co">#morph_elem取0-2，依次表示矩形、十字形和椭圆盘（圆盘）形状的结构核</span></span>
<span>  <span class="va">morph_elem</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="va">elementTrackname</span>,<span class="va">window_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#获取控制结构核尺寸的滑动条的当前取值，存入morph_size中</span></span>
<span>  <span class="va">morph_size</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="va">morphsizeTrackname</span>,<span class="va">window_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#生成相应的结构核</span></span>
<span>  <span class="va">element</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span> <span class="va">morph_elem</span>, </span>
<span>                                      <span class="fu">Size</span><span class="op">(</span> <span class="fl">2</span><span class="op">*</span><span class="va">morph_size</span> <span class="op">+</span> <span class="fl">1</span>, <span class="fl">2</span><span class="op">*</span><span class="va">morph_size</span><span class="op">+</span><span class="fl">1</span> <span class="op">)</span>, </span>
<span>                                      <span class="fu">Point</span><span class="op">(</span> <span class="va">morph_size</span>, <span class="va">morph_size</span> <span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#对图像src进行形态学操作，操作结果保存在dst中</span></span>
<span>  <span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_morphologyEx</span><span class="op">(</span> <span class="va">src</span>, <span class="va">dst</span>, <span class="va">morph_operator</span>, <span class="va">element</span> <span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#将dst显示在window_name指定的标题的图形窗口中</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span> <span class="va">window_name</span>, <span class="va">dst</span> <span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/baboon.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#创建标题为Morphology Transformations Demo的图形窗口</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Morphology Transformations Demo"</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#在图形窗口中创建控制形态学操作类型的滑动条</span></span>
<span><span class="va">operatorTrackname</span> <span class="op">=</span> <span class="st">"Operator:"</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="va">operatorTrackname</span>, </span>
<span>                  <span class="va">window_name</span>, <span class="fl">0</span>, </span>
<span>                  <span class="va">max_operator</span>, <span class="va">Morphology_Operations</span> <span class="op">)</span></span>
<span></span>
<span><span class="co">#在图形窗口中创建控制结构核类型的滑动条</span></span>
<span><span class="va">elementTrackname</span> <span class="op">=</span> <span class="st">"Element:"</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="va">elementTrackname</span>, <span class="va">window_name</span>,</span>
<span>                  <span class="fl">0</span>, <span class="va">max_elem</span>,</span>
<span>                  <span class="va">Morphology_Operations</span> <span class="op">)</span></span>
<span></span>
<span><span class="co">#在图形窗口中创建控制结构核尺寸的滑动条</span></span>
<span><span class="va">morphsizeTrackname</span> <span class="op">=</span> <span class="st">"Kernel size:\n 2n +1"</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="va">morphsizeTrackname</span>, <span class="va">window_name</span>,</span>
<span>                  <span class="fl">0</span>, <span class="va">max_kernel_size</span>,</span>
<span>                  <span class="va">Morphology_Operations</span> <span class="op">)</span></span>
<span></span>
<span><span class="co">#调用Morphology_Operations函数</span></span>
<span><span class="fu">Morphology_Operations</span><span class="op">(</span> <span class="fl">0</span>, <span class="fl">0</span> <span class="op">)</span></span></code></pre></div>
<p><strong><em>以下代码演示了如何从如下图像中提出出音符。</em></strong></p>
<p><strong><em>从音乐表中提取音符。涉及利用形态变换提取水平线和垂直线</em></strong></p>
</div>
</div>
<div id="击中-击不中变换hit-miss" class="section level2" number="6.13">
<h2>
<span class="header-section-number">6.13</span> 击中-击不中变换（hit-miss）<a class="anchor" aria-label="anchor" href="#%E5%87%BB%E4%B8%AD-%E5%87%BB%E4%B8%8D%E4%B8%AD%E5%8F%98%E6%8D%A2hit-miss"><i class="fas fa-link"></i></a>
</h2>
<p><a href="https://www.pythonf.cn/read/168479" class="uri">https://www.pythonf.cn/read/168479</a></p>
<p>击中-击不中变换也属于形态学，适用于单通道二值图像，可以用来探测图像中存在的某些特征（比如：水平线、竖直线、直角边缘等等）。这种变换使用两个结构核<span class="math inline">\(B_1\)</span>和<span class="math inline">\(B_2\)</span>，分别称为击中结构核与击不中结构核，其中<span class="math inline">\(B_1\)</span>用于探测目标区域内部，作为击中部分，B2用于探测目标区域外部,作为击不中部分。从数学公式上，击中-击不中变换可以表示为：</p>
<p><span class="math display">\[
A \oplus B = (A \ominus B_1) \cap (A^c \ominus B_2)
\]</span></p>
<p>击中-击不中变换的基本步骤为：</p>
<ul>
<li>使用<span class="math inline">\(B_1\)</span>对图像<span class="math inline">\(A\)</span>进行腐蚀得到<span class="math inline">\(C_1\)</span>；<br>
</li>
<li>使用<span class="math inline">\(B_2\)</span>对图像<span class="math inline">\(A\)</span>的补集进行腐蚀得到<span class="math inline">\(C_2\)</span>；<br>
</li>
<li>取<span class="math inline">\(C_1\)</span>和<span class="math inline">\(C_2\)</span>的交集作为击中-击不中变换的运算结果。</li>
</ul>
<p>击中结构核<span class="math inline">\(B_1\)</span>与击不中结构核<span class="math inline">\(B_2\)</span>可以合并成一个结构核，比如：</p>
<div class="float">
<img src="images/tutorial/hitmiss_kernels.png" alt="左：击中结构核B1；中间：击不中结构核B2；右：组合后的结构核B"><div class="figcaption">左：击中结构核B1；中间：击不中结构核B2；右：组合后的结构核B</div>
</div>
<p>组合而成的结构核（默认情况下，锚点在中心点处）可以探测的图像特征是：在目标像素的邻域像素矩阵中，目标像素的上、下、左、右四个像素取值相同，但目标像素的取值与这四个像素值不同，而其它像素取值则没有限制。</p>
<p>OpenCV中使用<strong>morphologyEx</strong>函数可以进行击中-击不中变换操作：</p>
<div class="sourceCode" id="cb1056"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵7行7列的全0矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将矩阵的对角线和反对角线上的元素(不包括边缘像素)设置为255</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">img_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span>  <span class="va">img_mat</span><span class="op">[</span><span class="va">i</span>,<span class="fl">7</span><span class="op">-</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#将img.mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成击中-击不中内核，寻找X型特征</span></span>
<span><span class="va">ker_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>,</span>
<span>        <span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>,</span>
<span>        <span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span>,<span class="fl">3</span>,<span class="fl">3</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="va">ker</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">ker_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用morphologyEx进行击中-击不中变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">MORPH_HITMISS</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看变换前的img</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    0    0    0    0    0    0    0
## [2,]    0  255    0    0    0  255    0
## [3,]    0    0  255    0  255    0    0
## [4,]    0    0    0  255    0    0    0
## [5,]    0    0  255    0  255    0    0
## [6,]    0  255    0    0    0  255    0
## [7,]    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb1058"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看变换后得到的dst</span></span>
<span><span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    0    0    0    0    0    0    0
## [2,]    0    0    0    0    0    0    0
## [3,]    0    0    0    0    0    0    0
## [4,]    0    0    0  255    0    0    0
## [5,]    0    0    0    0    0    0    0
## [6,]    0    0    0    0    0    0    0
## [7,]    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>可以看到，结果中仅有第4行第4列的元素为255，表明在这个位置存在X型特征。可以通过如下代码（遵循击中-击不中变换的基本步骤）来验证这个结果：</p>
<div class="sourceCode" id="cb1060"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵7行7列的全0矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将矩阵的对角线和反对角线上的元素(不包括边缘像素)设置为255</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">img_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">i</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span>  <span class="va">img_mat</span><span class="op">[</span><span class="va">i</span>,<span class="fl">7</span><span class="op">-</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成击中结构核</span></span>
<span><span class="va">hit_kernel_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span>,</span>
<span>          <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span>,<span class="fl">3</span>,<span class="fl">3</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="va">hit_kernel</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">hit_kernel</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">hit_kernel_mat</span><span class="op">)</span></span>
<span><span class="co">#对img按照击中机构核进行腐蚀，结果保存在hit_result中</span></span>
<span><span class="va">hit_result</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_erode</span><span class="op">(</span><span class="va">img</span>,<span class="va">hit_result</span>,<span class="va">hit_kernel</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成击不中结构核</span></span>
<span><span class="va">miss_kernel_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span>,</span>
<span>          <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span><span class="op">)</span>,<span class="fl">3</span>,<span class="fl">3</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="va">miss_kernel</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">miss_kernel</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">miss_kernel_mat</span><span class="op">)</span></span>
<span><span class="co">#img取补集，结果保存在img_comp中</span></span>
<span><span class="va">img_comp</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_not</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_comp</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img_comp按照击不中结构核进行腐蚀，结果保存在miss_result中</span></span>
<span><span class="va">miss_result</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_erode</span><span class="op">(</span><span class="va">img_comp</span>,<span class="va">miss_result</span>,<span class="va">miss_kernel</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对hit_result和miss_result取交集，结果保存在img_out中</span></span>
<span><span class="va">img_out</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_and</span><span class="op">(</span><span class="va">hit_result</span>,<span class="va">miss_result</span>,<span class="va">img_out</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">img_out</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    0    0    0    0    0    0    0
## [2,]    0    0    0    0    0    0    0
## [3,]    0    0    0    0    0    0    0
## [4,]    0    0    0  255    0    0    0
## [5,]    0    0    0    0    0    0    0
## [6,]    0    0    0    0    0    0    0
## [7,]    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p><strong>示例</strong></p>
<p>以下代码演示了使用不同结构核探索图形的不同结构特征的情况。</p>
<div class="float">
<img src="images/tutorial/hitmiss_input.png" alt="Input binary image"><div class="figcaption">Input binary image</div>
</div>
<p>首先生成上图所示的图像矩阵</p>
<div class="sourceCode" id="cb1062"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img.mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">0</span>,   <span class="fl">0</span>,   <span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">0</span>,   <span class="fl">0</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">0</span>,   <span class="fl">255</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">0</span>,   <span class="fl">0</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">0</span>, <span class="fl">255</span>, <span class="fl">0</span>,   <span class="fl">0</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">255</span>, <span class="fl">0</span>,   <span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">0</span>,   <span class="fl">0</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">255</span>, <span class="fl">0</span>,   <span class="fl">0</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">0</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">255</span>, <span class="fl">0</span>,   <span class="fl">255</span>, <span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">255</span>, <span class="fl">0</span>,</span>
<span>          <span class="fl">0</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">255</span>, <span class="fl">0</span>, <span class="fl">0</span>,   <span class="fl">0</span>,   <span class="fl">0</span><span class="op">)</span>,<span class="fl">8</span>,<span class="fl">8</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">8</span>,<span class="fl">8</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span></code></pre></div>
<ul>
<li>使用如下结构核，探测图像特征 —— 在目标像素的邻域像素矩阵中，目标像素的上、下、左、右四个像素取值相同，但目标像素的取值与这四个像素值不同，而其它像素取值则没有限制。</li>
</ul>
<div class="inline-figure"><img src="images/tutorial/hitmiss_kernels0.png"></div>
<div class="sourceCode" id="cb1063"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成击中-击不中内核</span></span>
<span><span class="va">ker_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,  <span class="fl">1</span>,  <span class="fl">0</span>,</span>
<span>          <span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>,  <span class="fl">1</span>,</span>
<span>          <span class="fl">0</span>,  <span class="fl">1</span>,  <span class="fl">0</span><span class="op">)</span>,<span class="fl">3</span>,<span class="fl">3</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_16SC1</span><span class="op">)</span></span>
<span><span class="va">ker</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">ker_mat</span><span class="op">)</span></span>
<span><span class="co">#使用morphologyEx进行击中-击不中变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">MORPH_HITMISS</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    0    0    0    0    0    0    0    0
## [2,]    0    0    0    0    0    0    0    0
## [3,]    0    0    0    0    0    0    0    0
## [4,]    0    0    0    0    0    0    0    0
## [5,]    0    0    0    0    0    0    0    0
## [6,]    0    0    0    0    0    0    0    0
## [7,]    0    0  255    0    0    0    0    0
## [8,]    0    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>结果表明，以第7行第3列像素为目标像素的邻域像素矩阵中存在待探测的结构。</p>
<ul>
<li>若使用如下结构核，则可以在图像中发现右上角模式。</li>
</ul>
<div class="inline-figure"><img src="images/tutorial/hitmiss_kernels1.png"></div>
<div class="sourceCode" id="cb1065"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成击中-击不中内核</span></span>
<span><span class="va">ker_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span></span>
<span>        <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="op">-</span><span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>,</span>
<span>          <span class="fl">1</span>,  <span class="fl">1</span>, <span class="op">-</span><span class="fl">1</span>,</span>
<span>          <span class="fl">0</span>,  <span class="fl">1</span>,  <span class="fl">0</span><span class="op">)</span>,<span class="fl">3</span>,<span class="fl">3</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_16SC1</span><span class="op">)</span></span>
<span><span class="va">ker</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">ker_mat</span><span class="op">)</span></span>
<span><span class="co">#使用morphologyEx进行击中-击不中变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span>,<span class="va">MORPH_HITMISS</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    0    0    0    0    0    0    0    0
## [2,]    0    0    0  255    0    0    0    0
## [3,]    0    0    0    0    0    0    0    0
## [4,]    0    0    0    0    0    0    0    0
## [5,]    0    0    0    0    0    0    0    0
## [6,]    0    0    0    0    0    0  255    0
## [7,]    0    0    0    0    0    0    0    0
## [8,]    0    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>结果表明，以第2行第4列像素、第6行第7列像素为目标像素的邻域像素矩阵中存在待探测的结构。</p>
<ul>
<li>将击中-击不中结构核换成如下形式，则可以发现左端点模式。</li>
</ul>
<div class="inline-figure"><img src="images/tutorial/hitmiss_kernels2.png"></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    0    0    0    0    0    0    0    0
## [2,]    0    0    0    0    0    0    0  255
## [3,]    0    0    0    0    0    0    0    0
## [4,]    0    0    0    0    0  255    0    0
## [5,]    0    0    0    0    0    0    0    0
## [6,]    0    0    0    0    0  255    0    0
## [7,]    0    0    0    0    0    0    0    0
## [8,]    0    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>结果表明，以第2行第8列像素、第4行第6列像素、第6行第6列像素为目标像素的邻域像素矩阵中存在待探测的结构。</p>
<ul>
<li>再击中-击不中内核换成如下形式，则可以发现长度为3像素的水平线。</li>
</ul>
<div class="inline-figure"><img src="images/tutorial/hitmiss_kernels3.png"></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    0    0    0    0    0    0    0    0
## [2,]    0    0  255    0    0    0    0    0
## [3,]    0    0  255    0    0    0    0    0
## [4,]    0    0  255    0    0    0    0    0
## [5,]    0    0    0    0    0    0    0    0
## [6,]    0    0    0    0    0    0    0    0
## [7,]    0    0    0    0    0    0    0    0
## [8,]    0    0  255    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>结果表明，以第2行第3列像素、第3行第3列像素、第4行第3列像素、第8行第3列像素为目标像素的邻域像素矩阵中存在待探测的结构。</p>
<ul>
<li>最后将击中-击不中内核换成如下形式，可以发现长度为5像素的竖直线。</li>
</ul>
<div class="inline-figure"><img src="images/tutorial/hitmiss_kernels4.png"></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    0    0    0    0    0    0    0    0
## [2,]    0    0    0    0    0    0    0    0
## [3,]    0    0    0    0    0    0    0    0
## [4,]    0    0  255    0    0    0    0    0
## [5,]    0    0    0    0    0    0    0    0
## [6,]    0    0    0    0    0    0    0    0
## [7,]    0    0    0    0    0    0    0    0
## [8,]    0    0    0    0    0    0    0    0
## attr(,"depth")
## [1] 0</code></pre>
<p>结果表明，以第4行第3列像素为目标像素的邻域像素矩阵中存在待探测的结构。</p>
<p><strong>示例</strong></p>
<p>识别五线谱中的水平直线：</p>
<div class="sourceCode" id="cb1070"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读入五线谱图像文件（按灰度图模式读入）</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/notes.png"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#对src进行逆二值化</span></span>
<span><span class="va">src_bin</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">thresh_val</span> <span class="op">=</span> <span class="fu">cv_threshold</span><span class="op">(</span><span class="va">src</span>,<span class="va">src_bin</span>,<span class="fl">100</span>,<span class="fl">255</span>,</span>
<span>                          <span class="va">THRESH_BINARY_INV</span><span class="op">+</span><span class="va">THRESH_OTSU</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成结构核，用来寻找水平线</span></span>
<span><span class="va">horizontalStructure</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>, <span class="fu">Size</span><span class="op">(</span><span class="fl">40</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用morphologyEx进行击中-击不中变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">src_bin</span>,<span class="va">dst</span>,<span class="va">MORPH_HITMISS</span>,<span class="va">horizontalStructure</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#进行膨胀操作，增强水平线效果</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">ker</span> <span class="op">=</span> <span class="fu">Mat_ones</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">1</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu">cv_dilate</span><span class="op">(</span><span class="va">dst</span>,<span class="va">dst</span>,<span class="va">ker</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'dst'</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-211-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>通过识别五线谱中的竖直直线来提取出音符。</p>
<div class="sourceCode" id="cb1071"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读入五线谱图像文件（按灰度图模式读入）</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/notes.png"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#对src进行逆二值化（背景称为黑色），结果保存在src_bin中</span></span>
<span><span class="va">src_bin</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">thresh_val</span> <span class="op">=</span> <span class="fu">cv_threshold</span><span class="op">(</span><span class="va">src</span>,<span class="va">src_bin</span>,<span class="fl">100</span>,<span class="fl">255</span>,</span>
<span>                          <span class="va">THRESH_BINARY_INV</span> <span class="op">+</span> <span class="va">THRESH_OTSU</span><span class="op">)</span></span>
<span><span class="co">#生成结构核，用来寻找竖直线</span></span>
<span><span class="va">verticalStructure</span> <span class="op">=</span> <span class="fu">cv_getStructuringElement</span><span class="op">(</span><span class="va">MORPH_RECT</span>, <span class="fu">Size</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#使用morphologyEx进行击中-击不中变换，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_morphologyEx</span><span class="op">(</span><span class="va">src_bin</span>,<span class="va">dst</span>,<span class="va">MORPH_HITMISS</span>,<span class="va">verticalStructure</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对dst进行膨胀操作，增强竖直线效果，结果仍然保存在dst中</span></span>
<span><span class="fu">cv_dilate</span><span class="op">(</span><span class="va">dst</span>,<span class="va">dst</span>,<span class="va">verticalStructure</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对dst进行平滑操作，再次增强竖直线效果，结果仍然保存在dst中</span></span>
<span><span class="fu">cv_blur</span><span class="op">(</span><span class="va">dst</span>,<span class="va">dst</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对dst进行按位取反操作（让背景变为白色），结果仍然保存在dst中</span></span>
<span><span class="fu">cv_bitwise_not</span><span class="op">(</span><span class="va">dst</span>,<span class="va">dst</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示结果</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'dst'</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-213-1.png" width="672"></div>
</div>
<div id="图像金字塔" class="section level2" number="6.14">
<h2>
<span class="header-section-number">6.14</span> 图像金字塔<a class="anchor" aria-label="anchor" href="#%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94"><i class="fas fa-link"></i></a>
</h2>
<p><a href="https://blog.csdn.net/zhu_hongji/article/details/81536820" class="uri">https://blog.csdn.net/zhu_hongji/article/details/81536820</a></p>
<p>在一个图像的尺寸不断减半且同时分辨率降低的过程中，会形成一系列图像，这些图像按尺寸大小从底部向上依次排列，会呈现出一个金字塔形状，因此常把这一系列图像称为原图像的图像金字塔，如图：</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-218-1.png" width="672"></div>
<p>在实际应用中，会对图像金字塔从最底层到最顶层编号：最底层为0，依次向上为1、2、3、……。从<span class="math inline">\(i\)</span>层变化到<span class="math inline">\(i+1\)</span>层，由于尺寸会变小，所以这种变化操作常称为下采样；相反从<span class="math inline">\(i+1\)</span>层变化到<span class="math inline">\(i\)</span>层，由于尺寸会变大，所以这种变化操作常称为上采样。</p>
<p>常见图像金字塔有高斯金字塔、拉普拉斯金字塔和DOG金字塔。</p>
<div id="高斯金字塔gaussian-pyramid" class="section level3" number="6.14.1">
<h3>
<span class="header-section-number">6.14.1</span> 高斯金字塔（Gaussian pyramid）<a class="anchor" aria-label="anchor" href="#%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94gaussian-pyramid"><i class="fas fa-link"></i></a>
</h3>
<p>高斯金字塔在形成过程中会使用高斯滤波器。</p>
<p>从<span class="math inline">\(i\)</span>层变化到<span class="math inline">\(i+1\)</span>层的下采样步骤为：</p>
<ul>
<li>
<p>对<span class="math inline">\(i\)</span>层图像<span class="math inline">\(G_i\)</span>用如下高斯滤波器进行平滑：</p>
<p><span class="math display">\[
  \frac{1}{256} \left[ \begin{matrix} 1&amp;4&amp;6&amp;4&amp;1 \\4&amp;16&amp;24&amp;16&amp;4 \\6&amp;24&amp;36&amp;24&amp;6 \\4&amp;16&amp;24&amp;16&amp;4 \\1&amp;4&amp;6&amp;4&amp;1 \end{matrix} \right]
  \]</span><br></p>
</li>
<li><p>删除高斯平滑结果中的偶数行和偶数列后作为<span class="math inline">\(i+1\)</span>层图形。</p></li>
</ul>
<p>从<span class="math inline">\(i+1\)</span>层变化到<span class="math inline">\(i\)</span>层的上采样步骤为：</p>
<ul>
<li><p>将<span class="math inline">\(i+1\)</span>层图像<span class="math inline">\(G_{i+1}\)</span>的行、列都扩展2倍，确保扩展的行、列都在偶数位置，且以0填充。<br></p></li>
<li>
<p>对扩展图像用如下高斯滤波器进行平滑，平滑结果作为<span class="math inline">\(i\)</span>层图像。</p>
<p><span class="math display">\[
  \frac{1}{64} \left[ \begin{matrix} 1&amp;4&amp;6&amp;4&amp;1 \\4&amp;16&amp;24&amp;16&amp;4 \\6&amp;24&amp;36&amp;24&amp;6 \\4&amp;16&amp;24&amp;16&amp;4 \\1&amp;4&amp;6&amp;4&amp;1 \end{matrix} \right]
  \]</span></p>
</li>
</ul>
<p>在OpenCV中，高斯金字塔的下采样操作可以通过<strong>pyrDown</strong>函数实现。</p>
<div class="sourceCode" id="cb1072"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成13行13列的随机矩阵img_mat</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">13</span>,<span class="fl">13</span><span class="op">*</span><span class="fl">13</span>,replace<span class="op">=</span><span class="cn">T</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">13</span>,nc<span class="op">=</span><span class="fl">13</span><span class="op">)</span></span>
<span><span class="co">#将img.mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">13</span>,<span class="fl">13</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行高斯金字塔下采样，采样结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_pyrDown</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code>##       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]
## [1,] 5.734 6.508 9.344 7.609 7.914 6.570 7.125
## [2,] 7.617 7.289 7.066 6.652 7.457 7.445 7.031
## [3,] 8.344 7.773 6.645 6.199 7.855 8.172 6.773
## [4,] 8.047 8.695 7.270 6.648 7.125 8.484 7.008
## [5,] 7.469 8.336 6.016 5.340 5.922 6.691 5.609
## [6,] 8.984 8.586 7.277 6.090 6.605 6.836 5.820
## [7,] 9.031 8.695 8.078 8.094 6.219 6.609 6.016
## attr(,"depth")
## [1] 5</code></pre>
<p>可以通过如下代码（遵循高斯下采样步骤）验证这个结果：</p>
<div class="sourceCode" id="cb1074"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成13行13列的随机矩阵img.mat</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">13</span>,<span class="fl">13</span><span class="op">*</span><span class="fl">13</span>,replace<span class="op">=</span><span class="cn">T</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">13</span>,nc<span class="op">=</span><span class="fl">13</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">13</span>,<span class="fl">13</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成高斯滤波器</span></span>
<span><span class="va">gKer_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">5</span>,nc<span class="op">=</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">ind</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">4</span>,<span class="fl">6</span>,<span class="fl">4</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">gKer_mat</span><span class="op">[</span><span class="va">ind</span>,<span class="op">]</span> <span class="op">=</span> <span class="va">i</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">4</span>,<span class="fl">6</span>,<span class="fl">4</span>,<span class="fl">1</span><span class="op">)</span></span>
<span>  <span class="va">ind</span> <span class="op">=</span> <span class="va">ind</span> <span class="op">+</span><span class="fl">1</span></span>
<span><span class="op">}</span></span>
<span><span class="va">gKer_mat</span> <span class="op">=</span> <span class="va">gKer_mat</span><span class="op">/</span><span class="fl">256</span></span>
<span><span class="va">gKer</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">5</span>,<span class="fl">5</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">gKer</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">gKer_mat</span><span class="op">)</span></span>
<span><span class="co">#对img进行高斯滤波（使用的是filter2D函数），结果保存在dst1中</span></span>
<span><span class="va">dst1</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_filter2D</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst1</span>,<span class="op">-</span><span class="fl">1</span>,<span class="va">gKer</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将dst1转变为R语言矩阵res</span></span>
<span><span class="va">res</span> <span class="op">=</span><span class="va">dst1</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#查看res去除了偶数行和偶数列后的结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">res</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">*</span><span class="fl">2</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">*</span><span class="fl">2</span><span class="op">)</span><span class="op">]</span>,<span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code>##       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]
## [1,] 5.734 6.508 9.344 7.609 7.914 6.570 7.125
## [2,] 7.617 7.289 7.066 6.652 7.457 7.445 7.031
## [3,] 8.344 7.773 6.645 6.199 7.855 8.172 6.773
## [4,] 8.047 8.695 7.270 6.648 7.125 8.484 7.008
## [5,] 7.469 8.336 6.016 5.340 5.922 6.691 5.609
## [6,] 8.984 8.586 7.277 6.090 6.605 6.836 5.820
## [7,] 9.031 8.695 8.078 8.094 6.219 6.609 6.016</code></pre>
<p>而高斯金字塔的上采样操作可以通过OpenCV的<strong>pyrUp</strong>函数实现。</p>
<div class="sourceCode" id="cb1076"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#取img_mat为上面res去除了偶数行和偶数列后的结果</span></span>
<span><span class="co">#这样做，可以很容易看出高斯金字塔的上、下采样不是可互逆还原的过程，</span></span>
<span><span class="co">#因为其中存在信息损失</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="va">res</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">*</span><span class="fl">2</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">*</span><span class="fl">2</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行高斯金字塔上采样，结果保存在dst中</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_pyrUp</span><span class="op">(</span><span class="va">img</span>,<span class="va">dst</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">dst</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code>##        [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9] [,10] [,11] [,12]
##  [1,] 6.330 6.454 6.900 7.739 8.340 8.072 7.599 7.585 7.620 7.294 6.954 6.945
##  [2,] 6.731 6.787 7.034 7.552 7.907 7.668 7.334 7.408 7.531 7.347 7.101 7.043
##  [3,] 7.417 7.362 7.285 7.275 7.220 7.007 6.894 7.140 7.441 7.495 7.392 7.219
##  [4,] 7.868 7.756 7.503 7.193 6.886 6.641 6.633 7.041 7.521 7.732 7.676 7.355
##  [5,] 8.119 8.022 7.745 7.302 6.849 6.544 6.545 7.013 7.590 7.917 7.909 7.478
##  [6,] 8.205 8.215 8.070 7.596 7.050 6.690 6.624 6.957 7.462 7.909 8.044 7.609
##  [7,] 8.143 8.273 8.282 7.785 7.146 6.732 6.584 6.747 7.131 7.644 7.900 7.512
##  [8,] 7.947 8.137 8.187 7.579 6.796 6.318 6.141 6.259 6.590 7.056 7.295 6.948
##  [9,] 7.901 8.071 8.067 7.371 6.499 5.964 5.759 5.877 6.185 6.546 6.696 6.372
## [10,] 8.285 8.344 8.205 7.554 6.757 6.181 5.900 5.989 6.258 6.514 6.570 6.239
## [11,] 8.743 8.685 8.429 7.894 7.267 6.733 6.396 6.359 6.483 6.631 6.628 6.304
## [12,] 8.916 8.824 8.566 8.159 7.725 7.385 7.080 6.752 6.536 6.567 6.583 6.320
## [13,] 8.939 8.854 8.637 8.330 8.049 7.911 7.663 7.055 6.510 6.452 6.511 6.314
## [14,] 8.947 8.863 8.660 8.387 8.157 8.086 7.857 7.156 6.502 6.414 6.486 6.312
##       [,13] [,14]
##  [1,] 7.062 7.102
##  [2,] 7.069 7.078
##  [3,] 7.063 7.011
##  [4,] 7.016 6.902
##  [5,] 6.996 6.835
##  [6,] 7.070 6.891
##  [7,] 6.981 6.804
##  [8,] 6.469 6.309
##  [9,] 5.951 5.811
## [10,] 5.846 5.715
## [11,] 5.940 5.818
## [12,] 6.019 5.918
## [13,] 6.072 5.991
## [14,] 6.090 6.016
## attr(,"depth")
## [1] 5</code></pre>
<p>可以通过如下代码（遵循高斯上采样步骤）验证这个结果：</p>
</div>
<div id="拉普拉斯金字塔laplacian-pyramid" class="section level3" number="6.14.2">
<h3>
<span class="header-section-number">6.14.2</span> 拉普拉斯金字塔（Laplacian pyramid）<a class="anchor" aria-label="anchor" href="#%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94laplacian-pyramid"><i class="fas fa-link"></i></a>
</h3>
<p>拉普拉斯金字塔第<span class="math inline">\(i\)</span>层图像<span class="math inline">\(L_i\)</span>的生成步骤：</p>
<ul>
<li>首先生成高斯金字塔<br>
</li>
<li>对高斯金字塔第<span class="math inline">\(i+1\)</span>层图像<span class="math inline">\(G_{i+1}\)</span>进行上采样得到<span class="math inline">\(G_i'\)</span>
</li>
<li>计算高斯金字塔第<span class="math inline">\(i\)</span>层图像<span class="math inline">\(G_i\)</span>与<span class="math inline">\(G_i'\)</span>之差，即<span class="math inline">\(G_i - G_i'\)</span>，作为拉普拉斯金字塔第<span class="math inline">\(i\)</span>层图像<span class="math inline">\(L_i\)</span>。</li>
</ul>
<p>以下代码演示了拉普拉斯金字塔的生成操作：</p>
<div class="sourceCode" id="cb1078"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行6次高斯金字塔下采样，并将采样结果保存在列表G中（G代表一个高斯金字塔）</span></span>
<span><span class="va">G</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="va">G</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">img</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu">cv_pyrDown</span><span class="op">(</span><span class="va">G</span><span class="op">[[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="va">G</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">dst</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#生成拉普拉斯金字塔，把结果保存在列表L中</span></span>
<span><span class="va">L</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">5</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#对高斯金字塔的第i+1层进行上采样</span></span>
<span>  <span class="va">G_prime</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_pyrUp</span><span class="op">(</span><span class="va">G</span><span class="op">[[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">G_prime</span><span class="op">)</span></span>
<span>  <span class="fu">cv_subtract</span><span class="op">(</span><span class="va">G</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,<span class="va">G_prime</span>,<span class="va">dst</span>,dtype<span class="op">=</span><span class="va">CV_8S</span><span class="op">)</span></span>
<span>  <span class="va">L</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">dst</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#如何很好展示图像金字塔（需要改造一下matImgPlot功能）</span></span></code></pre></div>
</div>
<div id="dog金字塔difference-of-gaussian-dog" class="section level3" number="6.14.3">
<h3>
<span class="header-section-number">6.14.3</span> DOG金字塔(Difference of Gaussian-DOG)<a class="anchor" aria-label="anchor" href="#dog%E9%87%91%E5%AD%97%E5%A1%94difference-of-gaussian-dog"><i class="fas fa-link"></i></a>
</h3>
<p><a href="https://blog.csdn.net/dcrmg/article/details/52577555" class="uri">https://blog.csdn.net/dcrmg/article/details/52577555</a></p>
<p>通俗描述：就是把同一张图像在不同的参数下做高斯模糊之后的结果相减，得到的输出图像。称为高斯不同(DOG)。高斯不同是图像的内在特征，在灰度图像增强、角点检测中经常用到</p>
<p>理论描述：差分金字塔，DOG（Difference of Gaussian）金字塔是在高斯金字塔的基础上构建起来的，其实生成高斯金字塔的目的就是为了构建DOG金字塔。DOG金字塔的第1组第1层是由高斯金字塔的第1组第2层减第1组第1层得到的。以此类推，逐组逐层生成每一个差分图像，所有差分图像构成差分金字塔。概括为DOG金字塔的第0组第l层图像是由高斯金字塔的第0组第i+1层减第0组第i层得到的。</p>
<p>DOG金字塔的构建可以用下图描述：</p>
<div class="inline-figure"><img src="images/tutorial/20180809155648979.png"></div>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb1079"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设置图形窗口的标题</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Pyramids Demo"</span></span>
<span></span>
<span><span class="co">#读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/chicky_512.png"</span><span class="op">)</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">while</span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#在图形窗口中显示src</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">src</span><span class="op">)</span></span>
<span>  <span class="co">#等待用户按键</span></span>
<span>  <span class="va">cc</span> <span class="op">=</span> <span class="fu">cv_waitKey</span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">cc</span><span class="op">==</span><span class="fl">27</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#若按下esc，则循环终止</span></span>
<span>    <span class="fu">cv_destroyWindow</span><span class="op">(</span><span class="va">window_name</span><span class="op">)</span></span>
<span>    <span class="kw">break</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="va">cc</span><span class="op">==</span><span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">"i"</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#若按下i，则进行上采样</span></span>
<span>    <span class="va">imginfo</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">src</span><span class="op">)</span></span>
<span>    <span class="fu">cv_pyrUp</span><span class="op">(</span><span class="va">src</span>,<span class="va">src</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">imginfo</span><span class="op">$</span><span class="va">width</span><span class="op">*</span><span class="fl">2</span>,<span class="va">imginfo</span><span class="op">$</span><span class="va">height</span><span class="op">*</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="va">cc</span><span class="op">==</span><span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">"o"</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#若按下o，则进行下采样</span></span>
<span>    <span class="va">imginfo</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">src</span><span class="op">)</span></span>
<span>    <span class="fu">cv_pyrDown</span><span class="op">(</span><span class="va">src</span>,<span class="va">src</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">imginfo</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="va">imginfo</span><span class="op">$</span><span class="va">height</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p><strong>示例</strong></p>
<p><a href="https://blog.csdn.net/weixin_44586473/article/details/105893478" class="uri">https://blog.csdn.net/weixin_44586473/article/details/105893478</a></p>
<p><a href="https://blog.csdn.net/jjddss/article/details/73469348" class="uri">https://blog.csdn.net/jjddss/article/details/73469348</a></p>
<p>图像重建</p>
<div class="sourceCode" id="cb1080"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">orange</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/orange.jpg"</span><span class="op">)</span></span>
<span><span class="co">#将图像转变为32位浮点类型</span></span>
<span><span class="va">orange</span><span class="op">$</span><span class="fu">convertTo</span><span class="op">(</span><span class="va">orange</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对orange生成拉普拉斯金字塔</span></span>
<span><span class="co">#首先：对apple进行6次高斯金字塔下采样，并将采样结果保存在列表G中，</span></span>
<span><span class="co">#G代表橙子图片的高斯金字塔</span></span>
<span><span class="va">G</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="va">G</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">orange</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu">cv_pyrDown</span><span class="op">(</span><span class="va">G</span><span class="op">[[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="va">G</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">dst</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#然后生成橙子图片的拉普拉斯金字塔，把结果保存在列表L中</span></span>
<span><span class="va">L</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#对高斯金字塔的第i+1层进行上采样</span></span>
<span>  <span class="va">G_prime</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_pyrUp</span><span class="op">(</span><span class="va">G</span><span class="op">[[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">G_prime</span><span class="op">)</span></span>
<span>  <span class="fu">cv_subtract</span><span class="op">(</span><span class="va">G</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,<span class="va">G_prime</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="va">L</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">dst</span></span>
<span><span class="op">}</span></span>
<span><span class="va">L</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">G</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#基于L重建橙子图像，结果保存在res中</span></span>
<span><span class="va">res</span> <span class="op">=</span> <span class="va">L</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">5</span><span class="op">:</span><span class="fl">1</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu">cv_pyrUp</span><span class="op">(</span><span class="va">res</span>,<span class="va">res</span><span class="op">)</span></span>
<span>  <span class="fu">cv_add</span><span class="op">(</span><span class="va">L</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,<span class="va">res</span>,<span class="va">res</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#(cv.Mat(res))$convertTo(tmp.ref,ocv_matDepth["CV_8U"],1,0)</span></span>
<span><span class="co">#按最大最小值方式对res进行归一化，结果仍保存在res中</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">res</span>,<span class="va">res</span>,norm_type <span class="op">=</span> <span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'res'</span>,<span class="va">res</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-228-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>苹果和橘子的融合</p>
<div class="sourceCode" id="cb1081"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取苹果和橘子图像文件</span></span>
<span><span class="va">apple</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/apple.jpg"</span><span class="op">)</span></span>
<span><span class="va">orange</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/orange.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将两个图像都转变为32位浮点类型</span></span>
<span><span class="va">apple</span><span class="op">$</span><span class="fu">convertTo</span><span class="op">(</span><span class="va">apple</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">orange</span><span class="op">$</span><span class="fu">convertTo</span><span class="op">(</span><span class="va">orange</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对apple生成拉普拉斯金字塔</span></span>
<span><span class="co">#首先：对apple进行6次高斯金字塔下采样，并将采样结果保存在列表Ga中，</span></span>
<span><span class="co">#Ga代表苹果图片的高斯金字塔</span></span>
<span><span class="va">Ga</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="va">Ga</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">apple</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu">cv_pyrDown</span><span class="op">(</span><span class="va">Ga</span><span class="op">[[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="va">Ga</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">dst</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># cv.iminfo(Ga[[1]])</span></span>
<span><span class="co"># cv.normalize01(Ga[[1]],tmp.ref,norm_Type="NORM_MINMAX")</span></span>
<span><span class="co"># cv.imdisplay(uncloseRef(tmp.ref))</span></span>
<span></span>
<span><span class="co">#然后生成苹果图片的拉普拉斯金字塔，把结果保存在列表La中</span></span>
<span><span class="va">La</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#对高斯金字塔的第i+1层进行上采样</span></span>
<span>  <span class="va">G_prime</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_pyrUp</span><span class="op">(</span><span class="va">Ga</span><span class="op">[[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">G_prime</span><span class="op">)</span></span>
<span>  <span class="fu">cv_subtract</span><span class="op">(</span><span class="va">Ga</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,<span class="va">G_prime</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="va">La</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">dst</span></span>
<span><span class="op">}</span></span>
<span><span class="va">La</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">Ga</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#对orange生成拉普拉斯金字塔</span></span>
<span><span class="co">#首先：对apple进行6次高斯金字塔下采样，并将采样结果保存在列表Go中，</span></span>
<span><span class="co">#Go代表橙子图片的高斯金字塔</span></span>
<span><span class="va">Go</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="va">Go</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">orange</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu">cv_pyrDown</span><span class="op">(</span><span class="va">Go</span><span class="op">[[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="va">Go</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">dst</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#然后生成橙子图片的拉普拉斯金字塔，把结果保存在列表Lo中</span></span>
<span><span class="va">Lo</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#对高斯金字塔的第i+1层进行上采样</span></span>
<span>  <span class="va">G_prime</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_pyrUp</span><span class="op">(</span><span class="va">Go</span><span class="op">[[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">G_prime</span><span class="op">)</span></span>
<span>  <span class="fu">cv_subtract</span><span class="op">(</span><span class="va">Go</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,<span class="va">G_prime</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="va">Lo</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">dst</span></span>
<span><span class="op">}</span></span>
<span><span class="va">Lo</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">Go</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#对苹果和橙子的拉普拉斯金字塔的相同层图像进行融合，结果保存在列表Ls中</span></span>
<span><span class="va">Ls</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span><span class="st">"list"</span>,<span class="fl">6</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">Ls</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="va">La</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span></span>
<span>  <span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">La</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="va">appleRight</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="va">Ls</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,</span>
<span>                            <span class="fu">Rect</span><span class="op">(</span><span class="va">img_info</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">0</span>,</span>
<span>                              <span class="va">img_info</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">orangeRight</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="va">Lo</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,</span>
<span>                             <span class="fu">Rect</span><span class="op">(</span><span class="va">img_info</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">0</span>,</span>
<span>                               <span class="va">img_info</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">orangeRight</span><span class="op">$</span><span class="fu">copyTo</span><span class="op">(</span><span class="va">appleRight</span><span class="op">)</span> </span>
<span>  <span class="co">#cv.imdisplay(Ls[[i]])</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#LS是苹果左侧和桔子右侧融合图形的拉普拉斯金字塔</span></span>
<span><span class="va">res</span> <span class="op">=</span> <span class="va">Ls</span><span class="op">[[</span><span class="fl">6</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">5</span><span class="op">:</span><span class="fl">1</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu">cv_pyrUp</span><span class="op">(</span><span class="va">res</span>,<span class="va">res</span><span class="op">)</span></span>
<span>  <span class="fu">cv_add</span><span class="op">(</span><span class="va">Ls</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,<span class="va">res</span>,<span class="va">res</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#(cv.Mat(res))$convertTo(tmp.ref,ocv_matDepth["CV_8U"],1,0)</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">res</span>,<span class="va">res</span>,norm_type <span class="op">=</span> <span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'res'</span>,<span class="va">res</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-230-1.png" width="672"></div>
<p>若是直接左右拼接融合苹果和橘子图像，效果如下：</p>
<div class="sourceCode" id="cb1082"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">apple</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/apple.jpg"</span><span class="op">)</span></span>
<span><span class="va">orange</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/orange.jpg"</span><span class="op">)</span></span>
<span><span class="co">#获取苹果的基本信息</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">apple</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设置苹果右半区域为感兴趣区域appleRight</span></span>
<span><span class="va">appleRight</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="va">apple</span>,<span class="fu">Rect</span><span class="op">(</span><span class="va">img_info</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">0</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#获取橘子右半区域</span></span>
<span><span class="va">orangeRight</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="va">orange</span>,<span class="fu">Rect</span><span class="op">(</span><span class="va">img_info</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="fl">0</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">width</span><span class="op">/</span><span class="fl">2</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将橘子右半区域复制到苹果的右半区域</span></span>
<span><span class="va">orangeRight</span><span class="op">$</span><span class="fu">copyTo</span><span class="op">(</span><span class="va">appleRight</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'apple'</span>,<span class="va">apple</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div id="图像边缘检测" class="section level2" number="6.15">
<h2>
<span class="header-section-number">6.15</span> 图像边缘检测<a class="anchor" aria-label="anchor" href="#%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><i class="fas fa-link"></i></a>
</h2>
<p><a href="https://www.cnblogs.com/noticeable/p/10896398.html" class="uri">https://www.cnblogs.com/noticeable/p/10896398.html</a> 含图像的一阶微分和二阶微分说明</p>
<p><a href="https://blog.csdn.net/dieju8330/article/details/82790345" class="uri">https://blog.csdn.net/dieju8330/article/details/82790345</a></p>
<p><a href="https://blog.csdn.net/xiaowei_cqu/article/details/7829481/" class="uri">https://blog.csdn.net/xiaowei_cqu/article/details/7829481/</a></p>
<p><a href="https://blog.csdn.net/wangjia2575525474/article/details/116645943?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control" class="uri">https://blog.csdn.net/wangjia2575525474/article/details/116645943?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control</a> 含非极大抑制</p>
<p><a href="https://blog.csdn.net/augusdi/article/details/12907151/" class="uri">https://blog.csdn.net/augusdi/article/details/12907151/</a></p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-233-1.png" width="672"></div>
<p>对于上图而言，图里面竖直中心线左边很暗，而右边很亮，所以人眼会很容易识别这条线，并将其作为边缘 —— 也就是像素的灰度值快速变化的地方。</p>
<p>下图是函数<span class="math inline">\(\displaystyle y=f(x)=\frac{1} {(1+e^{-x})}\)</span>的图像，函数在红圈标注的点处，函数值变化最快。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-234-1.png" width="672"></div>
<p>在数学中，可以用导数来刻画函数值变化快慢。下图是<span class="math inline">\(y=f(x)\)</span>的导数图形，可以发现在红圈标注的点出，导数取得最大值。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-235-1.png" width="672"></div>
<p>OpenCV借鉴了这种现象背后的结论，通过寻找导数（或者说梯度）高于指定阈值的像素位置来确立图像边缘，并形成了多种边缘检测方法。这些方法的主要思路是：</p>
<div id="sobel算子" class="section level3" number="6.15.1">
<h3>
<span class="header-section-number">6.15.1</span> Sobel算子<a class="anchor" aria-label="anchor" href="#sobel%E7%AE%97%E5%AD%90"><i class="fas fa-link"></i></a>
</h3>
<p>Sobel算子的主要计算步骤：</p>
<ul>
<li>求图像强度函数的水平方向导数</li>
</ul>
<p>定义如下形式的滤波器（常称之为水平导数内核）：</p>
<p><span class="math display">\[
M_x=\left[ \begin{matrix} -1&amp;0&amp;+1 \\ -2&amp;0&amp;+2 \\-1&amp;0&amp;+1 \end{matrix} \right]
\]</span>
使用此滤波器对图像进行平滑：</p>
<p><span class="math display">\[
  G_x= I \otimes M_x
\]</span></p>
<p>平滑结果<span class="math inline">\(G_x\)</span>中的每个元素都表示原图像强度函数在对应像素位置处的水平方向导数，即体现着原图像强度函数在相应位置处的水平方向的变化速度。</p>
<ul>
<li>求图像强度函数的垂直方向导数</li>
</ul>
<p>定义如下形式的滤波器（常称之为垂直导数内核）</p>
<p><span class="math display">\[
  M_y=\left[ \begin{matrix} -1&amp;-2&amp;-1 \\ 0&amp;0&amp;0 \\+1&amp;+2&amp;+1 \end{matrix} \right]
\]</span></p>
<p>使用此滤波器对图像进行平滑：</p>
<p><span class="math display">\[
  G_y= I \otimes M_y
\]</span></p>
<p>平滑结果<span class="math inline">\(G_y\)</span>中的每个元素都表示原图像强度函数在对应像素位置处的垂直方向导数，即体现着原图像强度函数在相应位置处的垂直方向的变化速度。</p>
<ul>
<li>基于<span class="math inline">\(G_x\)</span>和<span class="math inline">\(G_y\)</span>计算图像强度函数梯度的模</li>
</ul>
<p>在图像的每个点上，我们通过结合以上两个结果来计算该点梯度的模：</p>
<p><span class="math display">\[
G=\sqrt {G_x^2+G_y^2}
\]</span></p>
<p>有时，也会使用以下更简单的替代计算公式：</p>
<p><span class="math display">\[
G=|G_x| + |G_y|
\]</span>
getDerivKernels函数，可以生成求导内核：</p>
<div class="sourceCode" id="cb1083"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成x方向、y方向上都是2阶导数的3阶内核</span></span>
<span><span class="va">kx</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">ky</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_getDerivKernels</span><span class="op">(</span><span class="va">kx</span>,<span class="va">ky</span>,<span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示结果</span></span>
<span><span class="va">kx</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1]
## [1,]    1
## [2,]   -2
## [3,]    1
## attr(,"depth")
## [1] 5</code></pre>
<div class="sourceCode" id="cb1085"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ky</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1]
## [1,]    1
## [2,]   -2
## [3,]    1
## attr(,"depth")
## [1] 5</code></pre>
<p><strong>示例</strong></p>
<p>通过Sobel算子计算图像的水平方向导数：</p>
<div class="sourceCode" id="cb1087"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="va">img_mat</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用Sobel算子计算水平方向导数(默认使用3阶求导内核)</span></span>
<span><span class="va">res_sobel</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">res_sobel</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_sobel</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]  [,5] [,6] [,7]
## [1,]    0    0 1020    0 -1020    0    0
## [2,]    0    0 1020    0 -1020    0    0
## [3,]    0    0 1020    0 -1020    0    0
## [4,]    0    0 1020    0 -1020    0    0
## [5,]    0    0 1020    0 -1020    0    0
## [6,]    0    0 1020    0 -1020    0    0
## [7,]    0    0 1020    0 -1020    0    0
## attr(,"depth")
## [1] 5</code></pre>
<p>从结果可以看出，求导结果的取值范围会超出[0,255]区间，所以在计算导数的时候，为Sobel算子指定了”CV_32F”——即计算结果的像素深度为为32位浮点数。</p>
<p>此外，可以通过如下代码来验证这个结果：</p>
<div class="sourceCode" id="cb1089"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="va">img_mat</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#按BORDER_DEFAULT方式扩展图像边缘：</span></span>
<span><span class="co">#对于3行3列且锚点在中心位置的滤波器，只需上下各扩展1行，左右各扩展1列即可，</span></span>
<span><span class="co">#扩展结果保存在img_borderadded中</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用cv2r函数img_borderadded转变为R语言的矩阵img_borderadded_mat</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#res_mat先初始化为img_borderadded_mat</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span></span>
<span><span class="co">#设定滤波器的行数和列数</span></span>
<span><span class="va">m</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="va">n</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="co">#设定滤波器的锚点为其中心点</span></span>
<span><span class="va">anchor_x</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="va">anchor_y</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="co">#生成水平导数内核</span></span>
<span><span class="va">Mx</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>,<span class="op">-</span><span class="fl">2</span>,<span class="op">-</span><span class="fl">1</span>, <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>, <span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#移动水平导数内核，计算目标像素的水平导数值，并保存在res.mat的对应位置中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">8</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">8</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#取出目标像素的领域像素矩阵，保存在tmp中</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">m</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                              <span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_x</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="co">#将tmp与滤波器ker的对应元素相乘再求和，得到目标像素的滤波输出值</span></span>
<span>    <span class="va">res_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">tmp</span> <span class="op">*</span> <span class="va">Mx</span><span class="op">)</span> </span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除扩展的边缘</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">res_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">9</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">9</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_mat</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]  [,5] [,6] [,7]
## [1,]    0    0 1020    0 -1020    0    0
## [2,]    0    0 1020    0 -1020    0    0
## [3,]    0    0 1020    0 -1020    0    0
## [4,]    0    0 1020    0 -1020    0    0
## [5,]    0    0 1020    0 -1020    0    0
## [6,]    0    0 1020    0 -1020    0    0
## [7,]    0    0 1020    0 -1020    0    0</code></pre>
<p>类似地，可以通过Sobel算子计算图像的垂直方向导数（并进行验证）。</p>
<p><strong>示例</strong></p>
<p>Sobel算子中的scale参数的设置方式有：</p>
<ul>
<li>依据求导内核的尺寸设置</li>
</ul>
<p><span class="math display">\[
scale = \frac{1}{2^{ksize-1}}
\]</span></p>
<p>其中：<span class="math inline">\(ksize\)</span>为求导内核的阶数。</p>
<div class="sourceCode" id="cb1091"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="va">img_mat</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="co">#将img.mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设置求导内核尺寸为5</span></span>
<span><span class="va">ksize</span> <span class="op">=</span> <span class="fl">5</span></span>
<span><span class="co">#使用Sobel算子计算水平方向导数</span></span>
<span><span class="va">res_sobel</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">res_sobel</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span>,scale <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_sobel</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]  [,5] [,6] [,7]
## [1,]    0    0 1020    0 -1020    0    0
## [2,]    0    0 1020    0 -1020    0    0
## [3,]    0    0 1020    0 -1020    0    0
## [4,]    0    0 1020    0 -1020    0    0
## [5,]    0    0 1020    0 -1020    0    0
## [6,]    0    0 1020    0 -1020    0    0
## [7,]    0    0 1020    0 -1020    0    0
## attr(,"depth")
## [1] 5</code></pre>
<p><strong>示例</strong></p>
<ul>
<li>单独使用水平方向导数时，能检测出竖直方向边缘；而单独使用垂直方向导数时，能检测出水平方向边缘</li>
</ul>
<div class="sourceCode" id="cb1093"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/abox01.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用Sobel算子计算水平方向导数，结果存入grad_x中</span></span>
<span><span class="va">grad_x</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">grad_x</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#将grad_x标准化，便于显示grad_x对应的图像</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">grad_x</span>,<span class="va">grad_x</span>,norm_type <span class="op">=</span> <span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'grad_x'</span>,<span class="va">grad_x</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="co">#使用Sobel算子计算垂直方向导数，结果存入grad_y中</span></span>
<span><span class="va">grad_y</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">grad_y</span>,<span class="va">CV_32F</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#将grad_y标准化，便于显示grad_y对应的图像</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">grad_y</span>,<span class="va">grad_y</span>,norm_type <span class="op">=</span> <span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span><span class="co">#显示grad_y</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'grad_y'</span>,<span class="va">grad_y</span><span class="op">)</span></span></code></pre></div>
<p>边缘检测结果为如下：左边为原图，中间为水平方向导数图（检测出竖直方向边缘），右边为垂直方向导数图（检测出水平方向边缘）</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-243-1.png" width="672"></div>
<ul>
<li>通过水平方向导数和垂直方向导数计算梯度的模，可以同时检测出多个方向的边缘</li>
</ul>
<div class="sourceCode" id="cb1094"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/abox02.jpg"</span><span class="op">)</span></span>
<span><span class="co">#使用Sobel算子计算水平方向导数，结果存入grad_x中</span></span>
<span><span class="va">grad_x</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">grad_x</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#计算grad_x的平方，结果存入grad_x_square中</span></span>
<span><span class="va">grad_x_square</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_multiply</span><span class="op">(</span><span class="va">grad_x</span>,<span class="va">grad_x</span>,<span class="va">grad_x_square</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用Sobel算子计算垂直方向导数，结果存入grad_y中</span></span>
<span><span class="va">grad_y</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">grad_y</span>,<span class="va">CV_32F</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#计算grad_y的平方，结果存入grad_y_square中</span></span>
<span><span class="va">grad_y_square</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_multiply</span><span class="op">(</span><span class="va">grad_y</span>,<span class="va">grad_y</span>,<span class="va">grad_y_square</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#计算grad_x和grad_y的平方和，结果存入square_sum中</span></span>
<span><span class="va">square_sum</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_add</span><span class="op">(</span><span class="va">grad_x_square</span>,<span class="va">grad_y_square</span>,<span class="va">square_sum</span><span class="op">)</span></span>
<span><span class="co">#求square_sum的算数平方根，结果存入grad中</span></span>
<span><span class="va">grad</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_sqrt</span><span class="op">(</span><span class="va">square_sum</span>,<span class="va">grad</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将grad标准化，便于显示grad对应的图像</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">grad</span>,<span class="va">grad</span>,norm_type <span class="op">=</span> <span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'grad'</span>,<span class="va">grad</span><span class="op">)</span></span></code></pre></div>
<p>可以通过R语言的矩阵运算，简化上面关于图像矩阵求平方、求和、求算数平方根的代码：</p>
<div class="sourceCode" id="cb1095"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/abox02.jpg"</span><span class="op">)</span></span>
<span><span class="co">#使用Sobel算子计算水平方向导数，结果存入grad_x中</span></span>
<span><span class="va">grad_x</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">grad_x</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#使用Sobel算子计算垂直方向导数，结果存入grad_y中</span></span>
<span><span class="va">grad_y</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">grad_y</span>,<span class="va">CV_32F</span>,<span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将grad_x和grad_y转变为R语言的数组</span></span>
<span><span class="va">grad_x_arr</span> <span class="op">=</span> <span class="va">grad_x</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">grad_y_arr</span> <span class="op">=</span> <span class="va">grad_y</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#一次性完成平方、求和、求算数平方根运算，结果保存在grad.arr中</span></span>
<span><span class="va">grad_arr</span> <span class="op">=</span> <span class="op">(</span><span class="va">grad_x_arr</span><span class="op">^</span><span class="fl">2</span><span class="op">+</span><span class="va">grad_y_arr</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="va">sqrt</span></span>
<span><span class="co">#将grad.arr转变为图像矩阵</span></span>
<span><span class="va">grad</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">grad_arr</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">grad_arr</span><span class="op">)</span>,<span class="va">CV_32FC3</span><span class="op">)</span></span>
<span><span class="va">grad</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">grad_arr</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将grad标准化，便于显示grad对应的图像</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">grad</span>,<span class="va">grad</span>,norm_type <span class="op">=</span> <span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'grad'</span>,<span class="va">grad</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-246-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>以下代码演示了如何交互控制Sobel算子的导数内核尺寸ksize、导数放大系数scale和导数偏移量delta，进而观察不同的边缘检测效果。</p>
<div class="inline-figure"><img src="images/SobelDemo.png"></div>
<div class="sourceCode" id="cb1096"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#将图形窗口的标题存放在window_name中</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Sobel Demo - Simple Edge Detector"</span></span>
<span><span class="co">#Sobel算子的导数内核尺寸存放在ksize中，初始值为3</span></span>
<span><span class="va">ksize</span> <span class="op">=</span> <span class="fl">3</span></span>
<span><span class="co">#Sobel算子的导数放大系数存放在scale中，初始值为1</span></span>
<span><span class="va">scale</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#Sobel算子的导数偏移量存放在delta中，初始值为0</span></span>
<span><span class="va">delta</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#Sobel算子的求导结果是32位浮点数</span></span>
<span><span class="va">ddepth</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">CV_32F</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成引用类型变量，作为OpenCV中的函数的引用参数</span></span>
<span><span class="co"># tmp.ref = encloseRef(cv.mat.Mat01())</span></span>
<span><span class="kw">while</span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#对img进行高斯平滑，结果保存在img_gauss中</span></span>
<span>  <span class="va">img_gauss</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_GaussianBlur</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_gauss</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#将img_gauss灰度化，结果保存在img_gray中</span></span>
<span>  <span class="va">img_gray</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_gray</span>,<span class="va">COLOR_BGR2GRAY</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#求img_gray的水平方向和垂直方向导数，结果分别保存在grad_x和grad_y中</span></span>
<span>  <span class="va">grad_x</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img_gray</span>,<span class="va">grad_x</span>,<span class="va">ddepth</span>,<span class="fl">1</span>,<span class="fl">0</span>,<span class="va">ksize</span>,<span class="va">scale</span>,<span class="va">delta</span><span class="op">)</span></span>
<span>  <span class="va">grad_y</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img_gray</span>,<span class="va">grad_y</span>,<span class="va">ddepth</span>,<span class="fl">0</span>,<span class="fl">1</span>,<span class="va">ksize</span>,<span class="va">scale</span>,<span class="va">delta</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#将grad_x和grad_y转变为R语言的矩阵</span></span>
<span>  <span class="va">grad_x_mat</span> <span class="op">=</span> <span class="va">grad_x</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">grad_y_mat</span> <span class="op">=</span> <span class="va">grad_y</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="co">#一次性完成取绝对值、求和运算，结果保存在grad.mat中</span></span>
<span>  <span class="va">grad_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">grad_x_mat</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">grad_y_mat</span><span class="op">)</span></span>
<span>  <span class="co">#将grad_arr转变为图像矩阵</span></span>
<span>  <span class="va">grad</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">grad_mat</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">grad_mat</span><span class="op">)</span>,<span class="va">CV_32FC1</span><span class="op">)</span></span>
<span>  <span class="va">grad</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">grad_mat</span><span class="op">)</span></span>
<span>  <span class="co">#将grad标准化，便于显示grad对应的图像</span></span>
<span>  <span class="fu">cv_normalize</span><span class="op">(</span><span class="va">grad</span>,<span class="va">grad</span>,norm_type <span class="op">=</span> <span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">grad</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#图形窗口等待用户输入</span></span>
<span>  <span class="va">key</span> <span class="op">=</span> <span class="fu">cv_waitKey</span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="co">#若这个过程中，用户按下esc键，则循环终止</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fl">27</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="kw">break</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#若这个过程中，用户按下k键，则导数内核尺寸ksize累加2，当累加值超过30，又变回3</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'k'</span><span class="op">)</span> <span class="op">||</span> <span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'K'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">ksize</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">ksize</span><span class="op">&lt;</span><span class="fl">30</span>,<span class="va">ksize</span><span class="op">+</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#若这个过程中，用户按下s键，则导数内核放大系数累加1</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'s'</span><span class="op">)</span> <span class="op">||</span> <span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'S'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">scale</span><span class="op">=</span><span class="va">scale</span><span class="op">+</span><span class="fl">1</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#若这个过程中，用户按下d键，则导数内核偏移量累加1</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'d'</span><span class="op">)</span> <span class="op">||</span> <span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'D'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">delta</span><span class="op">=</span><span class="va">delta</span><span class="op">+</span><span class="fl">1</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#若这个过程中，用户按下r键，则：</span></span>
<span>  <span class="co">#ksize的值重置为3，scale的值重置为1，delta的值重置为0</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'r'</span><span class="op">)</span> <span class="op">||</span> <span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'R'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">ksize</span><span class="op">=</span><span class="fl">3</span></span>
<span>    <span class="va">scale</span><span class="op">=</span><span class="fl">1</span></span>
<span>    <span class="va">delta</span><span class="op">=</span><span class="fl">0</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
</div>
<div id="scharr算子" class="section level3" number="6.15.2">
<h3>
<span class="header-section-number">6.15.2</span> Scharr算子<a class="anchor" aria-label="anchor" href="#scharr%E7%AE%97%E5%AD%90"><i class="fas fa-link"></i></a>
</h3>
<p>当Sobel算子的导数内核<span class="math inline">\(M_x\)</span>和<span class="math inline">\(M_y\)</span>为3行3列矩阵时，计算结果可能会存在较大偏差。为此OpenCV通过使用Scharr算子来解决导数内核为3行3列时产生的不精确性。速度上，Scharr算子与Sobel算子一样快，但更精确。</p>
<p>Scharr算子使用的水平导数内核、垂直导数内核为：</p>
<p><span class="math display">\[
  M_x=\left[ \begin{matrix} -3&amp;0&amp;+3 \\ -10&amp;0&amp;+10 \\-3&amp;0&amp;+3 \end{matrix} \right]
\]</span></p>
<p><span class="math display">\[
  M_y=\left[ \begin{matrix} -3&amp;-10&amp;-3 \\ 0&amp;0&amp;0 \\+3&amp;+10&amp;+3 \end{matrix} \right]
\]</span></p>
<p><strong>示例</strong></p>
<p>通过Scharr算子计算图像的水平方向导数：</p>
<div class="sourceCode" id="cb1097"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="va">img_mat</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用Scharr算子计算水平方向导数</span></span>
<span><span class="va">res_scharr</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Scharr</span><span class="op">(</span><span class="va">img</span>,<span class="va">res_scharr</span>,<span class="va">CV_32F</span>,<span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_scharr</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]  [,5] [,6] [,7]
## [1,]    0    0 4080    0 -4080    0    0
## [2,]    0    0 4080    0 -4080    0    0
## [3,]    0    0 4080    0 -4080    0    0
## [4,]    0    0 4080    0 -4080    0    0
## [5,]    0    0 4080    0 -4080    0    0
## [6,]    0    0 4080    0 -4080    0    0
## [7,]    0    0 4080    0 -4080    0    0
## attr(,"depth")
## [1] 5</code></pre>
<p>可以通过如下代码来验证这个结果：</p>
<div class="sourceCode" id="cb1099"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="va">img_mat</span><span class="op">[</span>,<span class="fl">4</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#按BORDER_DEFAULT方式扩展图像边缘：</span></span>
<span><span class="co">#对于3行3列且锚点在中心位置的滤波器，只需上下各扩展1行，左右各扩展1列即可，</span></span>
<span><span class="co">#扩展结果保存在img_borderadded中</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用cv2r函数img_borderadded转变为R语言的矩阵img_borderadded_mat</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#res_mat先初始化为img_borderadded_mat</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span></span>
<span><span class="co">#设定滤波器的行数和列数</span></span>
<span><span class="va">m</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="va">n</span><span class="op">=</span><span class="fl">3</span></span>
<span><span class="co">#设定滤波器的锚点为其中心点</span></span>
<span><span class="va">anchor_x</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="va">anchor_y</span><span class="op">=</span><span class="fl">1</span></span>
<span><span class="co">#生成滤波器（水平导数内核）</span></span>
<span><span class="va">Mx</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">3</span>,<span class="op">-</span><span class="fl">10</span>,<span class="op">-</span><span class="fl">3</span>, <span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">0</span>, <span class="fl">3</span>,<span class="fl">10</span>,<span class="fl">3</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#移动水平导数内核，计算目标像素的水平导数值，并保存在res.mat的对应位置中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">8</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fl">8</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#取出目标像素的领域像素矩阵，保存在tmp中</span></span>
<span>    <span class="va">tmp</span> <span class="op">=</span> <span class="va">img_borderadded_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">m</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>                              <span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_x</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="va">anchor_y</span><span class="op">+</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span>    <span class="co">#将tmp与滤波器ker的对应元素相乘再求和，得到目标像素的滤波输出值</span></span>
<span>    <span class="va">res_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">tmp</span> <span class="op">*</span> <span class="va">Mx</span><span class="op">)</span> </span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除扩展的边缘</span></span>
<span><span class="va">res_mat</span> <span class="op">=</span> <span class="va">res_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">9</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">9</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_mat</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]  [,5] [,6] [,7]
## [1,]    0    0 4080    0 -4080    0    0
## [2,]    0    0 4080    0 -4080    0    0
## [3,]    0    0 4080    0 -4080    0    0
## [4,]    0    0 4080    0 -4080    0    0
## [5,]    0    0 4080    0 -4080    0    0
## [6,]    0    0 4080    0 -4080    0    0
## [7,]    0    0 4080    0 -4080    0    0</code></pre>
<p>类似地，可以通过Scharr算子计算图像的垂直方向导数（并进行验证）。</p>
</div>
<div id="laplace算子" class="section level3" number="6.15.3">
<h3>
<span class="header-section-number">6.15.3</span> Laplace算子<a class="anchor" aria-label="anchor" href="#laplace%E7%AE%97%E5%AD%90"><i class="fas fa-link"></i></a>
</h3>
<p>函数<span class="math inline">\(\displaystyle y=f(x)=\frac{1} {(1+e^{-x})}\)</span>在<span class="math inline">\(x=0\)</span>处，函数值变化最快（见下图）。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-253-1.png" width="672"></div>
<p>函数<span class="math inline">\(\displaystyle y=f(x)=\frac{1} {(1+e^{-x})}\)</span>的一阶导数在<span class="math inline">\(x=0\)</span>处取最大值（如下图）。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-254-1.png" width="672"></div>
<p>而函数<span class="math inline">\(\displaystyle y=f(x)=\frac{1} {(1+e^{-x})}\)</span>的二阶导数在<span class="math inline">\(x=0\)</span>处为0。</p>
<div class="inline-figure"><img src="07-imgproc_files/figure-html/unnamed-chunk-255-1.png" width="672"></div>
<p>OpenCV中的Laplace算子就是使用图像强度函数的二阶导数为0的准则来检测图像中的边缘。在实际边缘检测中，由于二阶导数为0的点不仅出现在边缘上，也可以出现在其他无意义的位置上，所以Laplace算子还包括对非边缘点的过滤方法。</p>
<p>Laplace算子的核心计算公式为：</p>
<p><span class="math display">\[
Laplace(f) = \frac {\partial^2 f} {\partial x^2}+\frac {\partial^2 f} {\partial y^2}
\]</span>
其中<span class="math inline">\(f\)</span>表示图像强度函数。</p>
<p>公式表明：Laplace算子会计算每个像素所在位置的水平二阶导数和垂直二阶导数，而后再计算这两个二阶导数之和。而这种计算过程，可以转为图像平滑运算，而采用的滤波器为如下类似矩阵：</p>
<p><span class="math display">\[
M_x=\left[ \begin{matrix} +2&amp;0&amp;+2 \\ 0&amp;-8&amp;0 \\+2&amp;0&amp;+2 \end{matrix} \right]
\]</span></p>
<p>使用此滤波器对图像进行平滑：</p>
<p><span class="math display">\[
  G_x= I \otimes M_x
\]</span></p>
<p>平滑结果<span class="math inline">\(G_x\)</span>中的每个元素都表示原图像强度函数在对应像素位置处的水平方向导数，即体现着原图像强度函数在相应位置处的水平方向的变化速度。</p>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb1101"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img.mat</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">7</span>,<span class="fl">7</span><span class="op">*</span><span class="fl">7</span>,replace<span class="op">=</span><span class="cn">T</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span><span class="co">#将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img使用Laplace算子</span></span>
<span><span class="va">res_lap</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Laplacian</span><span class="op">(</span><span class="va">img</span>,<span class="va">res_lap</span>,<span class="va">CV_32F</span>,<span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果</span></span>
<span><span class="va">res_lap</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]  -32   -8    0   28   16  -28   32
## [2,]  -12   10   10   14  -14  -26   36
## [3,]    4   -2  -18   -8    8    4   32
## [4,]   -4   -4   12   10   -6  -28  -32
## [5,]   16  -24   16    2   -4   16   24
## [6,]   12  -24   14  -24   18   -6    4
## [7,]   32    4   20   -8   24  -36    0
## attr(,"depth")
## [1] 5</code></pre>
<p>可以通过如下代码（基于Sobel算子计算两个方向的二阶导数）验证这个结果：</p>
<div class="sourceCode" id="cb1103"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img_mat</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">7</span>,<span class="fl">7</span><span class="op">*</span><span class="fl">7</span>,replace<span class="op">=</span><span class="cn">T</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">7</span>,nc<span class="op">=</span><span class="fl">7</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将img.mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">7</span>,<span class="fl">7</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用Sobel算子计算2阶水平方向导数和2阶垂直方向导数，</span></span>
<span><span class="co">#结果分别保存在res_sobel_x2和res_sobel_y2中</span></span>
<span><span class="va">res_sobel_x2</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">res_sobel_x2</span>,<span class="va">CV_32F</span>,<span class="fl">2</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">res_sobel_y2</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_Sobel</span><span class="op">(</span><span class="va">img</span>,<span class="va">res_sobel_y2</span>,<span class="va">CV_32F</span>,<span class="fl">0</span>,<span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果（水平方向2阶导数和垂直方向2阶导数之和）</span></span>
<span><span class="va">res_sobel_x2</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> <span class="va">res_sobel_y2</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]  -32   -8    0   28   16  -28   32
## [2,]  -12   10   10   14  -14  -26   36
## [3,]    4   -2  -18   -8    8    4   32
## [4,]   -4   -4   12   10   -6  -28  -32
## [5,]   16  -24   16    2   -4   16   24
## [6,]   12  -24   14  -24   18   -6    4
## [7,]   32    4   20   -8   24  -36    0
## attr(,"depth")
## [1] 5</code></pre>
<p>还可以通过如下代码（图形平滑思路）来验证这个结果：</p>
<p><strong>示例</strong></p>
<p>以下代码演示了如何交互控制Laplace算子的导数内核尺寸ksize、导数放大系数scale和导数偏移量delta，进而观察不同的边缘检测效果。</p>
<div class="inline-figure"><img src="images/LaplaceDemo.png"></div>
<div class="sourceCode" id="cb1105"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#将图形窗口的标题存放在window_name中</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Laplace Demo"</span></span>
<span><span class="co">#Sobel算子的导数内核尺寸存放在ksize中，初始值为3</span></span>
<span><span class="va">ksize</span> <span class="op">=</span> <span class="fl">3</span></span>
<span><span class="co">#Sobel算子的导数放大系数存放在scale中，初始值为1</span></span>
<span><span class="va">scale</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="co">#Sobel算子的导数偏移量存放在delta中，初始值为0</span></span>
<span><span class="va">delta</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="co">#Sobel算子的求导结果是32位浮点数</span></span>
<span><span class="va">ddepth</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">CV_32F</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成引用类型变量，作为OpenCV中的函数的引用参数</span></span>
<span><span class="kw">while</span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#对img进行高斯平滑，结果保存在img_gauss中</span></span>
<span>  <span class="va">img_gauss</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_GaussianBlur</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_gauss</span>,<span class="fu">Size</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span><span class="op">)</span>,<span class="fl">0</span>,<span class="fl">0</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#将img_gauss灰度化，结果保存在img_gray中</span></span>
<span>  <span class="va">img_gray</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_gray</span>,<span class="va">COLOR_BGR2GRAY</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#求img_gray使用Laplace算子</span></span>
<span>  <span class="va">img_lap</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_Laplacian</span><span class="op">(</span><span class="va">img_gray</span>,<span class="va">img_lap</span>,<span class="va">ddepth</span>,<span class="va">ksize</span>,<span class="va">scale</span>,<span class="va">delta</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#将img_lap标准化，便于显示img_lap对应的图像</span></span>
<span>  <span class="fu">cv_normalize</span><span class="op">(</span><span class="va">img_lap</span>,<span class="va">img_lap</span>,norm_type <span class="op">=</span> <span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">img_lap</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#图形窗口等待用户输入</span></span>
<span>  <span class="va">key</span> <span class="op">=</span> <span class="fu">cv_waitKey</span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span>  <span class="co">#若这个过程中，用户按下esc键，则循环终止</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fl">27</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="kw">break</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#若这个过程中，用户按下k键，则导数内核尺寸ksize累加2，当累加值超过30，又变回3</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'k'</span><span class="op">)</span> <span class="op">||</span> <span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'K'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">ksize</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">ksize</span><span class="op">&lt;</span><span class="fl">30</span>,<span class="va">ksize</span><span class="op">+</span><span class="fl">2</span>,<span class="fl">3</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#若这个过程中，用户按下s键，则导数内核放大系数累加1</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'s'</span><span class="op">)</span> <span class="op">||</span> <span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'S'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">scale</span><span class="op">=</span><span class="va">scale</span><span class="op">+</span><span class="fl">1</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#若这个过程中，用户按下d键，则导数内核偏移量累加1</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'d'</span><span class="op">)</span> <span class="op">||</span> <span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'D'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">delta</span><span class="op">=</span><span class="va">delta</span><span class="op">+</span><span class="fl">1</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#若这个过程中，用户按下r键，则ksize的值重置为3，scale的值重置为1，delta的值重置为0</span></span>
<span>  <span class="kw">if</span><span class="op">(</span><span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'r'</span><span class="op">)</span> <span class="op">||</span> <span class="va">key</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'R'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">ksize</span><span class="op">=</span><span class="fl">3</span></span>
<span>    <span class="va">scale</span><span class="op">=</span><span class="fl">1</span></span>
<span>    <span class="va">delta</span><span class="op">=</span><span class="fl">0</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
</div>
<div id="canny算子" class="section level3" number="6.15.4">
<h3>
<span class="header-section-number">6.15.4</span> Canny算子<a class="anchor" aria-label="anchor" href="#canny%E7%AE%97%E5%AD%90"><i class="fas fa-link"></i></a>
</h3>
<p>应用Canny算子检测边缘的主要步骤：</p>
<ul>
<li><p>通过图像平滑抑制噪声<br></p></li>
<li>
<p>计算图像强度梯度的模和梯度方向</p>
<ul>
<li>使用Sobel算子，计算图像水平方向导数<span class="math inline">\(G_x\)</span>和垂直方向导数<span class="math inline">\(G_y\)</span>。<br>
</li>
<li>通过如下公式计算梯度的模和梯度方向：</li>
</ul>
</li>
</ul>
<p><span class="math display">\[
  \begin{aligned}
    G &amp;= \sqrt {G_x^2+G_y^2} \\
    \theta &amp;= arctan \left( \frac{G_y}{G_x} \right)
  \end{aligned}
\]</span></p>
<p>梯度方向值会四舍五入到四个可能的角度之一，即0、45、90或135</p>
<ul>
<li><p>应用非最大抑制，删除不应被视为边缘的像素（这里涉及到插值、比较等操作）。</p></li>
<li>
<p>确定并使用上、下两个阈值进一步过滤目前的都的边缘像素</p>
<ul>
<li>如果像素梯度的模高于上阈值，则接受该像素作为边缘；<br>
</li>
<li>如果像素梯度的模低于下限阈值，则拒绝该像素作为边缘；<br>
</li>
<li>如果像素梯度的模在两个阈值之间，则仅当它连接到高于上阈值的像素时才接受该像素作为边缘。</li>
</ul>
</li>
</ul>
<p>Canny推荐的上、下阈值之比在2:1和3:1之间。</p>
<p><strong>示例</strong></p>
<p>以下代码用滑动条控制Canny算子的下阈值，上阈值则自动为下阈值的3倍，便于观察在不同上、下阈值下Canny算子的边缘检测效果。</p>
<div class="sourceCode" id="cb1106"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#控制下阈值的滑动条的最大取值为100</span></span>
<span><span class="va">max_lowThreshold</span> <span class="op">=</span> <span class="fl">100</span></span>
<span><span class="co">#调用Sobel算子时，水平导数内核与垂直导数内核的尺寸为3行3列矩阵</span></span>
<span><span class="va">ksize</span> <span class="op">=</span> <span class="fl">3</span></span>
<span><span class="co">#将图形窗口的标题存放在window_name中</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"Edge Map"</span></span>
<span></span>
<span><span class="co">#读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/building1.jpg"</span><span class="op">)</span></span>
<span><span class="co">#将src转变为灰度图，结果保存在src_gray中</span></span>
<span><span class="va">src_gray</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_cvtColor</span><span class="op">(</span><span class="va">src</span>, <span class="va">src_gray</span>, <span class="va">COLOR_BGR2GRAY</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#定义滑动条滑动事件的响应函数CannyThreshold</span></span>
<span></span>
<span><span class="va">CannyThreshold</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">val</span>, <span class="va">param</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#对src_gray进行平滑操作（使用的是归一化盒子滤波），结果保存在src_blur中</span></span>
<span>  <span class="va">src_blur</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_blur</span><span class="op">(</span><span class="va">src_gray</span>, <span class="va">src_blur</span>, <span class="fu">Size</span><span class="op">(</span><span class="fl">3</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#获取控制下阈值的滑动条的当前取值，存入lowThreshold中</span></span>
<span>  <span class="va">lowThreshold</span> <span class="op">=</span> <span class="fu">cv_getTrackbarPos</span><span class="op">(</span><span class="st">"Min Threshold:"</span>, <span class="va">window_name</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#对src_blur进行Canny算子边缘检测，结果保存在detected_edges中</span></span>
<span>  <span class="va">detected_edges</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_Canny</span><span class="op">(</span></span>
<span>    <span class="va">src_blur</span>,</span>
<span>    <span class="va">detected_edges</span>,</span>
<span>    <span class="va">lowThreshold</span>,</span>
<span>    <span class="fl">3</span> <span class="op">*</span> <span class="va">lowThreshold</span>,</span>
<span>    <span class="va">ksize</span></span>
<span>  <span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#将detected_edges显示在window_name指定的标题的图形窗口中</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">detected_edges</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#创建以window_name取值为标题的图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="va">window_name</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#在图形窗口中创建控制Canny算子下阈值的滑动条（滑动条的位置先置于30处）</span></span>
<span><span class="fu">cv_createTrackbar</span><span class="op">(</span><span class="st">"Min Threshold:"</span>,</span>
<span>                  <span class="va">window_name</span>,</span>
<span>                  <span class="fl">30</span>,</span>
<span>                  <span class="va">max_lowThreshold</span>,</span>
<span>                  <span class="va">CannyThreshold</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#调用CannyThreshold函数</span></span>
<span><span class="fu">CannyThreshold</span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span></span></code></pre></div>

</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">5</span> 核心功能（核心模块）</a></div>
<div class="next"><a href="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86imgproc%E6%A8%A1%E5%9D%97-part2.html"><span class="header-section-number">7</span> 图像处理（imgproc模块-PART2）</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86imgproc%E6%A8%A1%E5%9D%97-part1"><span class="header-section-number">6</span> 图像处理（imgproc模块-PART1）</a></li>
<li><a class="nav-link" href="#%E7%81%B0%E5%BA%A6%E5%8C%96"><span class="header-section-number">6.1</span> 灰度化</a></li>
<li><a class="nav-link" href="#%E5%B0%BA%E5%AF%B8%E5%8F%98%E6%8D%A2"><span class="header-section-number">6.2</span> 尺寸变换</a></li>
<li><a class="nav-link" href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><span class="header-section-number">6.3</span> 仿射变换</a></li>
<li><a class="nav-link" href="#%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2"><span class="header-section-number">6.4</span> 透视变换</a></li>
<li>
<a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%98%E5%9B%BE-1"><span class="header-section-number">6.5</span> 基础绘图</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#point%E4%B8%8Escalar"><span class="header-section-number">6.5.1</span> Point与Scalar</a></li>
<li><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF%E6%AE%B5"><span class="header-section-number">6.5.2</span> 绘制直线（段）</a></li>
<li><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2"><span class="header-section-number">6.5.3</span> 绘制矩形</a></li>
<li><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%9C%86"><span class="header-section-number">6.5.4</span> 绘制圆</a></li>
<li><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E6%A4%AD%E5%9C%86%E5%BC%A7"><span class="header-section-number">6.5.5</span> 绘制椭圆弧</a></li>
<li><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="header-section-number">6.5.6</span> 绘制多边形</a></li>
<li><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%A1%AB%E5%85%85%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="header-section-number">6.5.7</span> 绘制填充多边形</a></li>
<li><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC"><span class="header-section-number">6.5.8</span> 绘制文本</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E9%98%88%E5%80%BC%E8%BF%90%E7%AE%97"><span class="header-section-number">6.6</span> 基本阈值运算</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E5%8C%96%E9%98%88%E5%80%BC"><span class="header-section-number">6.6.1</span> 二值化阈值</a></li>
<li><a class="nav-link" href="#%E9%80%86%E4%BA%8C%E5%80%BC%E5%8C%96%E9%98%88%E5%80%BC"><span class="header-section-number">6.6.2</span> 逆二值化阈值</a></li>
<li><a class="nav-link" href="#%E6%88%AA%E6%96%AD"><span class="header-section-number">6.6.3</span> 截断</a></li>
<li><a class="nav-link" href="#%E4%B8%8B%E6%8A%98%E6%96%AD%E9%98%88%E5%80%BC%E4%BB%A5%E4%B8%8B%E4%B8%BA0"><span class="header-section-number">6.6.4</span> 下折断（阈值以下为0）</a></li>
<li><a class="nav-link" href="#%E4%B8%8A%E6%8A%98%E6%96%AD%E9%98%88%E5%80%BC%E4%BB%A5%E4%B8%8A%E4%B8%BA0"><span class="header-section-number">6.6.5</span> 上折断（阈值以上为0）</a></li>
<li><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="header-section-number">6.6.6</span> 应用示例</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#%E4%BD%BF%E7%94%A8inrange%E8%BF%9B%E8%A1%8C%E9%98%88%E5%80%BC%E8%BF%90%E7%AE%97"><span class="header-section-number">6.7</span> 使用inRange进行阈值运算</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#hsv%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4"><span class="header-section-number">6.7.1</span> HSV色彩空间</a></li>
<li><a class="nav-link" href="#%E8%AE%A1%E7%AE%97bgr%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%8C%87%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%AF%B9%E5%BA%94%E7%9A%84hsv%E9%A2%9C%E8%89%B2%E5%80%BC"><span class="header-section-number">6.7.2</span> 计算BGR颜色空间中指定颜色对应的HSV颜色值</a></li>
</ul>
</li>
<li><a class="nav-link" href="#%E6%BC%AB%E6%B0%B4%E5%A1%AB%E5%85%85"><span class="header-section-number">6.8</span> 漫水填充</a></li>
<li>
<a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91"><span class="header-section-number">6.9</span> 图像平滑</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="header-section-number">6.9.1</span> 常用滤波器</a></li>
<li><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%A4%E6%B3%A2%E5%99%A8"><span class="header-section-number">6.9.2</span> 自定义滤波器</a></li>
</ul>
</li>
<li><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E7%9A%84%E7%BB%93%E6%9E%84%E6%A0%B8"><span class="header-section-number">6.10</span> 形态学的结构核</a></li>
<li>
<a class="nav-link" href="#%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80"><span class="header-section-number">6.11</span> 腐蚀与膨胀</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E8%86%A8%E8%83%80"><span class="header-section-number">6.11.1</span> 膨胀</a></li>
<li><a class="nav-link" href="#%E8%85%90%E8%9A%80"><span class="header-section-number">6.11.2</span> 腐蚀</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#%E5%BC%80%E8%BF%90%E7%AE%97%E9%97%AD%E8%BF%90%E7%AE%97%E5%92%8C%E5%BD%A2%E6%80%81%E5%AD%A6%E6%A2%AF%E5%BA%A6"><span class="header-section-number">6.12</span> 开运算、闭运算和形态学梯度</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E5%BC%80%E8%BF%90%E7%AE%97"><span class="header-section-number">6.12.1</span> 开运算</a></li>
<li><a class="nav-link" href="#%E9%97%AD%E8%BF%90%E7%AE%97"><span class="header-section-number">6.12.2</span> 闭运算</a></li>
<li><a class="nav-link" href="#%E7%A4%BC%E5%B8%BD"><span class="header-section-number">6.12.3</span> 礼帽</a></li>
<li><a class="nav-link" href="#%E9%BB%91%E5%B8%BD"><span class="header-section-number">6.12.4</span> 黑帽</a></li>
<li><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E6%A2%AF%E5%BA%A6"><span class="header-section-number">6.12.5</span> 形态学梯度</a></li>
</ul>
</li>
<li><a class="nav-link" href="#%E5%87%BB%E4%B8%AD-%E5%87%BB%E4%B8%8D%E4%B8%AD%E5%8F%98%E6%8D%A2hit-miss"><span class="header-section-number">6.13</span> 击中-击不中变换（hit-miss）</a></li>
<li>
<a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94"><span class="header-section-number">6.14</span> 图像金字塔</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94gaussian-pyramid"><span class="header-section-number">6.14.1</span> 高斯金字塔（Gaussian pyramid）</a></li>
<li><a class="nav-link" href="#%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94laplacian-pyramid"><span class="header-section-number">6.14.2</span> 拉普拉斯金字塔（Laplacian pyramid）</a></li>
<li><a class="nav-link" href="#dog%E9%87%91%E5%AD%97%E5%A1%94difference-of-gaussian-dog"><span class="header-section-number">6.14.3</span> DOG金字塔(Difference of Gaussian-DOG)</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="header-section-number">6.15</span> 图像边缘检测</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#sobel%E7%AE%97%E5%AD%90"><span class="header-section-number">6.15.1</span> Sobel算子</a></li>
<li><a class="nav-link" href="#scharr%E7%AE%97%E5%AD%90"><span class="header-section-number">6.15.2</span> Scharr算子</a></li>
<li><a class="nav-link" href="#laplace%E7%AE%97%E5%AD%90"><span class="header-section-number">6.15.3</span> Laplace算子</a></li>
<li><a class="nav-link" href="#canny%E7%AE%97%E5%AD%90"><span class="header-section-number">6.15.4</span> Canny算子</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/Judy-ZQ/ROpenCV-Tutorial/blob/master/07-imgproc.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/Judy-ZQ/ROpenCV-Tutorial/edit/master/07-imgproc.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>ROpenCV — R与OpenCV之间的桥梁</strong>" was written by zpy. It was last built on 2024-11-02.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
