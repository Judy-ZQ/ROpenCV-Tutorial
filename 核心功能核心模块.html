<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>5 核心功能（核心模块） | ROpenCV — R与OpenCV之间的桥梁</title>
<meta name="author" content="zpy">
<meta name="generator" content="bookdown 0.40 with bs4_book()">
<meta property="og:title" content="5 核心功能（核心模块） | ROpenCV — R与OpenCV之间的桥梁">
<meta property="og:type" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="5 核心功能（核心模块） | ROpenCV — R与OpenCV之间的桥梁">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.8.0/transition.js"></script><script src="libs/bs3compat-0.8.0/tabs.js"></script><script src="libs/bs3compat-0.8.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-141212623-1"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-141212623-1');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<meta name="description" content='5.1 遍历图像矩阵的像素 通过图像矩阵类实例的可以遍历图像矩阵的像素： #读取图像文件，读取结果保存在img中 img = cv_imread("images/LinuxLogo.jpg") #获取图像第112行~第116行，第167列到第171列的像素， #并输出到命令行窗口中 for(rr in 111:115){  for(cc in 166:170){  ...'>
<meta property="og:description" content='5.1 遍历图像矩阵的像素 通过图像矩阵类实例的可以遍历图像矩阵的像素： #读取图像文件，读取结果保存在img中 img = cv_imread("images/LinuxLogo.jpg") #获取图像第112行~第116行，第167列到第171列的像素， #并输出到命令行窗口中 for(rr in 111:115){  for(cc in 166:170){  ...'>
<meta name="twitter:description" content='5.1 遍历图像矩阵的像素 通过图像矩阵类实例的可以遍历图像矩阵的像素： #读取图像文件，读取结果保存在img中 img = cv_imread("images/LinuxLogo.jpg") #获取图像第112行~第116行，第167列到第171列的像素， #并输出到命令行窗口中 for(rr in 111:115){  for(cc in 166:170){  ...'>
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">ROpenCV — R与OpenCV之间的桥梁</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">前言</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> 简介</a></li>
<li><a class="" href="RBasis.html"><span class="header-section-number">2</span> R基础</a></li>
<li><a class="" href="imagebasis.html"><span class="header-section-number">3</span> OpenCV中的图像矩阵类（Mat）</a></li>
<li><a class="" href="%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html"><span class="header-section-number">4</span> 图像基本操作</a></li>
<li><a class="active" href="%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">5</span> 核心功能（核心模块）</a></li>
<li><a class="" href="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86imgproc%E6%A8%A1%E5%9D%97-part1.html"><span class="header-section-number">6</span> 图像处理（imgproc模块-PART1）</a></li>
<li><a class="" href="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86imgproc%E6%A8%A1%E5%9D%97-part2.html"><span class="header-section-number">7</span> 图像处理（imgproc模块-PART2）</a></li>
<li><a class="" href="%E6%91%84%E5%83%8F%E6%9C%BA%E6%A0%87%E5%AE%9A%E5%92%8C%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BAcalib3d%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">8</span> 摄像机标定和三维重建（calib3d模块）</a></li>
<li><a class="" href="d%E7%89%B9%E5%BE%81%E6%A1%86%E6%9E%B6feature2d%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">9</span> 2D特征框架（feature2d模块）</a></li>
<li><a class="" href="%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91io%E4%BB%A5%E5%8F%8Avideo%E6%A8%A1%E5%9D%97.html"><span class="header-section-number">10</span> 视频处理（视频IO以及Video模块）</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/Judy-ZQ/ROpenCV-Tutorial">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="核心功能核心模块" class="section level1" number="5">
<h1>
<span class="header-section-number">5</span> 核心功能（核心模块）<a class="anchor" aria-label="anchor" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><i class="fas fa-link"></i></a>
</h1>
<div id="遍历图像矩阵的像素" class="section level2" number="5.1">
<h2>
<span class="header-section-number">5.1</span> 遍历图像矩阵的像素<a class="anchor" aria-label="anchor" href="#%E9%81%8D%E5%8E%86%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%83%8F%E7%B4%A0"><i class="fas fa-link"></i></a>
</h2>
<p>通过图像矩阵类实例的可以遍历图像矩阵的像素：</p>
<div class="sourceCode" id="cb713"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件，读取结果保存在img中</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/LinuxLogo.jpg"</span><span class="op">)</span></span>
<span><span class="co">#获取图像第112行~第116行，第167列到第171列的像素，</span></span>
<span><span class="co">#并输出到命令行窗口中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">rr</span> <span class="kw">in</span> <span class="fl">111</span><span class="op">:</span><span class="fl">115</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">cc</span> <span class="kw">in</span> <span class="fl">166</span><span class="op">:</span><span class="fl">170</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#获取rr行cc列的像素值px（由于img是三通道图像，所以px包含三个值）</span></span>
<span>    <span class="va">px</span> <span class="op">=</span> <span class="va">img</span><span class="op">[</span><span class="va">rr</span>,<span class="va">cc</span><span class="op">]</span></span>
<span>    <span class="co">#将px输出到命令行窗口中，并以竖线间隔开</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="va">px</span>,<span class="st">"|"</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#一行像素遍历结束后，换行</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<pre><code>## 255 255 255 |254 254 254 |252 252 252 |255 255 255 |253 253 253 |
## 247 247 247 |255 255 255 |254 254 254 |252 252 252 |255 255 255 |
## 251 251 251 |254 254 254 |254 254 254 |252 252 252 |255 255 255 |
## 252 252 252 |252 252 252 |254 254 254 |252 252 252 |255 255 255 |
## 252 252 252 |253 253 253 |254 254 254 |252 252 252 |255 255 255 |</code></pre>
<div class="sourceCode" id="cb715"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 或者直接使用如下命令</span></span>
<span><span class="co"># img[111:115,166:170]</span></span></code></pre></div>
<p>也可以通过cv2r函数把图像矩阵转变为R语言的矩阵（或者数组），进而遍历像素：</p>
<div class="sourceCode" id="cb716"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读入图像，获取图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/LinuxLogo.jpg"</span><span class="op">)</span></span>
<span><span class="co">#通过cv2r函数将img转变为R语言的数组img.arr</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#获取img_arr的第112行~第116行，第167列到第171列的元素，</span></span>
<span><span class="co">#并输出到命令行窗口中</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">rr</span> <span class="kw">in</span> <span class="fl">112</span><span class="op">:</span><span class="fl">116</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">cc</span> <span class="kw">in</span> <span class="fl">167</span><span class="op">:</span><span class="fl">171</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#获取rr行cc列的元素值px（由于是img是三维数组，所以px包含三个值）</span></span>
<span>    <span class="va">px</span> <span class="op">=</span> <span class="va">img_arr</span><span class="op">[</span><span class="va">rr</span>,<span class="va">cc</span>,<span class="op">]</span></span>
<span>    <span class="co">#将px输出到命令行窗口中，并以竖线间隔开</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="va">px</span>,<span class="st">"|"</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="co">#一行像素遍历结束后，换行</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\n"</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<pre><code>## 255 255 255 |254 254 254 |252 252 252 |255 255 255 |253 253 253 |
## 247 247 247 |255 255 255 |254 254 254 |252 252 252 |255 255 255 |
## 251 251 251 |254 254 254 |254 254 254 |252 252 252 |255 255 255 |
## 252 252 252 |252 252 252 |254 254 254 |252 252 252 |255 255 255 |
## 252 252 252 |253 253 253 |254 254 254 |252 252 252 |255 255 255 |</code></pre>
<div class="sourceCode" id="cb718"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 或者直接使用如下命令</span></span>
<span><span class="co"># img_arr[111:115,166:170,]</span></span></code></pre></div>
</div>
<div id="使用查询表" class="section level2" number="5.2">
<h2>
<span class="header-section-number">5.2</span> 使用查询表<a class="anchor" aria-label="anchor" href="#%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E8%A1%A8"><i class="fas fa-link"></i></a>
</h2>
<p>依据从前面的知识可知，8位无符号单通道图像的颜色数有<span class="math inline">\(2^8=256\)</span>个，而8位无符号三通道图像的颜色数则有<span class="math inline">\(2^8 \times 2^8 \times 2^8 \approx1600\)</span>万颜色值。使用如此多的颜色会严重影响我们的算法性能。事实上，有时只需与很少颜色就能得到相同的最终结果。所以，在一些情况下，我们通常会减少颜色空间。比如将颜色除以一个整数，然后向下取整再乘以该整数，就可以得到更少的颜色（见如下公式）。例如将颜色值除以10，向下取整后再乘以10（见如下公式），那么0到9之间的每个值变为0，10到19之间的每个值变为10，以此类推。</p>
<p><span class="math display">\[
I_{new} = \left \lfloor \frac{I_{old}}{10} \right \rfloor \times 10
\]</span></p>
<div class="sourceCode" id="cb719"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#按灰度方式读入图像，获取图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/HappyFish.jpg"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#用cv2r函数将img转变为R语言的矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#查询img.mat中存在多少个颜色值</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 256</code></pre>
<div class="sourceCode" id="cb721"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看img_mat第1行~第6行、第1列~第6列的数据</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]  254  254  254  254  254  254
## [2,]  254  254  254  254  254  254
## [3,]  254  254  254  254  254  254
## [4,]  254  254  254  254  254  254
## [5,]  254  254  254  254  254  254
## [6,]  254  254  254  254  254  254</code></pre>
<div class="sourceCode" id="cb723"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#基于查询表获取img_mat原来数值对应的新值，并进行更新</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">img_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">floor</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span><span class="op">/</span><span class="fl">10</span><span class="op">)</span><span class="op">*</span><span class="fl">10</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#更新之后，再次查询img.mat中存在多少个颜色值</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 26</code></pre>
<div class="sourceCode" id="cb725"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#利用r2cv函数，将img_mat转变为OpenCV的图像矩阵</span></span>
<span><span class="va">img1</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img1</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span></code></pre></div>
<p>由于除法和乘法运算操作对于一个系统来说是比较耗时的，这时候一个明智的做法是预先计算所有可能的值并将结果存放在”查询表（Lookup table）“中，而后通过查表操作依据<span class="math inline">\(I_{old}\)</span>得到<span class="math inline">\(I_{new}\)</span>。”查询表”是一个简单的数组（具有一个或多个维度），体现着输入值和输出值的对应关系。它的优点是可以避开耗时的计算，而只需要查询并读取结果。</p>
<div class="sourceCode" id="cb726"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成查询表lookuptbl</span></span>
<span><span class="va">lookuptbl</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">24</span>,each<span class="op">=</span><span class="fl">10</span><span class="op">)</span><span class="op">*</span><span class="fl">10</span>,<span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">250</span>,<span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#基于查询表，可以快速查找I_old（比如87）对应的I_new（为80）</span></span>
<span><span class="va">I_old</span> <span class="op">=</span> <span class="fl">87</span></span>
<span><span class="va">I_new</span> <span class="op">=</span> <span class="va">lookuptbl</span><span class="op">[</span><span class="va">I_old</span><span class="op">]</span></span>
<span><span class="va">I_new</span></span></code></pre></div>
<pre><code>## [1] 80</code></pre>
<div class="sourceCode" id="cb728"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#按灰度方式读入图像，获取图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/HappyFish.jpg"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#用cv2r函数将img转变为R语言的矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#查询img.mat中存在多少个颜色值</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 256</code></pre>
<div class="sourceCode" id="cb730"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看img_mat第1行~第6行、第1列~第6列的数据</span></span>
<span><span class="va">img_mat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]  254  254  254  254  254  254
## [2,]  254  254  254  254  254  254
## [3,]  254  254  254  254  254  254
## [4,]  254  254  254  254  254  254
## [5,]  254  254  254  254  254  254
## [6,]  254  254  254  254  254  254</code></pre>
<div class="sourceCode" id="cb732"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成img_new_mat，尺寸与img_mat相同，所有元素为0</span></span>
<span><span class="va">img_new_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span>,nc<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#基于查询表获取img_mat原来数值对应的新值，并更新img_new_mat对应的值</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">I_old</span> <span class="op">=</span> <span class="va">img_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span><span class="op">+</span><span class="fl">1</span> <span class="co">#因颜色值以0开始,故而加1</span></span>
<span>    <span class="va">I_new</span> <span class="op">=</span> <span class="va">lookuptbl</span><span class="op">[</span><span class="va">I_old</span><span class="op">]</span></span>
<span>    <span class="va">img_new_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="va">I_new</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#查询img.new.mat中存在多少个颜色值</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unique.html">unique</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">img_new_mat</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 26</code></pre>
<div class="sourceCode" id="cb734"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#利用r2cv函数，将img.new.mat转变为OpenCV的图像矩阵</span></span>
<span><span class="va">img1</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_new_mat</span>,<span class="st">"depth"</span><span class="op">)</span><span class="op">=</span><span class="va">img1</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img1</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_new_mat</span><span class="op">)</span></span></code></pre></div>
<p>下图左边是原始图像，右边是压缩了颜色空间之后的图像。</p>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-6-1.png" width="672"></div>
<p><strong><em>我们的测试操作如下：读入图像（它可以是彩色或灰度），指定用于缩减算法的整数值。然后使用三种方法对图像进行扫描，转换读取到的颜色值，并打印出所花的时间（代码形式如下）。</em></strong></p>
</div>
<div id="计算操作时间" class="section level2" number="5.3">
<h2>
<span class="header-section-number">5.3</span> 计算操作时间<a class="anchor" aria-label="anchor" href="#%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4"><i class="fas fa-link"></i></a>
</h2>
<p>在OpenCV中，可以通过如下方式计算一些计算操作消耗的时间：</p>
<div class="sourceCode" id="cb735"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#获取时间刻度t1，作为计时开始点</span></span>
<span><span class="va">t1</span><span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#开始进行一些计算</span></span>
<span><span class="co">#……</span></span>
<span><span class="co">#计算结束</span></span>
<span></span>
<span><span class="co">#获取时间刻度t2，作为计时结束点</span></span>
<span><span class="va">t2</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#打印出从t1到t2所经历的时间(单位：秒)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html">sprintf</a></span><span class="op">(</span><span class="st">"Times passed in seconds: %f"</span>,<span class="op">(</span><span class="va">t2</span><span class="op">-</span><span class="va">t1</span><span class="op">)</span><span class="op">/</span><span class="fu">cv_getTickFrequency</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>比如，计算直接使用乘法、除法操作压缩狒狒图像颜色空间时所消耗的时间：</p>
<div class="sourceCode" id="cb736"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#获取时间刻度t1，作为计时开始点</span></span>
<span><span class="va">t1</span><span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#加载图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/baboon.jpg"</span><span class="op">)</span></span>
<span><span class="co">#用cv2r函数将img转变为R语言的数组</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img_arr包含的3个矩阵的每个元素通过乘除运算压缩颜色空间</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">img_arr</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span>,<span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">floor</a></span><span class="op">(</span><span class="va">img_arr</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span>,<span class="op">]</span><span class="op">/</span><span class="fl">10</span><span class="op">)</span><span class="op">*</span><span class="fl">10</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#利用r2cv函数，将img.arr转变为OpenCV的图像矩阵</span></span>
<span><span class="va">img1</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img1</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t2，作为计时结束点</span></span>
<span><span class="va">t2</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#打印出从t1到t2所经历的时间(单位：秒)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html">sprintf</a></span><span class="op">(</span><span class="st">"Times passed in seconds: %f"</span>,<span class="op">(</span><span class="va">t2</span><span class="op">-</span><span class="va">t1</span><span class="op">)</span><span class="op">/</span><span class="fu">cv_getTickFrequency</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "Times passed in seconds: 0.530430"</code></pre>
<p>而在使用查询表时所消耗的时间：</p>
<div class="sourceCode" id="cb738"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成查询表lookuptbl</span></span>
<span><span class="va">lookuptbl</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">24</span>,each<span class="op">=</span><span class="fl">10</span><span class="op">)</span><span class="op">*</span><span class="fl">10</span>,<span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">250</span>,<span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t1，作为计时开始点</span></span>
<span><span class="va">t1</span><span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#加载图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/baboon.jpg"</span><span class="op">)</span></span>
<span><span class="co">#用cv2r函数将img转变为R语言的数组</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img_arr包含的3个矩阵的每个元素通过查询表压缩颜色空间</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">img_arr</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span>,<span class="op">]</span> <span class="op">=</span> <span class="va">lookuptbl</span><span class="op">[</span><span class="va">img_arr</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span>,<span class="op">]</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="co">#这里加1，是因为颜色值是以0开始的</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#利用r2cv函数，将img.arr转变为OpenCV的图像矩阵</span></span>
<span><span class="va">img1</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img1</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t2，作为计时结束点</span></span>
<span><span class="va">t2</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#打印出从t1到t2所经历的时间(单位：秒)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html">sprintf</a></span><span class="op">(</span><span class="st">"Times passed in seconds: %f"</span>,<span class="op">(</span><span class="va">t2</span><span class="op">-</span><span class="va">t1</span><span class="op">)</span><span class="op">/</span><span class="fu">cv_getTickFrequency</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "Times passed in seconds: 0.507315"</code></pre>
<p>可以看到，单独使用查询表方式，较之于直接使用乘除运算方式而言，时间消耗并没有优势。若在基于查询表的基础之上，再结合向量运算时（R语言的向量运算很强），时间消耗会大大减少：</p>
<div class="sourceCode" id="cb740"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成查询表lookuptbl</span></span>
<span><span class="va">lookuptbl</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">24</span>,each<span class="op">=</span><span class="fl">10</span><span class="op">)</span><span class="op">*</span><span class="fl">10</span>,<span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">250</span>,<span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t1，作为计时开始点</span></span>
<span><span class="va">t1</span><span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#加载图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/baboon.jpg"</span><span class="op">)</span></span>
<span><span class="co">#用cv2r函数将img转变为R语言的数组</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img_arr包含的3个矩阵的每个元素通过查询表和数组操作压缩颜色空间</span></span>
<span><span class="va">img_arr</span><span class="op">[</span>,,<span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/array.html">array</a></span><span class="op">(</span><span class="va">lookuptbl</span><span class="op">[</span><span class="va">img_arr</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span>,dim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用r2cv函数，将img.arr转变为OpenCV的图像矩阵</span></span>
<span><span class="va">img1</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img1</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_arr</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t2，作为计时结束点</span></span>
<span><span class="va">t2</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#打印出从t1到t2所经历的时间(单位：秒)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html">sprintf</a></span><span class="op">(</span><span class="st">"Times passed in seconds: %f"</span>,<span class="op">(</span><span class="va">t2</span><span class="op">-</span><span class="va">t1</span><span class="op">)</span><span class="op">/</span><span class="fu">cv_getTickFrequency</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "Times passed in seconds: 0.218667"</code></pre>
<p>下图左边是狒狒原始图像，右边是颜色空间压缩结果：</p>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-12-1.png" width="672"></div>
</div>
<div id="扩展图像边缘" class="section level2" number="5.4">
<h2>
<span class="header-section-number">5.4</span> 扩展图像边缘<a class="anchor" aria-label="anchor" href="#%E6%89%A9%E5%B1%95%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98"><i class="fas fa-link"></i></a>
</h2>
<p>可以使用copyMakeBorder函数扩展图像边缘，形成一些边框效果。</p>
<div id="border_replicate方式" class="section level3" number="5.4.1">
<h3>
<span class="header-section-number">5.4.1</span> BORDER_REPLICATE方式<a class="anchor" aria-label="anchor" href="#border_replicate%E6%96%B9%E5%BC%8F"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb742"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#通过r2cv函数将img_mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat_zeros</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">3</span></span>
<span><span class="co">#扩展图像边缘，扩展结果存入img.borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_REPLICATE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过cv2r函数，获得img_borderadded的像素值</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/BORDER_REPLICATE.png" width="119" style="display: block; margin: auto;"></div>
<div class="sourceCode" id="cb743"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读入图像，存放在img变量中</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span><span class="co"># 获取图像img的基本信息（含高度、宽度尺寸）</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">50</span></span>
<span><span class="co"># 扩展图像边缘，扩展结果存入img.borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_REPLICATE</span><span class="op">)</span></span>
<span><span class="co">#绘制蓝色矩形框，框外部分就是扩展的边缘</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span></span>
<span>  <span class="va">img_borderadded</span>,</span>
<span>  <span class="fu">Rect</span><span class="op">(</span><span class="fl">51</span>,<span class="fl">51</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">width</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span>,</span>
<span>  <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"ori"</span>,<span class="va">img</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"BORDER_REPLICATE"</span>,<span class="va">img_borderadded</span><span class="op">)</span></span></code></pre></div>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-16-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-16-2.png" width="672"></p>
</div>
<div id="border_reflect方式" class="section level3" number="5.4.2">
<h3>
<span class="header-section-number">5.4.2</span> BORDER_REFLECT方式<a class="anchor" aria-label="anchor" href="#border_reflect%E6%96%B9%E5%BC%8F"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb744"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#通过r2cv函数将img_mat转变为opencv图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">5</span></span>
<span><span class="co">#扩展图像边缘，扩展结果存入img_borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_REFLECT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过cv2r函数，获得img.borderadded的像素值</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/BORDER_REFLECT.png" width="167" style="display: block; margin: auto;"></div>
<div class="sourceCode" id="cb745"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读入图像，存放在img变量中</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/chicky_512.png"</span><span class="op">)</span></span>
<span><span class="co">#获取图像img的基本信息（含高度、宽度尺寸）</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">50</span></span>
<span><span class="co"># 扩展图像边缘，扩展结果存入img_borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_REFLECT</span><span class="op">)</span></span>
<span><span class="co">#绘制蓝色矩形框，框外部分就是扩展的边缘</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span></span>
<span>  <span class="va">img_borderadded</span>,</span>
<span>  <span class="fu">Rect</span><span class="op">(</span><span class="fl">51</span>,<span class="fl">51</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">width</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span>,</span>
<span>  <span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span>,<span class="fl">255</span>,<span class="fl">255</span><span class="op">)</span>,<span class="fl">2</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"ori"</span>,<span class="va">img</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"BORDER_REFLECT"</span>,<span class="va">img_borderadded</span><span class="op">)</span></span></code></pre></div>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-20-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-20-2.png" width="672"></p>
</div>
<div id="border_wrap方式" class="section level3" number="5.4.3">
<h3>
<span class="header-section-number">5.4.3</span> BORDER_WRAP方式<a class="anchor" aria-label="anchor" href="#border_wrap%E6%96%B9%E5%BC%8F"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb746"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#通过r2cv函数将img_mat转变为opencv图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">5</span></span>
<span><span class="co">#扩展图像边缘，扩展结果存入img.borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_WRAP</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过cv2r函数，获得img_borderadded的像素值</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/BORDER_WRAP.png" width="167" style="display: block; margin: auto;"></div>
<div class="sourceCode" id="cb747"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读入图像，存放在img变量中</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/baboon.jpg"</span><span class="op">)</span></span>
<span><span class="co"># 获取图像img的基本信息（含高度、宽度尺寸）</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">50</span></span>
<span><span class="co"># 扩展图像边缘，扩展结果存入img_borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_WRAP</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#绘制蓝色矩形框，框外部分就是扩展的边缘</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span></span>
<span>  <span class="va">img_borderadded</span>,</span>
<span>  <span class="fu">Rect</span><span class="op">(</span><span class="fl">51</span>,<span class="fl">51</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">width</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span>,</span>
<span>  <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span></span>
<span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"ori"</span>,<span class="va">img</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"BORDER_WRAP"</span>,<span class="va">img_borderadded</span><span class="op">)</span></span></code></pre></div>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-24-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-24-2.png" width="672"></p>
</div>
<div id="border_constant方式" class="section level3" number="5.4.4">
<h3>
<span class="header-section-number">5.4.4</span> BORDER_CONSTANT方式<a class="anchor" aria-label="anchor" href="#border_constant%E6%96%B9%E5%BC%8F"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb748"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#通过r2cv函数将img_mat转变为opencv图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="co"># 设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">3</span></span>
<span><span class="co"># 扩展图像边缘(扩充像素的颜色为0)，扩展结果存入img_borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_CONSTANT</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过cv2r函数，获得img_borderadded的像素值</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/BORDER_CONSTANT.png" width="119" style="display: block; margin: auto;"></div>
<div class="sourceCode" id="cb749"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 读入图像，存放在img变量中</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/cat.jpg"</span><span class="op">)</span></span>
<span><span class="co"># 获取图像img的基本信息（含高度、宽度尺寸）</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">50</span></span>
<span><span class="co"># 扩展图像边缘，扩展结果存入img_borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_CONSTANT</span>,<span class="fu">Scalar</span><span class="op">(</span><span class="fl">128</span>,<span class="fl">128</span>,<span class="fl">128</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#绘制蓝色矩形框，框外部分就是扩展的边缘</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span></span>
<span>  <span class="va">img_borderadded</span>,</span>
<span>  <span class="fu">Rect</span><span class="op">(</span><span class="fl">51</span>,<span class="fl">51</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">width</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span>,</span>
<span>  <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"ori"</span>,<span class="va">img</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"BORDER_CONSTANT"</span>,<span class="va">img_borderadded</span><span class="op">)</span></span></code></pre></div>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-28-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-28-2.png" width="672"></p>
</div>
<div id="border_default或者border_reflect_101方式" class="section level3" number="5.4.5">
<h3>
<span class="header-section-number">5.4.5</span> BORDER_DEFAULT或者BORDER_REFLECT_101方式<a class="anchor" aria-label="anchor" href="#border_default%E6%88%96%E8%80%85border_reflect_101%E6%96%B9%E5%BC%8F"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb750"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的矩阵img_mat</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#通过r2cv函数将img_mat转变为opencv图像img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">5</span></span>
<span><span class="co"># 扩展图像边缘，扩展结果存入img_borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 通过cv2r函数，获得img_borderadded的像素值</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op">=</span> <span class="va">img_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_borderadded_mat</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu">knitr</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/BORDER_DEFAULT.png" width="167" style="display: block; margin: auto;"></div>
<div class="sourceCode" id="cb751"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 读入图像，存放在img变量中</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/HappyFish.jpg"</span><span class="op">)</span></span>
<span><span class="co"># 获取图像img的基本信息（含高度、宽度尺寸）</span></span>
<span><span class="va">img_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设定图像上、下、左、右四侧需要扩展的像素个数</span></span>
<span><span class="va">sz</span> <span class="op">=</span> <span class="fl">50</span></span>
<span><span class="co"># 扩展图像边缘，扩展结果存入img.borderadded</span></span>
<span><span class="va">img_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_borderadded</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">sz</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#绘制蓝色矩形框，框外部分就是扩展的边缘</span></span>
<span><span class="fu">cv_rectangle</span><span class="op">(</span></span>
<span>  <span class="va">img_borderadded</span>,</span>
<span>  <span class="fu">Rect</span><span class="op">(</span><span class="fl">51</span>,<span class="fl">51</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">width</span>,<span class="va">img_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span>,</span>
<span>  <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span></span>
<span><span class="op">)</span></span>
<span></span>
<span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"ori"</span>,<span class="va">img</span><span class="op">)</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"BORDER_DEFAULT"</span>,<span class="va">img_borderadded</span><span class="op">)</span></span></code></pre></div>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-32-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-32-2.png" width="672"></p>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb752"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#指定边缘扩展方式</span></span>
<span><span class="va">borderType</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">BORDER_CONSTANT</span><span class="op">)</span></span>
<span><span class="co">#指定图形窗口的标题</span></span>
<span><span class="va">window_name</span> <span class="op">=</span> <span class="st">"copyMakeBorder Demo"</span></span>
<span></span>
<span><span class="co">#读取图像文件</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span><span class="co">#获取图像基本信息</span></span>
<span><span class="va">src_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">src</span><span class="op">)</span></span>
<span><span class="co">#生成图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#指定上、下、左、右需要扩展的像素个数</span></span>
<span><span class="va">top</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">0.1</span> <span class="op">*</span> <span class="va">src_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span></span>
<span><span class="va">bottom</span> <span class="op">=</span> <span class="va">top</span></span>
<span><span class="va">left</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fl">0.1</span> <span class="op">*</span> <span class="va">src_info</span><span class="op">$</span><span class="va">width</span><span class="op">)</span></span>
<span><span class="va">right</span> <span class="op">=</span> <span class="va">left</span></span>
<span></span>
<span><span class="co">#循环进行边缘扩展处理</span></span>
<span><span class="kw">while</span> <span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">{</span></span>
<span>  <span class="co">#生成随机颜色值，当边缘扩展方式为BORDER_CONSTANT时使用该值</span></span>
<span>  <span class="va">value</span> <span class="op">=</span> <span class="fu">Scalar</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">255</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">255</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">255</span><span class="op">)</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#扩展图像边缘，结果保存在dst中</span></span>
<span>  <span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">src</span>, <span class="va">dst</span>, <span class="va">top</span>, <span class="va">bottom</span>, <span class="va">left</span>, <span class="va">right</span>, <span class="va">borderType</span>, <span class="va">value</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#绘制蓝色矩形框，框外部分就是扩展的边缘</span></span>
<span>  <span class="fu">cv_rectangle</span><span class="op">(</span></span>
<span>    <span class="va">dst</span>,</span>
<span>    <span class="fu">Rect</span><span class="op">(</span><span class="va">left</span>,<span class="va">top</span>,<span class="va">src_info</span><span class="op">$</span><span class="va">width</span>,<span class="va">src_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span>,</span>
<span>    <span class="fu">Scalar</span><span class="op">(</span><span class="fl">255</span>,<span class="fl">0</span>,<span class="fl">0</span><span class="op">)</span>,<span class="fl">2</span></span>
<span>  <span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#再图形窗口中显示边缘扩展结果</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="va">window_name</span>, <span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="co">#等待500毫秒，以便接受用户键盘输入</span></span>
<span>  <span class="va">cc</span> <span class="op">=</span> <span class="fu">cv_waitKey</span><span class="op">(</span><span class="fl">500</span><span class="op">)</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">cc</span> <span class="op">==</span> <span class="fl">27</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#当用户按下esc键时，退出循环</span></span>
<span>    <span class="kw">break</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">cc</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'c'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#当用户按下c键时，则边缘扩展方式为BORDER_CONSTANT</span></span>
<span>    <span class="va">borderType</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">BORDER_CONSTANT</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">cc</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'r'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#当用户按下r键时，则边缘扩展方式为BORDER_REPLICATE</span></span>
<span>    <span class="va">borderType</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">BORDER_REPLICATE</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">cc</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'e'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#当用户按下e键时，则边缘扩展方式为BORDER_REFLECT</span></span>
<span>    <span class="va">borderType</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">BORDER_REFLECT</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">cc</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'w'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#当用户按下w键时，则边缘扩展方式为BORDER_WRAP</span></span>
<span>    <span class="va">borderType</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">BORDER_WRAP</span><span class="op">)</span></span>
<span>  <span class="op">}</span><span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">cc</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/rawConversion.html">charToRaw</a></span><span class="op">(</span><span class="st">'d'</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="co">#当用户按下d键时，则边缘扩展方式为BORDER_DEFAULT</span></span>
<span>    <span class="va">borderType</span> <span class="op">=</span> <span class="fu"><a href="https://rlang.r-lib.org/reference/expr.html">expr</a></span><span class="op">(</span><span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<div class="inline-figure"><img src="images/copyMakerBorderDemo.png" width="384" style="display: block; margin: auto;"></div>
</div>
</div>
<div id="图像矩阵标准化归一化" class="section level2" number="5.5">
<h2>
<span class="header-section-number">5.5</span> 图像矩阵标准化/归一化<a class="anchor" aria-label="anchor" href="#%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E6%A0%87%E5%87%86%E5%8C%96%E5%BD%92%E4%B8%80%E5%8C%96"><i class="fas fa-link"></i></a>
</h2>
<p>图像矩阵标准化/归一化指的是通过一定方式将图像矩阵的像素值放缩到指定的区间范围内，而常见的标准化方式有：</p>
<p><strong>最小最大值标准化</strong></p>
<p>所使用的公式为：</p>
<p><span class="math display">\[
I_1=\frac{I-min(I)}{max(I)-min(I)}
\]</span>
其中，<span class="math inline">\(min(I)\)</span>、<span class="math inline">\(max(I)\)</span>分别表示图像矩阵中<span class="math inline">\(I\)</span>的最小像素值和最大像素值。从公式可以推知，经最小最大值标准化之后，图像的像素值都被放缩到[0,1]区间上。</p>
<div class="sourceCode" id="cb753"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#依据公式定义最小最大值标准化函数scale_minmax</span></span>
<span><span class="va">scale_minmax</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="op">(</span><span class="va">I</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">12</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#应用scale_minmax函数</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu">scale_minmax</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#查看标准化结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,] 0.00 0.27 0.55 0.82
## [2,] 0.09 0.36 0.64 0.91
## [3,] 0.18 0.45 0.73 1.00</code></pre>
<p>利用OpenCV中的<strong>normalize</strong>函数，指定标准化类型为NOMR_MINMAX，可以实现图像矩阵的最小最大值标准化：</p>
<div class="sourceCode" id="cb755"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">12</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#利用r2cv函数将img_mat转变为图像矩阵</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">4</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行NORM_MINMAX标准化，返回的矩阵深度为32位浮点数（存储的是[0,1]区间上的值）</span></span>
<span><span class="va">img_norm</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_norm</span>,norm_type<span class="op">=</span><span class="va">NORM_MINMAX</span>,dtype<span class="op">=</span><span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="co">#查看标准化结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">img_norm</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,] 0.00 0.27 0.55 0.82
## [2,] 0.09 0.36 0.64 0.91
## [3,] 0.18 0.45 0.73 1.00
## attr(,"depth")
## [1] 5</code></pre>
<p><strong><span class="math inline">\(L_\infty\)</span>范数标准化</strong></p>
<p>所使用的公式为：</p>
<p><span class="math display">\[
I_1=\frac{I}{max \left | I \right |}
\]</span>
其中，<span class="math inline">\(=max \left | I \right |\)</span>表示对图像矩阵的像素值取绝对值后再取最大值。从公式可以推知，经最小最大值标准化之后，图像的像素值都被放缩到[-1,1]区间上。</p>
<div class="sourceCode" id="cb757"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#依据公式定义最小最大值标准化函数scale_inf</span></span>
<span><span class="va">scale_inf</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">I</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">12</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#应用scale_inf函数</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu">scale_inf</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#查看标准化结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,] 0.08 0.33 0.58 0.83
## [2,] 0.17 0.42 0.67 0.92
## [3,] 0.25 0.50 0.75 1.00</code></pre>
<p>利用OpenCV中的<strong>normalize</strong>函数，指定标准化类型为NOMR_INF，可以实现图像矩阵的<span class="math inline">\(L_\infty\)</span>范数标准化：</p>
<div class="sourceCode" id="cb759"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">12</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#利用r2cv函数将img_mat转变为图像矩阵</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">4</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行NORM_INF标准化，返回的矩阵深度为32位浮点数（因为存储的是[-1,1]区间上的值）</span></span>
<span><span class="va">img_norm</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_norm</span>,norm_type <span class="op">=</span> <span class="va">NORM_INF</span>,dtype <span class="op">=</span> <span class="va">CV_32F</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看标准化结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">img_norm</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,] 0.08 0.33 0.58 0.83
## [2,] 0.17 0.42 0.67 0.92
## [3,] 0.25 0.50 0.75 1.00
## attr(,"depth")
## [1] 5</code></pre>
<p><strong><span class="math inline">\(L_1\)</span>范数标准化</strong></p>
<p>所使用的公式为：</p>
<p><span class="math display">\[
I_1=\frac{I}{sum \left | I \right |}
\]</span>
其中，<span class="math inline">\(sum \left | I \right |\)</span>表示对图像矩阵的像素值取绝对值后再求和。从公式可以推知，经最小最大值标准化之后，图像的像素值都被放缩到[-1,1]区间上。</p>
<div class="sourceCode" id="cb761"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#依据公式定义最小最大值标准化函数scale_L1</span></span>
<span><span class="va">scale_L1</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">I</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="op">-</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#应用scale_L1函数</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu">scale_L1</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#查看标准化结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##       [,1]  [,2] [,3] [,4]
## [1,] -0.14 -0.06 0.03 0.11
## [2,] -0.11 -0.03 0.06 0.14
## [3,] -0.08  0.00 0.08 0.17</code></pre>
<p>利用OpenCV中的<strong>normalize</strong>函数，指定标准化类型为NOMR_L1，可以实现图像矩阵的<span class="math inline">\(L_1\)</span>范数标准化：</p>
<div class="sourceCode" id="cb763"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="op">-</span><span class="fl">5</span><span class="op">:</span><span class="fl">6</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#利用r2cv函数将img.mat转变为图像矩阵</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">4</span>,<span class="va">CV_8SC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行NORM_L1标准化，返回的矩阵深度为32位浮点数（因为存储的是[-1,1]区间上的值）</span></span>
<span><span class="va">img_norm</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_norm</span>,norm_type <span class="op">=</span> <span class="va">NORM_L1</span>,dtype <span class="op">=</span> <span class="va">CV_32F</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看标准化结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">img_norm</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##       [,1]  [,2] [,3] [,4]
## [1,] -0.14 -0.06 0.03 0.11
## [2,] -0.11 -0.03 0.06 0.14
## [3,] -0.08  0.00 0.08 0.17
## attr(,"depth")
## [1] 5</code></pre>
<p><strong><span class="math inline">\(L_2\)</span>范数标准化</strong></p>
<p>所使用的公式为：</p>
<p><span class="math display">\[
I_1=\frac{I}{\sqrt {sum (I^2)}}
\]</span>
其中，<span class="math inline">\(\sqrt {sum (I^2)}\)</span>表示对图像矩阵的像素值进行平方运算、而后求和、最后求算数平方根。</p>
<div class="sourceCode" id="cb765"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#依据公式定义最小最大值标准化函数scale_L2</span></span>
<span><span class="va">scale_L2</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">I</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">I</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">I</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">12</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#应用scale_L2函数</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu">scale_L2</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#查看标准化结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,] 0.04 0.16 0.27 0.39
## [2,] 0.08 0.20 0.31 0.43
## [3,] 0.12 0.24 0.35 0.47</code></pre>
<p>利用OpenCV中的<strong>normalize</strong>函数，指定标准化类型为NOMR_L2，可以实现图像矩阵的<span class="math inline">\(L_2\)</span>范数标准化：</p>
<div class="sourceCode" id="cb767"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">12</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">4</span><span class="op">)</span></span>
<span><span class="co">#利用r2cv函数将img.mat转变为图像矩阵</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">4</span>,<span class="va">CV_8SC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行NORM_L2标准化，由于需要存储小数，所以返回的矩阵深度</span></span>
<span><span class="co">#为32位浮点数</span></span>
<span><span class="va">img_norm</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_norm</span>,norm_type<span class="op">=</span><span class="va">NORM_L2</span>,dtype <span class="op">=</span><span class="va">CV_32F</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看标准化结果</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">img_norm</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,] 0.04 0.16 0.27 0.39
## [2,] 0.08 0.20 0.31 0.43
## [3,] 0.12 0.24 0.35 0.47
## attr(,"depth")
## [1] 5</code></pre>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb769"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件，获得图像矩阵img_8u</span></span>
<span><span class="va">img_8u</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用图像矩阵的convertTo方法，将img_8u的深度转变为32位浮点数，</span></span>
<span><span class="co">#结果保存在img.32f中</span></span>
<span><span class="va">img_32f</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_8u</span><span class="op">$</span><span class="fu">convertTo</span><span class="op">(</span><span class="va">img_32f</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示img.32f，显示存在问题：全是白色</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"32f"</span>,<span class="va">img_32f</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用最小最大值标准化方法，将img_32f标准化，标准化结果保存在</span></span>
<span><span class="co">#img_32f_norm中</span></span>
<span><span class="va">img_32f_norm</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_normalize</span><span class="op">(</span><span class="va">img_32f</span>,<span class="va">img_32f_norm</span>,norm_type<span class="op">=</span><span class="va">NORM_MINMAX</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示img_32f_norm</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'32f'</span>,<span class="va">img_32f_norm</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="图像矩阵的按位运算" class="section level2" number="5.6">
<h2>
<span class="header-section-number">5.6</span> 图像矩阵的按位运算<a class="anchor" aria-label="anchor" href="#%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97"><i class="fas fa-link"></i></a>
</h2>
<p>二进制数按位运算包括：</p>
<ul>
<li>按位与（&amp;）：1&amp;1=1，1&amp;0=0，0&amp;1=0，0&amp;0=0</li>
<li>按位或（|）：1|1=1，1|0=1，0|1=1，0|0=0</li>
<li>按位异或（<sup>）：1</sup>1=0，1<sup>0=1，0</sup>1=1，0^0=0</li>
<li>按位求反（<sub>）：</sub>1=0，~0=1</li>
</ul>
<p>图像矩阵的按位运算有四个函数：</p>
<ul>
<li>按位与函数：bitwise_and</li>
<li>按位或函数：bitwise_or</li>
<li>按位异或函数：bitwise_xor</li>
<li>按位取反函数：bitwise_not</li>
</ul>
<p>这四个函数的大致计算过程是：先将图像矩阵的十进制像素值转变为二进制数，而后再依据二进制数相应法则计算，再把计算结果转变为十进制数返回。</p>
<div class="sourceCode" id="cb770"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成矩阵img1.mat,img2.mat</span></span>
<span><span class="va">img1_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">2</span>,nc<span class="op">=</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="va">img2_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">10</span><span class="op">:</span><span class="fl">19</span>,nr<span class="op">=</span><span class="fl">2</span>,nc<span class="op">=</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="co">#将img1_mat和img2_mat转变为图像矩阵img1和img2</span></span>
<span><span class="va">img1</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">2</span>,<span class="fl">5</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img1_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img1</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img1</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img1_mat</span><span class="op">)</span></span>
<span><span class="va">img2</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">2</span>,<span class="fl">5</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img2_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img2</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img2</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img2_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img1和img2进行按位与、按位或、按位异或运算，</span></span>
<span><span class="co">#结果分别保存在img.and,img.or和img.xor中</span></span>
<span><span class="va">img_and</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_and</span><span class="op">(</span><span class="va">img1</span>,<span class="va">img2</span>,<span class="va">img_and</span><span class="op">)</span></span>
<span><span class="va">img_or</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_or</span><span class="op">(</span><span class="va">img1</span>,<span class="va">img2</span>,<span class="va">img_or</span><span class="op">)</span></span>
<span><span class="va">img_xor</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_xor</span><span class="op">(</span><span class="va">img1</span>,<span class="va">img2</span>,<span class="va">img_xor</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看结果按位与结果</span></span>
<span><span class="va">img_and</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0    0    4    0    0
## [2,]    1    1    5    1    1
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb772"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看结果按位或结果</span></span>
<span><span class="va">img_or</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]   10   14   14   22   26
## [2,]   11   15   15   23   27
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb774"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#查看结果按位异或结果</span></span>
<span><span class="va">img_xor</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]   10   14   10   22   26
## [2,]   10   14   10   22   26
## attr(,"depth")
## [1] 0</code></pre>
<div class="sourceCode" id="cb776"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#对img1进行按位取反运算，结果保存在img_not中</span></span>
<span><span class="va">img_not</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_not</span><span class="op">(</span><span class="va">img1</span>,<span class="va">img_not</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看按位取反结果</span></span>
<span><span class="va">img_not</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]  255  253  251  249  247
## [2,]  254  252  250  248  246
## attr(,"depth")
## [1] 0</code></pre>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb778"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/LinuxLogo.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img进行按位取反，结果保存在img_not中</span></span>
<span><span class="va">img_not</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_not</span><span class="op">(</span><span class="va">img</span>,<span class="va">img_not</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#显示结果</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"按位取反结果"</span>,<span class="va">img_not</span><span class="op">)</span></span></code></pre></div>
<p>从操作结果可以看出：按位取反操作会让图像的白色区域变为黑色区域，而黑色区域则变为白色区域。</p>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-47-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>对如下两个图像进行按位与、按位或和按位异或运算：</p>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-48-1.png" width="672"></div>
<div class="sourceCode" id="cb779"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img1</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/LinuxLogo.jpg"</span><span class="op">)</span></span>
<span><span class="va">img2</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/WindowsLogo.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#对img1和img2进行按位与、按位或以及按位异或运算，</span></span>
<span><span class="co">#结果保存在img.and,img.or和img.xor中</span></span>
<span><span class="va">img_and</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_and</span><span class="op">(</span><span class="va">img1</span>,<span class="va">img2</span>,<span class="va">img_and</span><span class="op">)</span></span>
<span><span class="va">img_or</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_or</span><span class="op">(</span><span class="va">img1</span>,<span class="va">img2</span>,<span class="va">img_or</span><span class="op">)</span></span>
<span><span class="va">img_xor</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_bitwise_xor</span><span class="op">(</span><span class="va">img1</span>,<span class="va">img2</span>,<span class="va">img_xor</span><span class="op">)</span></span></code></pre></div>
<p>运算结果如下：</p>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-50-1.png" width="672"></div>
</div>
<div id="图像矩阵的掩码运算" class="section level2" number="5.7">
<h2>
<span class="header-section-number">5.7</span> 图像矩阵的掩码运算<a class="anchor" aria-label="anchor" href="#%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A9%E7%A0%81%E8%BF%90%E7%AE%97"><i class="fas fa-link"></i></a>
</h2>
<p>考虑如下公式：</p>
<p><span class="math display">\[
I_1(i,j)=5 \times I(i,j)-\left[ I(i-1,j)+I(i+1,j)+I(i,j-1)+I(i,j+1) \right]
\]</span></p>
<p>其中：<br><span class="math inline">\(I(i,j)\)</span>表示图像<span class="math inline">\(I\)</span>第<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列像素值；<br><span class="math inline">\(I(i-1,j)\)</span>表示图像<span class="math inline">\(I\)</span>第<span class="math inline">\(i-1\)</span>行<span class="math inline">\(j\)</span>列像素值；<br><span class="math inline">\(I(i+1,j)\)</span>表示图像<span class="math inline">\(I\)</span>第<span class="math inline">\(i+1\)</span>行<span class="math inline">\(j\)</span>列像素值；<br><span class="math inline">\(I(i,j-1)\)</span>表示图像<span class="math inline">\(I\)</span>第<span class="math inline">\(i\)</span>行<span class="math inline">\(j-1\)</span>列像素值；<br><span class="math inline">\(I(i,j+1)\)</span>表示图像<span class="math inline">\(I\)</span>第<span class="math inline">\(i\)</span>行<span class="math inline">\(j+1\)</span>列像素值；<br><span class="math inline">\(I_1(i,j)\)</span>表示图像<span class="math inline">\(I_1\)</span>第<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列像素值。</p>
<p>公式表示的意义是：图像<span class="math inline">\(I_1\)</span>的第<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列像素值等于图像<span class="math inline">\(I\)</span>的第<span class="math inline">\(i\)</span>行<span class="math inline">\(j\)</span>列像素值放大5倍再减去其紧邻的上、下、左、右四个像素值之和。由于第1行和最后1行，以及第1列和最后1列的像素处于图像边缘，其紧邻的像素中不能同时出现上、下、左、右四个像素。所以，在使用以上公式时通常会先扩展图像边缘，而后再计算，等计算结束后再舍掉扩展的边缘。</p>
<p>以下代码演示了该公式的使用情形：</p>
<div class="sourceCode" id="cb780"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#加载图像文件(按灰度图模式读入)</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#通过BORDER_DEFAULT方式扩展边缘</span></span>
<span><span class="va">src_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">src</span>,<span class="va">src_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数，将src转变为R语言的矩阵</span></span>
<span><span class="va">src_mat</span> <span class="op">=</span> <span class="va">src_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t1，作为计时开始点</span></span>
<span><span class="va">t1</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#直接将src_mat赋值给dst_mat</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">src_mat</span></span>
<span><span class="co">#利用上面的公式，通过src_mat计算dst_mat各个元素的值。</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">src_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">src_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">newv</span> <span class="op">=</span> <span class="fl">5</span><span class="op">*</span><span class="va">src_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span><span class="op">-</span></span>
<span>      <span class="op">(</span><span class="va">src_mat</span><span class="op">[</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span>,<span class="va">j</span><span class="op">]</span><span class="op">+</span><span class="va">src_mat</span><span class="op">[</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span>,<span class="va">j</span><span class="op">]</span><span class="op">+</span><span class="va">src_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">-</span><span class="fl">1</span><span class="op">]</span><span class="op">+</span><span class="va">src_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span>    <span class="va">dst_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">newv</span><span class="op">&lt;</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">newv</span><span class="op">&gt;</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="va">newv</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#去除dst.mat的第1行和最后1行，以及第1列和最后1列(即去除扩展的边缘)</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">dst_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">dst_mat</span><span class="op">)</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">dst_mat</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#利用r2cv函数，将dst.mat转变为图像矩阵dst</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="va">src</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">dst_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">dst</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">dst</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">dst_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t2，作为计时结束点</span></span>
<span><span class="va">t2</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#打印出从t1到t2所经历的时间(单位：秒)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html">sprintf</a></span><span class="op">(</span><span class="st">"Times passed in seconds: %f"</span>,<span class="op">(</span><span class="va">t2</span><span class="op">-</span><span class="va">t1</span><span class="op">)</span><span class="op">/</span><span class="fu">cv_getTickFrequency</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "Times passed in seconds: 1.622346"</code></pre>
<p>可以看出，处理后的图像具有一种锐化效果（即图像边缘更清晰）</p>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-52-1.png" width="672"></div>
<p>可以将公式：</p>
<p><span class="math display">\[
I_1(i,j)=5 \times I(i,j)-\left[ I(i-1,j)+I(i+1,j)+I(i,j-1)+I(i,j+1) \right]
\]</span></p>
<p>转变为矩阵操作：</p>
<p><span class="math display">\[
I_1=5 \times I-\left[ I.top+I.bottom+I.left+I.right \right]
\]</span></p>
<p>由于R有很强的矩阵运算能力，所以将逐个元素的循环运算转变为矩阵运算后，可以提高处理效率：</p>
<div class="sourceCode" id="cb782"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#加载图像文件(按灰度图模式读入)</span></span>
<span><span class="va">I</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#通过BORDER_DEFAULT方式扩展边缘</span></span>
<span><span class="va">I_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">I</span>,<span class="va">I_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数，将I转变为R语言的矩阵I_mat</span></span>
<span><span class="va">I_mat</span> <span class="op">=</span> <span class="va">I_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t1，作为计时开始点</span></span>
<span><span class="va">t1</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">I_top_mat</span> <span class="op">=</span> <span class="va">I_mat</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">I_mat</span><span class="op">)</span>,<span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">I_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>,<span class="op">]</span></span>
<span><span class="va">I_bottom_mat</span> <span class="op">=</span> <span class="va">I_mat</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">I_mat</span><span class="op">)</span>,<span class="fl">1</span><span class="op">)</span>,<span class="op">]</span></span>
<span><span class="va">I_left_mat</span> <span class="op">=</span> <span class="va">I_mat</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">I_mat</span><span class="op">)</span>,<span class="fl">1</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">I_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">I_right_mat</span> <span class="op">=</span> <span class="va">I_mat</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">I_mat</span><span class="op">)</span>,<span class="fl">1</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="va">I1_mat</span> <span class="op">=</span> <span class="fl">5</span><span class="op">*</span><span class="va">I_mat</span> <span class="op">-</span></span>
<span>  <span class="op">(</span><span class="va">I_top_mat</span> <span class="op">+</span> <span class="va">I_bottom_mat</span> <span class="op">+</span> <span class="va">I_left_mat</span> <span class="op">+</span> <span class="va">I_right_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#去除I1_mat的第1行和最后1行，以及第1列和最后1列(即去除扩展的边缘)</span></span>
<span><span class="va">I1_mat</span> <span class="op">=</span> <span class="va">I1_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">I1_mat</span><span class="op">)</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">I1_mat</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#利用r2cv函数，将I1.mat转变为图像矩阵I1</span></span>
<span><span class="va">I1</span> <span class="op">=</span> <span class="va">I</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">I1_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">I1</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">I1</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">I1_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t2，作为计时结束点</span></span>
<span><span class="va">t2</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#打印出从t1到t2所经历的时间(单位：秒)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html">sprintf</a></span><span class="op">(</span><span class="st">"Times passed in seconds: %f"</span>,<span class="op">(</span><span class="va">t2</span><span class="op">-</span><span class="va">t1</span><span class="op">)</span><span class="op">/</span><span class="fu">cv_getTickFrequency</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "Times passed in seconds: 0.042288"</code></pre>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-54-1.png" width="672"></div>
<p>以上图像锐化过程，可以转变为图像矩阵上的掩码运算，这种操作的思想是以掩码矩阵（也称为内核）的值为权重对相应像素值进行加权求和。</p>
<p>令掩码矩阵（或者内核）为：
<span class="math display">\[
\begin{aligned}
M= \left[ \begin{matrix}0 &amp; -1 &amp; 0 \\ -1 &amp; 5 &amp; -1 \\ 0 &amp; -1 &amp; 0  \end{matrix} \right]
\end{aligned}
\]</span></p>
<p>OpenCV会为掩码矩阵指定一个锚点anchor，默认情况下是掩码矩阵的中心点。锚点在掩码矩阵中行、列位置分别称为锚点的纵坐标和横坐标。对于这里的掩码矩阵<span class="math inline">\(M\)</span>，在默认情况下，其锚点的横坐标<span class="math inline">\(anchor_x\)</span>为1，纵坐标<span class="math inline">\(anchor_y\)</span>也为1。</p>
<p>则有：
<span class="math display">\[
I_1(i,j) = \sum_{r=0} ^{2} \sum_{c=0}^{2} I(i-anchor_y+r,j-anchor_x+c) \times M(r,c)
\]</span></p>
<p>掩码运算的具体操作是：首先依据掩码矩阵尺寸以及锚点所在的位置，扩展图像边缘，而后在（边缘扩展后的）图像矩阵上，按行按列移动掩码矩阵，每次移动都让掩码矩阵的锚点对准（边缘扩展前的）图像矩阵的一个像素，并对掩码矩阵“掩盖住”的所有像素值与对应掩码矩阵位置的权值相乘并求和，如此遍历完所有像素（这里的所有像素，指的是边缘扩展前的图像矩阵的所有像素）。每次移动，锚点对准的像素称为目标像素，掩码矩阵“掩盖”住的像素都称为目标像素的领域像素，这些领域像素按原有位置形成的矩阵称为目标像素的领域像素矩阵，也可以称为掩码矩阵的目标区域，每次的掩码计算结果称为目标像素的掩码输出值。</p>
<p>上面的公式可以演变为如下情形：</p>
<p><span class="math display">\[
I_1(i,j) = I_{neighbour} \otimes M
\]</span></p>
<p>其中，<span class="math inline">\(I_{neighbour}\)</span>表示目标像素<span class="math inline">\((i,j)\)</span>的邻域像素矩阵。<span class="math inline">\(\otimes\)</span>符号表示两个矩阵对应元素相乘再求和，这种运算方式常称为卷积。</p>
<p>更进一步，可以使用如下公式表示图像矩阵的掩码运算：</p>
<p><span class="math display">\[
I_1 = I \otimes M
\]</span>
<strong>示例</strong></p>
<p>以下代码演示了如何通过掩码操作实现图像的锐化：</p>
<div class="sourceCode" id="cb784"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#加载图像文件(按灰度图模式读入)</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#通过BORDER_DEFAULT方式扩展边缘</span></span>
<span><span class="va">src_borderadded</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">src</span>,<span class="va">src_borderadded</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数，将src转变为R语言的矩阵</span></span>
<span><span class="va">src_mat</span> <span class="op">=</span> <span class="va">src_borderadded</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#设定掩码矩阵（内核）</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">0</span>, <span class="op">-</span><span class="fl">1</span>,<span class="fl">5</span>,<span class="op">-</span><span class="fl">1</span>, <span class="fl">0</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t1，作为计时开始点</span></span>
<span><span class="va">t1</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#直接将src_mat赋值给dst_mat</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">src_mat</span></span>
<span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">src_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">src_mat</span><span class="op">)</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">newv</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">src_mat</span><span class="op">[</span><span class="op">(</span><span class="va">i</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">i</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span>,<span class="op">(</span><span class="va">j</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="va">j</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">]</span> <span class="op">*</span> <span class="va">M</span><span class="op">)</span>  <span class="co">#这些操作一定要体现在R语言的矩阵操作中</span></span>
<span>    <span class="va">dst_mat</span><span class="op">[</span><span class="va">i</span>,<span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">newv</span><span class="op">&lt;</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">newv</span><span class="op">&gt;</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="va">newv</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#去除dst_mat的第1行和最后1行，以及第1列和最后1列(即去除扩展的边缘)</span></span>
<span><span class="va">dst_mat</span> <span class="op">=</span> <span class="va">dst_mat</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">dst_mat</span><span class="op">)</span><span class="op">)</span>,<span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">dst_mat</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#利用r2cv函数，将dst.mat转变为图像矩阵dst</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="va">src</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">dst_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">dst</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">dst</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">dst_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t2，作为计时结束点</span></span>
<span><span class="va">t2</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#打印出从t1到t2所经历的时间(单位：秒)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html">sprintf</a></span><span class="op">(</span><span class="st">"Times passed in seconds: %f"</span>,<span class="op">(</span><span class="va">t2</span><span class="op">-</span><span class="va">t1</span><span class="op">)</span><span class="op">/</span><span class="fu">cv_getTickFrequency</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "Times passed in seconds: 1.396443"</code></pre>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-56-1.png" width="672"></div>
<p>当直接使用cv_filter2D函数（下一章还会用到此函数）进行掩码操作时，可以获得更快的速度：</p>
<div class="sourceCode" id="cb786"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#加载图像文件(按灰度图模式读入)</span></span>
<span><span class="va">src</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span>,<span class="fl">0</span><span class="op">)</span></span>
<span><span class="co">#设定掩码矩阵（内核）</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="va">M_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">0</span>, <span class="op">-</span><span class="fl">1</span>,<span class="fl">5</span>,<span class="op">-</span><span class="fl">1</span>, <span class="fl">0</span>,<span class="op">-</span><span class="fl">1</span>,<span class="fl">0</span><span class="op">)</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span>,byrow <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">M_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">M</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">M</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">M_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t1，作为计时开始点</span></span>
<span><span class="va">t1</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用cv.filter2D函数</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_filter2D</span><span class="op">(</span><span class="va">src</span>,<span class="va">dst</span>,<span class="op">-</span><span class="fl">1</span>,<span class="va">M</span>,borderType <span class="op">=</span> <span class="va">BORDER_DEFAULT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取时间刻度t2，作为计时结束点</span></span>
<span><span class="va">t2</span> <span class="op">=</span> <span class="fu">cv_getTickCount</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#打印出从t1到t2所经历的时间(单位：秒)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sprintf.html">sprintf</a></span><span class="op">(</span><span class="st">"Times passed in seconds: %f"</span>,<span class="op">(</span><span class="va">t2</span><span class="op">-</span><span class="va">t1</span><span class="op">)</span><span class="op">/</span><span class="fu">cv_getTickFrequency</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "Times passed in seconds: 0.009103"</code></pre>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-58-1.png" width="672"></div>
</div>
<div id="融合两个图像" class="section level2" number="5.8">
<h2>
<span class="header-section-number">5.8</span> 融合两个图像<a class="anchor" aria-label="anchor" href="#%E8%9E%8D%E5%90%88%E4%B8%A4%E4%B8%AA%E5%9B%BE%E5%83%8F"><i class="fas fa-link"></i></a>
</h2>
<p>使用如下线性运算公式可以实现两个图像的融合：
<span class="math display">\[
g(i,j)=(1-\alpha)f_0(i,j)+\alpha f_1(i,j)
\]</span></p>
<p>其中：</p>
<p><span class="math inline">\(f_0(i,j)\)</span>和<span class="math inline">\(f_1(i,j)\)</span>表示图像<span class="math inline">\(f_0\)</span>和<span class="math inline">\(f_1\)</span>各自在第<span class="math inline">\(i\)</span>行、第<span class="math inline">\(j\)</span>列的像素值。<br><span class="math inline">\((1-\alpha)\)</span>和<span class="math inline">\(\alpha\)</span>为两个图像融合时各自的权重，当<span class="math inline">\(\alpha=0\)</span>时，融合结果其实就是<span class="math inline">\(f_0\)</span>，当当<span class="math inline">\(\alpha=1\)</span>时，融合结果其实就是<span class="math inline">\(f_1\)</span>。</p>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb788"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#设立两个图像的融合权重都为0.5</span></span>
<span><span class="va">alpha</span> <span class="op">=</span> <span class="fl">0.5</span></span>
<span></span>
<span><span class="co">#读取两个图像文件</span></span>
<span><span class="va">src1</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/trans1.jpg"</span><span class="op">)</span></span>
<span><span class="va">src1_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">src1</span><span class="op">)</span></span>
<span><span class="va">src2</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/trans2.jpg"</span><span class="op">)</span></span>
<span><span class="va">src2_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">src2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过resize函数确保两个图像数据的尺寸一致</span></span>
<span><span class="fu">cv_resize</span><span class="op">(</span><span class="va">src2</span>,<span class="va">src2</span>,<span class="fu">Size</span><span class="op">(</span><span class="va">src1_info</span><span class="op">$</span><span class="va">height</span>,<span class="va">src1_info</span><span class="op">$</span><span class="va">width</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">src2</span><span class="op">)</span></span></code></pre></div>
<pre><code>## $width
## [1] 434
## 
## $height
## [1] 434
## 
## $channels
## [1] 3
## 
## $depth
## [1] 0
## 
## $type
## [1] 64</code></pre>
<div class="sourceCode" id="cb790"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用addWeighted函数融合src1和src2</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_addWeighted</span><span class="op">(</span><span class="va">src1</span>,<span class="fl">1</span><span class="op">-</span><span class="va">alpha</span>,<span class="va">src2</span>,<span class="va">alpha</span>,<span class="fl">0.0</span>,<span class="va">dst</span><span class="op">)</span></span></code></pre></div>
<p>融合前后的图像：</p>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-60-1.png" width="672"></div>
<p>通过<span class="math inline">\(\alpha\)</span>从0变化到1，则两个图像的融合过程可以形成一种动态渐变效果。</p>
<div class="sourceCode" id="cb791"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取两个图像文件</span></span>
<span><span class="va">src1</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/LinuxLogo.jpg"</span><span class="op">)</span></span>
<span><span class="va">src2</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/WindowsLogo.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#生成标题为display的图形窗口</span></span>
<span><span class="fu">cv_namedWindow</span><span class="op">(</span><span class="st">"display"</span>,<span class="va">WINDOW_AUTOSIZE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#通过循环方式控制图像融合权重变化，形成动态渐变效果</span></span>
<span><span class="va">dst</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">alpha</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span>,length<span class="op">=</span><span class="fl">100</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#使用addWeighted函数融合src1和src2，得到dst</span></span>
<span>  <span class="fu">cv_addWeighted</span><span class="op">(</span><span class="va">src1</span>,<span class="fl">1</span><span class="op">-</span><span class="va">alpha</span>,<span class="va">src2</span>,<span class="va">alpha</span>,<span class="fl">0.0</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="co">#将dst显示到display图形窗口上</span></span>
<span>  <span class="fu">cv_imshow</span><span class="op">(</span><span class="st">"display"</span>,<span class="va">dst</span><span class="op">)</span></span>
<span>  <span class="co">#暂停0.1秒</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Sys.sleep.html">Sys.sleep</a></span><span class="op">(</span><span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
</div>
<div id="改变图像的对比度和亮度" class="section level2" number="5.9">
<h2>
<span class="header-section-number">5.9</span> 改变图像的对比度和亮度<a class="anchor" aria-label="anchor" href="#%E6%94%B9%E5%8F%98%E5%9B%BE%E5%83%8F%E7%9A%84%E5%AF%B9%E6%AF%94%E5%BA%A6%E5%92%8C%E4%BA%AE%E5%BA%A6"><i class="fas fa-link"></i></a>
</h2>
<div id="采用线性运算方式" class="section level3" number="5.9.1">
<h3>
<span class="header-section-number">5.9.1</span> 采用线性运算方式<a class="anchor" aria-label="anchor" href="#%E9%87%87%E7%94%A8%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97%E6%96%B9%E5%BC%8F"><i class="fas fa-link"></i></a>
</h3>
<p>使用以下公式可以实现图像对比度和亮度控制：</p>
<p><span class="math display">\[
g = \alpha f+\beta
\]</span>
其中：</p>
<p><span class="math inline">\(f\)</span>表示原始图像，<span class="math inline">\(g\)</span>表示线性运算后得到的图像。</p>
<p><span class="math inline">\(\alpha\)</span>（<span class="math inline">\(\alpha&gt;0\)</span>）和<span class="math inline">\(\beta\)</span>通常称为增益和偏置参数，可以用来分别控制对比度和亮度。</p>
<p><span class="math inline">\(\beta&gt;0\)</span>参数会改变图像的亮度。当<span class="math inline">\(\beta&gt;0\)</span>，会将图像的直方图右移，进而增加图像的亮度；而当<span class="math inline">\(\beta&lt;0\)</span>，会将图像的直方图左移，进而降低图像的亮度。</p>
<p><span class="math inline">\(\alpha\)</span>参数会改变图像颜色值的分布方式。当<span class="math inline">\(\alpha&lt;1\)</span>，会将图像的直方图压缩，进而降低图像的对比度；当<span class="math inline">\(\alpha&gt;1\)</span>，会将图像的直方图扩展，进而提升图像的对比度。</p>
<div class="sourceCode" id="cb792"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数，将img转变为R语言中的数组</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#设置对比度控制参数（或者增益参数）</span></span>
<span><span class="va">alpha</span> <span class="op">=</span> <span class="fl">2.2</span></span>
<span><span class="co">#设置亮度控制参数（或者偏置参数）</span></span>
<span><span class="va">beta</span> <span class="op">=</span> <span class="fl">50</span></span>
<span><span class="co">#按照公式生成数组dst_arr</span></span>
<span><span class="va">dst_arr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">alpha</span><span class="op">*</span><span class="va">img_arr</span> <span class="op">+</span> <span class="va">beta</span><span class="op">)</span></span>
<span><span class="co">#截断</span></span>
<span><span class="va">dst_arr</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">dst_arr</span><span class="op">&lt;</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fu"><a href="https://rdrr.io/r/base/ifelse.html">ifelse</a></span><span class="op">(</span><span class="va">dst_arr</span><span class="op">&gt;</span><span class="fl">255</span>,<span class="fl">255</span>,<span class="va">dst_arr</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#利用r2cv函数将dst_arr转变为图像矩阵new_img</span></span>
<span><span class="va">new_img</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">dst_arr</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">new_img</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">new_img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">dst_arr</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-63-1.png" width="672"></div>
<p>由于<span class="math inline">\(\alpha f + \beta\)</span>的计算结果可能给出”CV_8U”类型的取值范围或不是整数，所以需要采用如下方式来确保值是有效的（等同于cv::saturate_cast）。</p>
<pre><code>ifelse(dst.arr&lt;0,0,ifelse(dst.arr&gt;255,255,dst.arr))</code></pre>
<p>可以直接使用opencv中的convertTo函数实现同样的效果</p>
<div class="sourceCode" id="cb794"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/lena.jpg"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#使用图像矩阵类的converTo函数，得到图像矩阵new_img</span></span>
<span><span class="va">new_img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">convertTo</span><span class="op">(</span><span class="va">new_img</span>,<span class="op">-</span><span class="fl">1</span>,<span class="va">alpha</span>,<span class="va">beta</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-65-1.png" width="672"></div>
<p><strong>示例</strong></p>
<p>以下代码将一个曝光不足的图像（即图像偏暗）的亮度增加50：</p>
<div class="sourceCode" id="cb795"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">'images/flower_lessdose.jpg'</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数将img转变为R语言的数组img_arr</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#img_arr的每个元素值都加上50，得到img_new_arr</span></span>
<span><span class="va">img_new_arr</span> <span class="op">=</span> <span class="va">img_arr</span><span class="op">+</span><span class="fl">50</span></span>
<span><span class="co">#img.new.arr中元素值小于0的取0，大于255的取255</span></span>
<span><span class="va">img_new_arr</span><span class="op">[</span><span class="va">img_new_arr</span><span class="op">&lt;</span><span class="fl">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="va">img_new_arr</span><span class="op">[</span><span class="va">img_new_arr</span><span class="op">&gt;</span><span class="fl">255</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="co">#利用r2cv函数将img_new_arr转变为图像矩阵img_new</span></span>
<span><span class="va">img_new</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_new</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_new_arr</span><span class="op">)</span></span></code></pre></div>
<p>亮度调整前后的效果：</p>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-67-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-67-2.png" width="672"></p>
<p>绘制亮度调整前后的两个图像的直方图：</p>
<div class="sourceCode" id="cb796"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">img_arr</span>,</span>
<span>     xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">255</span><span class="op">)</span>,</span>
<span>     breaks <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,</span>
<span>     col <span class="op">=</span> <span class="st">"cornsilk"</span>,main<span class="op">=</span><span class="st">""</span>,xlab<span class="op">=</span><span class="st">""</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span></span>
<span>  <span class="va">img_new_arr</span>,</span>
<span>  breaks <span class="op">=</span> <span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,</span>
<span>  col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">255</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">125</span>, maxColorValue <span class="op">=</span> <span class="fl">255</span><span class="op">)</span>,</span>
<span>  xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">255</span><span class="op">)</span>,</span>
<span>  add <span class="op">=</span> <span class="cn">T</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-68-1.png" width="672"></div>
<p>可以看到，原始图像的峰值出现在左侧，所以颜色偏暗，而调整后的图像的直方图向右侧移动了50，所以亮度增加了。</p>
<p><strong>示例</strong></p>
<p>以下代码将一个曝光不足的图像（即图像偏暗）的对比度增加：</p>
<div class="sourceCode" id="cb797"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">'images/flower_lessdose.jpg'</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数将img转变为R语言的数组img_arr</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#img.arr的每个元素值都乘以2.2，得到img_new_arr</span></span>
<span><span class="va">img_new_arr</span> <span class="op">=</span> <span class="fl">2.2</span><span class="op">*</span><span class="va">img_arr</span></span>
<span><span class="co">#img_new_arr中元素值小于0的取0，大于255的取255</span></span>
<span><span class="va">img_new_arr</span><span class="op">[</span><span class="va">img_new_arr</span><span class="op">&lt;</span><span class="fl">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="va">img_new_arr</span><span class="op">[</span><span class="va">img_new_arr</span><span class="op">&gt;</span><span class="fl">255</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span></span>
<span><span class="co">#利用r2cv函数将img_new_arr转变为图像矩阵img_new</span></span>
<span><span class="va">img_new</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_new</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_new_arr</span><span class="op">)</span></span></code></pre></div>
<p>对比度调整前后的效果：</p>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-70-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-70-2.png" width="672"></p>
<p>绘制对比度调整前后的两个图像的直方图：</p>
<div class="sourceCode" id="cb798"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">img_arr</span>,breaks<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,main<span class="op">=</span><span class="st">"调整前的直方图"</span>,xlab<span class="op">=</span><span class="st">""</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">img_new_arr</span>,breaks<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,main<span class="op">=</span><span class="st">"调整后的直方图"</span>,xlab<span class="op">=</span><span class="st">""</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-71-1.png" width="672"></div>
<div class="sourceCode" id="cb799"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span><span class="va">op</span><span class="op">)</span></span></code></pre></div>
<p><strong>示例</strong></p>
<p>以下代码将一个曝光不足的图像（即图像偏暗）的对比度和亮度同时增加：</p>
<div class="sourceCode" id="cb800"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">'images/flower_lessdose.jpg'</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数将img转变为R语言的数组img_arr</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#img_arr的每个元素值都乘以2.2并加上50，得到img_new_arr</span></span>
<span><span class="va">img_new_arr</span> <span class="op">=</span> <span class="fl">2.2</span><span class="op">*</span><span class="va">img_arr</span><span class="op">+</span><span class="fl">50</span></span>
<span><span class="co">#img.new.arr中元素值小于0的取0，大于255的取255</span></span>
<span><span class="va">img_new_arr</span><span class="op">[</span><span class="va">img_new_arr</span><span class="op">&lt;</span><span class="fl">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="va">img_new_arr</span><span class="op">[</span><span class="va">img_new_arr</span><span class="op">&gt;</span><span class="fl">255</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span></span>
<span><span class="co">#利用r2cv函数将img.new.arr转变为图像矩阵img_new</span></span>
<span><span class="va">img_new</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_new</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_new_arr</span><span class="op">)</span></span></code></pre></div>
<p>调整前后的效果：</p>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-73-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-73-2.png" width="672"></p>
<p>绘制调整前后的两个图像的直方图：</p>
<div class="sourceCode" id="cb801"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">img_arr</span>,breaks<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,main<span class="op">=</span><span class="st">"调整前的直方图"</span>,xlab<span class="op">=</span><span class="st">""</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">img_new_arr</span>,breaks<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,main<span class="op">=</span><span class="st">"调整后的直方图"</span>,xlab<span class="op">=</span><span class="st">""</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-74-1.png" width="672"></div>
<div class="sourceCode" id="cb802"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span><span class="va">op</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="采用非线性运算方式伽马校正" class="section level3" number="5.9.2">
<h3>
<span class="header-section-number">5.9.2</span> 采用非线性运算方式：伽马校正<a class="anchor" aria-label="anchor" href="#%E9%87%87%E7%94%A8%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97%E6%96%B9%E5%BC%8F%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3"><i class="fas fa-link"></i></a>
</h3>
<p>Gamma校正可用于通过使用输入值和映射输出值之间的非线性变换来校正图像的亮度：</p>
<p><span class="math display">\[
O= \left( \frac {I}{255} \right) ^ \gamma \times 255
\]</span></p>
<!-- 由于这种关系是非线性的，因此对所有像素的效果都不相同，而是取决于它们的原始值。 -->
<!-- ```{r eval=FALSE,echo=FALSE} -->
<!-- gammaCorFunc = function(x,g){ -->
<!--   (x/255)^g*255 -->
<!-- } -->
<!-- x = seq(0,250,length=500) -->
<!-- g = c(0.04,0.1,0.2,0.4,0.67,1,1.5,2.5,5.0,10.0) -->
<!-- cols = rainbow(length()) -->
<!-- plot(0:250,type="n") -->
<!-- for(i in 1:length(g)){ -->
<!--   lines(x,gammaCorFunc(x,g[i]),col=cols[i]) -->
<!--   text(250/length(g)*i,gammaCorFunc(250/length(g)*i,g[i]),paste0(expression(gamma),"=",g[i]),col=cols[i]) -->
<!-- } -->
<!-- ``` -->
<div class="inline-figure"><img src="images/tutorial/Basic_Linear_Transform_Tutorial_gamma.png"></div>
<p>当<span class="math inline">\(\gamma&lt;1\)</span>，原来的暗区域将变亮，相应颜色直方图将向右移动，当<span class="math inline">\(\gamma&gt;1\)</span>时，则相反.</p>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb803"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#定义伽马校正函数</span></span>
<span><span class="va">gammaCorFunc</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">I</span>,<span class="va">gamma</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="op">(</span><span class="va">I</span><span class="op">/</span><span class="fl">255</span><span class="op">)</span><span class="op">^</span><span class="va">gamma</span><span class="op">*</span><span class="fl">255</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">'images/flower_lessdose.jpg'</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数将img转变为R语言的数组img_arr</span></span>
<span><span class="va">img_arr</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#img_arr的每个元素值都应用伽马校正，得到img_new_arr</span></span>
<span><span class="va">img_new_arr</span> <span class="op">=</span> <span class="fu">gammaCorFunc</span><span class="op">(</span><span class="va">img_arr</span>,<span class="fl">0.4</span><span class="op">)</span></span>
<span><span class="co">#img_new_arr中元素值小于0的取0，大于255的取255</span></span>
<span><span class="va">img_new_arr</span><span class="op">[</span><span class="va">img_new_arr</span><span class="op">&lt;</span><span class="fl">0</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="va">img_new_arr</span><span class="op">[</span><span class="va">img_new_arr</span><span class="op">&gt;</span><span class="fl">255</span><span class="op">]</span> <span class="op">=</span> <span class="fl">255</span></span>
<span><span class="co">#利用r2cv函数将img_new_arr转变为图像矩阵img.</span></span>
<span><span class="va">img_new</span> <span class="op">=</span> <span class="va">img</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img_new</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_new_arr</span><span class="op">)</span></span></code></pre></div>
<p>调整前后的效果：</p>
<p><img src="06-coremodule_files/figure-html/unnamed-chunk-76-1.png" width="672"><img src="06-coremodule_files/figure-html/unnamed-chunk-76-2.png" width="672"></p>
<p>绘制调整前后的两个图像的直方图：</p>
<div class="sourceCode" id="cb804"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">img_arr</span>,breaks<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,main<span class="op">=</span><span class="st">"调整前的直方图"</span>,xlab<span class="op">=</span><span class="st">""</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="va">img_new_arr</span>,breaks<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">255</span>,main<span class="op">=</span><span class="st">"调整后的直方图"</span>,xlab<span class="op">=</span><span class="st">""</span>,ylab<span class="op">=</span><span class="st">""</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-77-1.png" width="672"></div>
<div class="sourceCode" id="cb805"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span><span class="va">op</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div id="拆分或者合并图像通道" class="section level2" number="5.10">
<h2>
<span class="header-section-number">5.10</span> 拆分或者合并图像通道<a class="anchor" aria-label="anchor" href="#%E6%8B%86%E5%88%86%E6%88%96%E8%80%85%E5%90%88%E5%B9%B6%E5%9B%BE%E5%83%8F%E9%80%9A%E9%81%93"><i class="fas fa-link"></i></a>
</h2>
<div class="sourceCode" id="cb806"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读取图像文件</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">'images/flower_lessdose.jpg'</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#拆分img的3个通道（得到的结果就是蓝色、绿色和红色分量矩阵）</span></span>
<span><span class="va">bgr</span> <span class="op">=</span> <span class="fu">stdVecOfMat</span><span class="op">(</span><span class="va">img</span><span class="op">$</span><span class="fu">channels</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">cv_split</span><span class="op">(</span><span class="va">img</span>,<span class="va">bgr</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看bgr</span></span>
<span><span class="va">bgr</span></span></code></pre></div>
<pre><code>## C++ object &lt;0000023cc90f86e0&gt; of class 'stdVectorOfMat' &lt;0000023cc77de9f0&gt;</code></pre>
<div class="sourceCode" id="cb808"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bgr</span><span class="op">$</span><span class="fu">size</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode" id="cb810"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">matImgPlot</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">bgr</span><span class="op">[[</span><span class="fl">0</span><span class="op">]</span><span class="op">]</span>,<span class="va">bgr</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">bgr</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-78-1.png" width="672"></div>
<div class="sourceCode" id="cb811"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">img1_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">img2_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">11</span><span class="op">:</span><span class="fl">19</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="va">img1</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img1_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img1</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img1</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img1_mat</span><span class="op">)</span></span>
<span><span class="va">img2</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/attr.html">attr</a></span><span class="op">(</span><span class="va">img2_mat</span>,<span class="st">"depth"</span><span class="op">)</span> <span class="op">=</span> <span class="va">img2</span><span class="op">$</span><span class="fu">depth</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">img2</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img2_mat</span><span class="op">)</span></span>
<span><span class="va">mv</span> <span class="op">=</span> <span class="fu">stdVecOfMat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">mv</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">img1</span><span class="op">)</span></span>
<span><span class="va">mv</span><span class="op">$</span><span class="fu">push_back</span><span class="op">(</span><span class="va">img2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_merge</span><span class="op">(</span><span class="va">mv</span>,<span class="va">img</span><span class="op">)</span></span>
<span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]   11   14   17
## [2,]   12   15   18
## [3,]   13   16   19
## 
## attr(,"depth")
## [1] 0</code></pre>
</div>
<div id="离散傅里叶变换dft" class="section level2" number="5.11">
<h2>
<span class="header-section-number">5.11</span> 离散傅里叶变换（DFT）<a class="anchor" aria-label="anchor" href="#%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2dft"><i class="fas fa-link"></i></a>
</h2>
<p>图像的离散傅里叶变换（DFT）公式如下：</p>
<p><span class="math display">\[
\begin{aligned}
F(k,l)&amp;=\sum_{i=0}^{N-1} \sum_{j=0}^{N-1} f(i,j)e^{-i2\pi \left( {\frac {k\times i}{N}} + {\frac {l\times j} {N}}  \right)} \\
e^{ix}&amp;=cosx+isinx
\end{aligned}
\]</span></p>
<p>这里<span class="math inline">\(f\)</span>是空间域中的图像，<span class="math inline">\(F\)</span>是频率域中的图像，变换后的结果是复数。</p>
<p>以下代码演示了该公式的实现情形：</p>
<div class="sourceCode" id="cb813"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#获取矩阵img_mat的行数和列数</span></span>
<span><span class="va">M</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="va">N</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span><span class="co">#初始化两个矩阵：realPart和imgPart，用来分别存放变换后的实数部分和虚数部分</span></span>
<span><span class="va">realPart</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="va">M</span>,nc<span class="op">=</span><span class="va">N</span><span class="op">)</span></span>
<span><span class="va">imgPart</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>,nr<span class="op">=</span><span class="va">M</span>,nc<span class="op">=</span><span class="va">N</span><span class="op">)</span></span>
<span><span class="co">#生成两个矩阵：cpos和rpos，分别体现矩阵各个元素的行、列位置</span></span>
<span><span class="va">rpos</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="va">M</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,times<span class="op">=</span><span class="va">N</span><span class="op">)</span>,nr<span class="op">=</span><span class="va">M</span>,nc<span class="op">=</span><span class="va">N</span><span class="op">)</span></span>
<span><span class="va">cpos</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,each<span class="op">=</span><span class="va">M</span><span class="op">)</span>,nr<span class="op">=</span><span class="va">M</span>,nc<span class="op">=</span><span class="va">N</span><span class="op">)</span></span>
<span><span class="co">#按照公式，计算每个k、l对应的离散傅里叶变换结果（实数、虚数分开计算）</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">k</span> <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="va">M</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="kw">for</span><span class="op">(</span><span class="va">l</span> <span class="kw">in</span> <span class="fl">0</span><span class="op">:</span><span class="op">(</span><span class="va">N</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">realPart</span><span class="op">[</span><span class="va">k</span><span class="op">+</span><span class="fl">1</span>,<span class="va">l</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="va">img_mat</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html">cos</a></span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">pi</span><span class="op">*</span><span class="op">(</span><span class="va">k</span><span class="op">*</span><span class="va">rpos</span><span class="op">/</span><span class="va">M</span><span class="op">+</span><span class="va">l</span><span class="op">*</span><span class="va">cpos</span><span class="op">/</span><span class="va">N</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> </span>
<span>    <span class="va">imgPart</span><span class="op">[</span><span class="va">k</span><span class="op">+</span><span class="fl">1</span>,<span class="va">l</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html">sum</a></span><span class="op">(</span><span class="op">-</span><span class="va">img_mat</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html">sin</a></span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">pi</span><span class="op">*</span><span class="op">(</span><span class="va">k</span><span class="op">*</span><span class="va">rpos</span><span class="op">/</span><span class="va">M</span><span class="op">+</span><span class="va">l</span><span class="op">*</span><span class="va">cpos</span><span class="op">/</span><span class="va">N</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="co">#查看转换后的实数和虚数结果（保留两位小数）</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">realPart</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1]  [,2]  [,3]
## [1,] 45.0 -13.5 -13.5
## [2,] -4.5   0.0   0.0
## [3,] -4.5   0.0   0.0</code></pre>
<div class="sourceCode" id="cb815"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">imgPart</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##      [,1] [,2]  [,3]
## [1,]  0.0 7.79 -7.79
## [2,]  2.6 0.00  0.00
## [3,] -2.6 0.00  0.00</code></pre>
<p>可以直接使用OpenCV中封装的离散傅里叶变换函数dft：</p>
<div class="sourceCode" id="cb817"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#生成3行3列的矩阵</span></span>
<span><span class="va">img_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">9</span>,nr<span class="op">=</span><span class="fl">3</span>,nc<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#利用r2cv函数将img.mat转变为图像矩阵img</span></span>
<span><span class="va">img</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="fl">3</span>,<span class="fl">3</span>,<span class="va">CV_8UC1</span><span class="op">)</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">img_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将img的深度由8位无符号整数转变32位浮点数</span></span>
<span><span class="va">img</span><span class="op">$</span><span class="fu">convertTo</span><span class="op">(</span><span class="va">img</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="co">#对img进行离散傅里叶变换，变换结果保存在complexI中</span></span>
<span><span class="va">complexI</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_dft</span><span class="op">(</span><span class="va">img</span>,<span class="va">complexI</span>,<span class="va">DFT_COMPLEX_OUTPUT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#查看变换结果（保留两位小数）</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">complexI</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span>,<span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>## , , 1
## 
##      [,1]  [,2]  [,3]
## [1,] 45.0 -13.5 -13.5
## [2,] -4.5   0.0   0.0
## [3,] -4.5   0.0   0.0
## 
## , , 2
## 
##      [,1] [,2]  [,3]
## [1,]  0.0 7.79 -7.79
## [2,]  2.6 0.00  0.00
## [3,] -2.6 0.00  0.00
## 
## attr(,"depth")
## [1] 5</code></pre>
<p><strong>基本步骤</strong></p>
<p>离散傅里叶变换遵循的如下步骤：</p>
<p><a href="https://zhuanlan.zhihu.com/p/99605178" class="uri">https://zhuanlan.zhihu.com/p/99605178</a></p>
<div class="inline-figure"><img src="images/fftsample.png"></div>
<ul>
<li>
<p>将图像扩展到最佳大小</p>
<p>DFT的性能取决于图像的大小。当图像大小是2，3和5的倍数时，DFT能过获得最快的处理速度。因此，为了获得最大的性能，通常需要扩展图像的边界以确保图像尺寸达到最佳大小。<strong>getoptimizedftsize</strong>函数可以返回这个最佳大小，然后可以使用<strong>copyMakeBorder</strong>函数以BORDER_CONSTANT方式扩展边缘（扩展像素初始化为零）。</p>
</li>
<li>
<p>将图像的深度转变为32位浮点数</p>
<p>傅立叶变换的结果是复数。这意味着对于每个像素值，DFT变换的结果包含实部和虚部两部分。而且，频域的取值范围比空间的取值范围(只有0到255共256个值）大得多。这时，我们需要至少用浮点格式来存储这些数据。因此，我们将把输入图像的矩阵转换为浮点类型，而且还要再扩展一个通道，以保存复数值（实部和虚部各需要一个通道）。</p>
</li>
<li><p>进行离散傅里叶变换，获得实部矩阵和虚部矩阵</p></li>
<li>
<p>通过实部矩阵和虚部矩阵计算模矩阵</p>
<p>模矩阵按如下公式计算：</p>
<p><span class="math display">\[
M = \sqrt[2] {Re^2+Im^2}
\]</span>
其中：</p>
<p><span class="math inline">\(Re\)</span>和<span class="math inline">\(Im\)</span>分表表示离散傅里叶变换形成的实部矩阵和虚部矩阵</p>
</li>
<li>
<p>对模矩阵取自然对数</p>
<p>查看使用离散傅里叶变换所产生的复数，会发现这些复数的模的取值范围太大，无法在屏幕上显示 —— 可以通过对数变换，将一些过小的值和一些过高的值相应地转变为白点和黑点。</p>
</li>
<li>
<p>频谱中心化</p>
<p>以模矩阵中心点为原点，以中心点所在的行和列为横轴和纵轴，使得模矩阵在坐标系的四个象限中各有1/4部分。对调第一、第三象限部分，以及对调第二、第四象限部分，可以完成频谱中心化操作。</p>
</li>
<li>
<p>标准化（归一化）</p>
<p>利用最小最大化归一化方法，将模矩阵的所有元素转变为[0,1]区间上的数。</p>
<p>最终的模矩阵的图像如下图所示：</p>
<div class="inline-figure"><img src="images/fftsampleMag.png"></div>
<p>图中的每一个点：</p>
<ul>
<li>它到中心点的距离描述的是频率<br>
</li>
<li>中心点到它的方向，是平面波的方向(可以删除)<br>
</li>
<li>该点的像素值描述的是它的幅值</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<div class="sourceCode" id="cb819"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#读入图像文件（按灰度模式读入）</span></span>
<span><span class="va">I</span> <span class="op">=</span> <span class="fu">cv_imread</span><span class="op">(</span><span class="st">"images/period_input1.jpg"</span>,<span class="va">IMREAD_GRAYSCALE</span><span class="op">)</span></span>
<span><span class="co">#获取图像的基本信息</span></span>
<span><span class="va">I_info</span> <span class="op">=</span> <span class="fu">rcv_matInfo</span><span class="op">(</span><span class="va">I</span><span class="op">)</span></span>
<span><span class="co">#依据图像现有高度和宽度获取适合DFT算法的优化高度和宽度值</span></span>
<span><span class="va">m</span> <span class="op">=</span> <span class="fu">cv_getOptimalDFTSize</span><span class="op">(</span><span class="va">I_info</span><span class="op">$</span><span class="va">height</span><span class="op">)</span></span>
<span><span class="va">n</span> <span class="op">=</span> <span class="fu">cv_getOptimalDFTSize</span><span class="op">(</span><span class="va">I_info</span><span class="op">$</span><span class="va">width</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#将I赋值给padded</span></span>
<span><span class="va">padded</span> <span class="op">=</span> <span class="va">I</span></span>
<span><span class="co">#如果优化高度不等于原图像高度，或者优化宽度不等于原图像宽度，则扩充边缘</span></span>
<span><span class="kw">if</span><span class="op">(</span><span class="va">m</span><span class="op">!=</span><span class="va">I_info</span><span class="op">$</span><span class="va">height</span> <span class="op">||</span> <span class="va">n</span><span class="op">!=</span><span class="va">I_info</span><span class="op">$</span><span class="va">width</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="fu">cv_copyMakeBorder</span><span class="op">(</span><span class="va">I</span>,<span class="va">padded</span>,</span>
<span>                    <span class="fl">0</span>,<span class="va">m</span><span class="op">-</span><span class="va">I_info</span><span class="op">$</span><span class="va">height</span>,<span class="fl">0</span>,<span class="va">n</span><span class="op">-</span><span class="va">I_info</span><span class="op">$</span><span class="va">width</span>,</span>
<span>                    <span class="va">BORDER_CONSTANT</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#将padded的深度从8位无符号整数转变为32位浮点数</span></span>
<span><span class="va">padded</span><span class="op">$</span><span class="fu">convertTo</span><span class="op">(</span><span class="va">padded</span>,<span class="va">CV_32F</span><span class="op">)</span></span>
<span><span class="co">#对padded进行离散傅里叶变换，变换结果保存在complexI中</span></span>
<span><span class="va">complexI</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_dft</span><span class="op">(</span><span class="va">padded</span>,<span class="va">complexI</span>,<span class="va">DFT_COMPLEX_OUTPUT</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#拆分complexI的通道</span></span>
<span><span class="co">#拆分得到的planes包含两个矩阵：第一个矩阵存储实数部分，第二个矩阵存储虚数部分</span></span>
<span><span class="va">planes</span> <span class="op">=</span> <span class="fu">stdVecOfMat</span><span class="op">(</span><span class="va">complexI</span><span class="op">$</span><span class="fu">channels</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu">cv_split</span><span class="op">(</span><span class="va">complexI</span>,<span class="va">planes</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#计算幅值</span></span>
<span><span class="va">magI</span> <span class="op">=</span> <span class="fu">Mat</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">cv_magnitude</span><span class="op">(</span><span class="va">planes</span><span class="op">[[</span><span class="fl">0</span><span class="op">]</span><span class="op">]</span>,<span class="va">planes</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,<span class="va">magI</span><span class="op">)</span></span>
<span><span class="co">#利用cv2r函数将magI转变为R语言的矩阵magI_mat</span></span>
<span><span class="va">magI_mat</span> <span class="op">=</span> <span class="va">magI</span><span class="op">$</span><span class="fu">cv2r</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#给magI_mat的每个元素加上1，便于取对数</span></span>
<span><span class="va">magI_mat</span> <span class="op">=</span> <span class="va">magI_mat</span><span class="op">+</span><span class="fl">1</span></span>
<span><span class="co">#对magI_mat的每个元素取自然对数</span></span>
<span><span class="va">magI_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">magI_mat</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#计算magI_mat的中心点所在的行、列位置</span></span>
<span><span class="va">cy</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">magI_mat</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span></span>
<span><span class="va">cx</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html">ncol</a></span><span class="op">(</span><span class="va">magI_mat</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span></span>
<span></span>
<span><span class="co">#依据中心点行、列位置为水平轴和竖直轴，将magI_mat划分为四个区域</span></span>
<span><span class="co">#q1为左上区域</span></span>
<span><span class="va">q1</span> <span class="op">=</span> <span class="va">magI_mat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">cy</span>,<span class="fl">1</span><span class="op">:</span><span class="va">cx</span><span class="op">]</span></span>
<span><span class="co">#q2为左下区域</span></span>
<span><span class="va">q2</span> <span class="op">=</span> <span class="va">magI_mat</span><span class="op">[</span><span class="op">(</span><span class="va">cy</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cy</span><span class="op">)</span>,<span class="fl">1</span><span class="op">:</span><span class="va">cx</span><span class="op">]</span></span>
<span><span class="co">#q3为右下区域</span></span>
<span><span class="va">q3</span> <span class="op">=</span> <span class="va">magI_mat</span><span class="op">[</span><span class="op">(</span><span class="va">cy</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cy</span><span class="op">)</span>,<span class="op">(</span><span class="va">cx</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cx</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="co">#q4为右上区域</span></span>
<span><span class="va">q4</span> <span class="op">=</span> <span class="va">magI_mat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">cy</span>,<span class="op">(</span><span class="va">cx</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cx</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#频谱中心化</span></span>
<span><span class="co">#先交换q1与q3</span></span>
<span><span class="va">magI_mat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">cy</span>,<span class="fl">1</span><span class="op">:</span><span class="va">cx</span><span class="op">]</span> <span class="op">=</span> <span class="va">q3</span></span>
<span><span class="va">magI_mat</span><span class="op">[</span><span class="op">(</span><span class="va">cy</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cy</span><span class="op">)</span>,<span class="op">(</span><span class="va">cx</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cx</span><span class="op">)</span><span class="op">]</span> <span class="op">=</span> <span class="va">q1</span></span>
<span><span class="co">#再交换q2与q4</span></span>
<span><span class="va">magI_mat</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="va">cy</span>,<span class="op">(</span><span class="va">cx</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cx</span><span class="op">)</span><span class="op">]</span> <span class="op">=</span> <span class="va">q2</span></span>
<span><span class="va">magI_mat</span><span class="op">[</span><span class="op">(</span><span class="va">cy</span><span class="op">+</span><span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="op">(</span><span class="fl">2</span><span class="op">*</span><span class="va">cy</span><span class="op">)</span>,<span class="fl">1</span><span class="op">:</span><span class="va">cx</span><span class="op">]</span> <span class="op">=</span> <span class="va">q4</span></span>
<span></span>
<span><span class="co">#自定义归一化函数，实现最大最小归一化</span></span>
<span><span class="va">myScale</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">m</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="op">(</span><span class="va">m</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co">#对magI.mat进行最小最大归一化</span></span>
<span><span class="va">magI_mat_norm</span> <span class="op">=</span> <span class="fu">myScale</span><span class="op">(</span><span class="va">magI_mat</span><span class="op">)</span></span>
<span><span class="co">#利用r2cv函数将magI_mat转变为图像矩阵</span></span>
<span><span class="co"># attr(magI_mat_norm,"depth")</span></span>
<span><span class="va">magI</span><span class="op">$</span><span class="fu">r2cv</span><span class="op">(</span><span class="va">magI_mat_norm</span><span class="op">)</span></span>
<span><span class="co">#显示magI</span></span>
<span><span class="fu">cv_imshow</span><span class="op">(</span><span class="st">'img'</span>,<span class="va">magI</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-84-1.png" width="672"></div>
<p>把上面代码的图像文件改为cat_roate.jpg，然后按照DFT的步骤运行相关代码，会发现：当图像旋转之后，离散傅里叶变换后的结果也会体现出对应的旋转效果。</p>
<div class="inline-figure"><img src="06-coremodule_files/figure-html/unnamed-chunk-86-1.png" width="672"></div>
</div>
<div id="使用xml和yaml文件进行文件输入和输出" class="section level2" number="5.12">
<h2>
<span class="header-section-number">5.12</span> 使用XML和YAML文件进行文件输入和输出<a class="anchor" aria-label="anchor" href="#%E4%BD%BF%E7%94%A8xml%E5%92%8Cyaml%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><i class="fas fa-link"></i></a>
</h2>
<div id="xml文件处理" class="section level3" number="5.12.1">
<h3>
<span class="header-section-number">5.12.1</span> XML文件处理<a class="anchor" aria-label="anchor" href="#xml%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb820"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#使用XML工具包解析xml格式的字符串</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://www.omegahat.net/RSXML/">XML</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">tt</span> <span class="op">=</span></span>
<span><span class="st">'</span></span>
<span><span class="st">&lt;x&gt;</span></span>
<span><span class="st">  &lt;a&gt;text&lt;/a&gt;</span></span>
<span><span class="st">    &lt;b foo="1"/&gt;</span></span>
<span><span class="st">    &lt;c bar="me"&gt;</span></span>
<span><span class="st">      &lt;d&gt;a phrase&lt;/d&gt;</span></span>
<span><span class="st">    &lt;/c&gt;</span></span>
<span><span class="st">&lt;/x&gt;</span></span>
<span><span class="st">'</span></span>
<span><span class="va">doc</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlTreeParse.html">xmlParse</a></span><span class="op">(</span><span class="va">tt</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlToList.html">xmlToList</a></span><span class="op">(</span><span class="va">doc</span><span class="op">)</span></span></code></pre></div>
<pre><code>## $a
## [1] "text"
## 
## $b
## foo 
## "1" 
## 
## $c
## $c$d
## [1] "a phrase"
## 
## $c$.attrs
##  bar 
## "me"</code></pre>
<div class="sourceCode" id="cb822"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># use an R-level node representation</span></span>
<span><span class="va">doc</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlTreeParse.html">xmlTreeParse</a></span><span class="op">(</span><span class="va">tt</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlToList.html">xmlToList</a></span><span class="op">(</span><span class="va">doc</span><span class="op">)</span></span></code></pre></div>
<pre><code>## $a
## [1] "text"
## 
## $b
## foo 
## "1" 
## 
## $c
## $c$d
## [1] "a phrase"
## 
## $c$.attrs
##  bar 
## "me"</code></pre>
<div class="sourceCode" id="cb824"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 读取并解析XML文件</span></span>
<span><span class="va">xmlfile</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlTreeParse.html">xmlParse</a></span><span class="op">(</span><span class="st">"data/book.xml"</span>,encoding<span class="op">=</span><span class="st">"UTF-8"</span><span class="op">)</span> </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">xmlfile</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#形成根目录列表数据</span></span>
<span><span class="va">xmltop</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlRoot.html">xmlRoot</a></span><span class="op">(</span><span class="va">xmlfile</span><span class="op">)</span> </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">xmltop</span><span class="op">)</span> <span class="co">#查看类</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlName.html">xmlName</a></span><span class="op">(</span><span class="va">xmltop</span><span class="op">)</span> <span class="co">#查看根目录名</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlSize.html">xmlSize</a></span><span class="op">(</span><span class="va">xmltop</span><span class="op">)</span> <span class="co">#查看根目录总数</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlName.html">xmlName</a></span><span class="op">(</span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span> <span class="co">#查看子目录名</span></span>
<span></span>
<span><span class="co"># 查看第一个子目录</span></span>
<span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="co"># 查看第二个子目录</span></span>
<span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#子目录节点</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlSize.html">xmlSize</a></span><span class="op">(</span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span> <span class="co">#子目录节点数</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlApply.html">xmlSApply</a></span><span class="op">(</span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, <span class="va">xmlName</span><span class="op">)</span> <span class="co">#子目录节点名</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlApply.html">xmlSApply</a></span><span class="op">(</span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, <span class="va">xmlAttrs</span><span class="op">)</span> <span class="co">#子目录节点属性</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlApply.html">xmlSApply</a></span><span class="op">(</span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, <span class="va">xmlSize</span><span class="op">)</span> <span class="co">#子目录节点大小</span></span>
<span></span>
<span><span class="co">#查看第一个子目录的第一个节点</span></span>
<span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="co">#查看第一个子目录的第二个节点</span></span>
<span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span>
<span></span>
<span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="co">#查看书的第一章第一节名称</span></span>
<span><span class="va">xmltop</span><span class="op">[[</span><span class="st">'chapter'</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="st">'section'</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="st">"title"</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>  <span class="co">#第二种方式</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/getNodeSet.html">getNodeSet</a></span><span class="op">(</span><span class="va">xmltop</span>, <span class="st">"//chapter/section"</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="co">#第三种方式</span></span>
<span></span>
<span><span class="co">#更改书的第一章第一节名称</span></span>
<span><span class="va">xmltop</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">=</span> <span class="st">"The new elements of an XML document"</span></span>
<span></span>
<span><span class="co">#保存到指定文件</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/XML/man/saveXML.html">saveXML</a></span><span class="op">(</span><span class="va">xmltop</span>,file<span class="op">=</span><span class="st">"data/out.xml"</span>,encoding <span class="op">=</span> <span class="st">"UTF-8"</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb825"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="http://had.co.nz/plyr">"plyr"</a></span><span class="op">)</span> <span class="co">#第二种方式，数据格式处理专用包plyr</span></span></code></pre></div>
<pre><code>## ------------------------------------------------------------------------------</code></pre>
<pre><code>## You have loaded plyr after dplyr - this is likely to cause problems.
## If you need functions from both plyr and dplyr, please load plyr first, then dplyr:
## library(plyr); library(dplyr)</code></pre>
<pre><code>## ------------------------------------------------------------------------------</code></pre>
<pre><code>## 
## Attaching package: 'plyr'</code></pre>
<pre><code>## The following objects are masked from 'package:dplyr':
## 
##     arrange, count, desc, failwith, id, mutate, rename, summarise,
##     summarize</code></pre>
<pre><code>## The following object is masked from 'package:purrr':
## 
##     compact</code></pre>
<div class="sourceCode" id="cb832"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">myBook</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/pkg/plyr/man/ldply.html">ldply</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/XML/man/xmlToList.html">xmlToList</a></span><span class="op">(</span><span class="st">"data/book.xml"</span><span class="op">)</span>, <span class="co">#先转成list</span></span>
<span>  <span class="va">data.frame</span> <span class="co">#再转dataframe</span></span>
<span><span class="op">)</span> </span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/View.html">View</a></span><span class="op">(</span><span class="va">myBook</span><span class="op">)</span></span></code></pre></div>
</div>
<div id="yaml文件处理" class="section level3" number="5.12.2">
<h3>
<span class="header-section-number">5.12.2</span> YAML文件处理<a class="anchor" aria-label="anchor" href="#yaml%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><i class="fas fa-link"></i></a>
</h3>
<div class="sourceCode" id="cb833"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Miachol/configr">configr</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">config</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/configr/man/read.config.html">read.config</a></span><span class="op">(</span>file<span class="op">=</span><span class="st">"data/config.yaml"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#读取config中的comments的version</span></span>
<span><span class="va">config</span><span class="op">$</span><span class="va">comments</span><span class="op">$</span><span class="va">version</span></span>
<span></span>
<span><span class="co">#修改config中的comments的version</span></span>
<span><span class="va">config</span><span class="op">$</span><span class="va">comments</span><span class="op">$</span><span class="va">version</span> <span class="op">=</span> <span class="st">"0.2.4"</span></span>
<span></span>
<span><span class="co">#保存到指定文件</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/configr/man/write.config.html">write.config</a></span><span class="op">(</span><span class="va">config</span>,file.path <span class="op">=</span> <span class="st">"data/config.new.yaml"</span>, write.type <span class="op">=</span> <span class="st">"yaml"</span><span class="op">)</span></span></code></pre></div>

</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html"><span class="header-section-number">4</span> 图像基本操作</a></div>
<div class="next"><a href="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86imgproc%E6%A8%A1%E5%9D%97-part1.html"><span class="header-section-number">6</span> 图像处理（imgproc模块-PART1）</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="header-section-number">5</span> 核心功能（核心模块）</a></li>
<li><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%83%8F%E7%B4%A0"><span class="header-section-number">5.1</span> 遍历图像矩阵的像素</a></li>
<li><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9F%A5%E8%AF%A2%E8%A1%A8"><span class="header-section-number">5.2</span> 使用查询表</a></li>
<li><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4"><span class="header-section-number">5.3</span> 计算操作时间</a></li>
<li>
<a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98"><span class="header-section-number">5.4</span> 扩展图像边缘</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#border_replicate%E6%96%B9%E5%BC%8F"><span class="header-section-number">5.4.1</span> BORDER_REPLICATE方式</a></li>
<li><a class="nav-link" href="#border_reflect%E6%96%B9%E5%BC%8F"><span class="header-section-number">5.4.2</span> BORDER_REFLECT方式</a></li>
<li><a class="nav-link" href="#border_wrap%E6%96%B9%E5%BC%8F"><span class="header-section-number">5.4.3</span> BORDER_WRAP方式</a></li>
<li><a class="nav-link" href="#border_constant%E6%96%B9%E5%BC%8F"><span class="header-section-number">5.4.4</span> BORDER_CONSTANT方式</a></li>
<li><a class="nav-link" href="#border_default%E6%88%96%E8%80%85border_reflect_101%E6%96%B9%E5%BC%8F"><span class="header-section-number">5.4.5</span> BORDER_DEFAULT或者BORDER_REFLECT_101方式</a></li>
</ul>
</li>
<li><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E6%A0%87%E5%87%86%E5%8C%96%E5%BD%92%E4%B8%80%E5%8C%96"><span class="header-section-number">5.5</span> 图像矩阵标准化/归一化</a></li>
<li><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="header-section-number">5.6</span> 图像矩阵的按位运算</a></li>
<li><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A9%E7%A0%81%E8%BF%90%E7%AE%97"><span class="header-section-number">5.7</span> 图像矩阵的掩码运算</a></li>
<li><a class="nav-link" href="#%E8%9E%8D%E5%90%88%E4%B8%A4%E4%B8%AA%E5%9B%BE%E5%83%8F"><span class="header-section-number">5.8</span> 融合两个图像</a></li>
<li>
<a class="nav-link" href="#%E6%94%B9%E5%8F%98%E5%9B%BE%E5%83%8F%E7%9A%84%E5%AF%B9%E6%AF%94%E5%BA%A6%E5%92%8C%E4%BA%AE%E5%BA%A6"><span class="header-section-number">5.9</span> 改变图像的对比度和亮度</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E9%87%87%E7%94%A8%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="header-section-number">5.9.1</span> 采用线性运算方式</a></li>
<li><a class="nav-link" href="#%E9%87%87%E7%94%A8%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%BF%90%E7%AE%97%E6%96%B9%E5%BC%8F%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3"><span class="header-section-number">5.9.2</span> 采用非线性运算方式：伽马校正</a></li>
</ul>
</li>
<li><a class="nav-link" href="#%E6%8B%86%E5%88%86%E6%88%96%E8%80%85%E5%90%88%E5%B9%B6%E5%9B%BE%E5%83%8F%E9%80%9A%E9%81%93"><span class="header-section-number">5.10</span> 拆分或者合并图像通道</a></li>
<li><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2dft"><span class="header-section-number">5.11</span> 离散傅里叶变换（DFT）</a></li>
<li>
<a class="nav-link" href="#%E4%BD%BF%E7%94%A8xml%E5%92%8Cyaml%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="header-section-number">5.12</span> 使用XML和YAML文件进行文件输入和输出</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#xml%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="header-section-number">5.12.1</span> XML文件处理</a></li>
<li><a class="nav-link" href="#yaml%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="header-section-number">5.12.2</span> YAML文件处理</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/Judy-ZQ/ROpenCV-Tutorial/blob/master/06-coremodule.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/Judy-ZQ/ROpenCV-Tutorial/edit/master/06-coremodule.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>ROpenCV — R与OpenCV之间的桥梁</strong>" was written by zpy. It was last built on 2024-11-02.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
